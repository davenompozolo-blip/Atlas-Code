{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "view-in-github",
        "colab_type": "text"
      },
      "source": [
        "<a href=\"https://colab.research.google.com/github/davenompozolo-blip/Atlas-Code/blob/main/Atlas%203%20Step%20Functioning%20Code\" target=\"_parent\"><img src=\"https://colab.research.google.com/assets/colab-badge.svg\" alt=\"Open In Colab\"/></a>"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "background_save": true,
          "base_uri": "https://localhost:8080/"
        },
        "id": "XQKO7BZrnf8k",
        "outputId": "51cb76b4-9da6-49b4-a650-230d2cc588a6"
      },
      "outputs": [
        {
          "name": "stdout",
          "output_type": "stream",
          "text": [
            "================================================================================\n",
            "üî• ATLAS TERMINAL v9.2 UNIFIED EDITION\n",
            "   Complete Portfolio Analytics + Valuation House\n",
            "   All Features Consolidated & Optimized\n",
            "================================================================================\n",
            "\n",
            "üì¶ Installing dependencies...\n",
            "‚úÖ Dependencies installed!\n",
            "\n",
            "üì° Setting up ngrok tunnel...\n",
            "\n",
            "üìù Creating ATLAS Terminal v9.2 UNIFIED...\n",
            "   ‚ú® Complete v8.8 Core Phoenix Mode\n",
            "   ‚ú® Complete v9.1 Valuation House\n",
            "   ‚ú® All modules optimized and integrated\n",
            "‚úÖ ATLAS v9.2 UNIFIED EDITION created!\n",
            "\n",
            "================================================================================\n",
            "üöÄ LAUNCHING ATLAS TERMINAL v9.2 UNIFIED EDITION\n",
            "================================================================================\n",
            "‚ú® COMPLETE CONSOLIDATION:\n",
            "  ‚úÖ All v8.8 Core Phoenix Mode Features\n",
            "  ‚úÖ Complete Valuation House DCF Engine\n",
            "  ‚úÖ 8 Modules Fully Integrated\n",
            "  ‚úÖ World-Class Visualizations Preserved\n",
            "  ‚úÖ All Enhancements Optimized\n",
            "\n",
            "üìä MODULE LIST:\n",
            "  1. Phoenix Parser\n",
            "  2. Portfolio Home\n",
            "  3. Market Watch\n",
            "  4. Risk Analysis\n",
            "  5. Performance Suite\n",
            "  6. Portfolio Deep Dive\n",
            "  7. Multi-Factor Analysis\n",
            "  8. Valuation House\n",
            "================================================================================\n",
            "\n",
            "‚úÖ ATLAS TERMINAL v9.2 UNIFIED is LIVE!\n",
            "üåê Access URL: NgrokTunnel: \"https://venus-unnauseated-superofficiously.ngrok-free.dev\" -> \"http://localhost:8501\"\n",
            "\n",
            "üéâ THE COMPLETE PLATFORM:\n",
            "   üî• Core Phoenix Mode - ALL Features\n",
            "   üíé Valuation House - Complete DCF Engine\n",
            "   üìä 8 Modules - Fully Integrated\n",
            "   üåü 150+ Features - All Preserved & Optimized\n",
            "================================================================================\n",
            "üíé THE ULTIMATE INVESTMENT ANALYSIS PLATFORM!\n",
            "üî• Everything You Need, Consolidated & Optimized!\n",
            "================================================================================\n"
          ]
        }
      ],
      "source": [
        "#!/usr/bin/env python3\n",
        "\"\"\"\n",
        "ATLAS TERMINAL v9.2 UNIFIED EDITION\n",
        "Complete Portfolio Analytics + Valuation House - All Features Consolidated\n",
        "\n",
        "UNIFIED IN v9.2:\n",
        "‚úÖ Complete v8.8 Core Phoenix Mode (all modules fully functional)\n",
        "‚úÖ Complete v9.1 Valuation House (FCFF/FCFE DCF engine)\n",
        "‚úÖ All visualizations and analytics preserved and optimized\n",
        "‚úÖ Unified navigation with all 7 modules\n",
        "‚úÖ Cross-module enhancements and optimizations\n",
        "\n",
        "COMPLETE MODULE LIST:\n",
        "1. Phoenix Parser - Exceptional data parsing\n",
        "2. Portfolio Home - Enhanced holdings analysis\n",
        "3. Market Watch - Global markets monitoring\n",
        "4. Risk Analysis - World-class risk metrics (8+ visualizations)\n",
        "5. Performance Suite - Comprehensive performance analytics\n",
        "6. Portfolio Deep Dive - Institutional-grade analysis\n",
        "7. Multi-Factor Analysis - Advanced factor attribution\n",
        "8. Valuation House - Professional DCF valuation engine\n",
        "\"\"\"\n",
        "\n",
        "import os\n",
        "import subprocess\n",
        "import sys\n",
        "import time\n",
        "from pathlib import Path\n",
        "\n",
        "print(\"=\"*80)\n",
        "print(\"üî• ATLAS TERMINAL v9.2 UNIFIED EDITION\")\n",
        "print(\"   Complete Portfolio Analytics + Valuation House\")\n",
        "print(\"   All Features Consolidated & Optimized\")\n",
        "print(\"=\"*80)\n",
        "\n",
        "# ============================================================================\n",
        "# INSTALL DEPENDENCIES\n",
        "# ============================================================================\n",
        "print(\"\\nüì¶ Installing dependencies...\")\n",
        "packages = [\n",
        "    \"streamlit\", \"yfinance\", \"plotly\", \"pandas\", \"numpy\",\n",
        "    \"scipy\", \"pyngrok\", \"openpyxl\", \"xlrd\", \"xlsxwriter\",\n",
        "    \"lxml\", \"html5lib\", \"networkx\", \"scikit-learn\", \"seaborn\",\n",
        "    \"pandas-datareader\", \"statsmodels\"\n",
        "]\n",
        "\n",
        "for pkg in packages:\n",
        "    try:\n",
        "        subprocess.check_call(\n",
        "            [sys.executable, \"-m\", \"pip\", \"install\", pkg, \"-q\"],\n",
        "            stdout=subprocess.DEVNULL,\n",
        "            stderr=subprocess.DEVNULL\n",
        "        )\n",
        "    except:\n",
        "        pass\n",
        "\n",
        "print(\"‚úÖ Dependencies installed!\")\n",
        "\n",
        "# ============================================================================\n",
        "# NGROK SETUP\n",
        "# ============================================================================\n",
        "print(\"\\nüì° Setting up ngrok tunnel...\")\n",
        "from pyngrok import ngrok\n",
        "\n",
        "ngrok.set_auth_token(\"3560NW1Q6pfr5LKXYCFxvt6JnAI_39PX8PaW3aGqhTTr2yo2M\")\n",
        "\n",
        "# ============================================================================\n",
        "# WRITE COMPLETE UNIFIED APP CODE\n",
        "# ============================================================================\n",
        "print(\"\\nüìù Creating ATLAS Terminal v9.2 UNIFIED...\")\n",
        "print(\"   ‚ú® Complete v8.8 Core Phoenix Mode\")\n",
        "print(\"   ‚ú® Complete v9.1 Valuation House\")\n",
        "print(\"   ‚ú® All modules optimized and integrated\")\n",
        "\n",
        "app_code = r'''\n",
        "\"\"\"\n",
        "ATLAS TERMINAL v9.2 UNIFIED EDITION\n",
        "The Complete Investment Analysis Platform\n",
        "\"\"\"\n",
        "\n",
        "import pickle\n",
        "import warnings\n",
        "import re\n",
        "import time\n",
        "import io\n",
        "import json\n",
        "import random\n",
        "from datetime import datetime, timedelta, date\n",
        "from pathlib import Path\n",
        "from collections import Counter, defaultdict\n",
        "import numpy as np\n",
        "import pandas as pd\n",
        "import plotly.express as px\n",
        "import plotly.graph_objects as go\n",
        "from plotly.subplots import make_subplots\n",
        "import streamlit as st\n",
        "import yfinance as yf\n",
        "from scipy import stats\n",
        "from scipy.optimize import minimize\n",
        "import networkx as nx\n",
        "from sklearn.preprocessing import StandardScaler\n",
        "from sklearn.decomposition import PCA\n",
        "from sklearn.linear_model import LinearRegression\n",
        "\n",
        "warnings.filterwarnings(\"ignore\")\n",
        "\n",
        "# ============================================================================\n",
        "# HELPER FUNCTIONS FOR VALIDATION\n",
        "# ============================================================================\n",
        "def is_valid_series(series):\n",
        "    \"\"\"Safely check if a pandas Series has valid data\"\"\"\n",
        "    return series is not None and isinstance(series, pd.Series) and not series.empty\n",
        "\n",
        "def is_valid_dataframe(df):\n",
        "    \"\"\"Safely check if a pandas DataFrame has valid data\"\"\"\n",
        "    return df is not None and isinstance(df, pd.DataFrame) and not df.empty\n",
        "\n",
        "# ============================================================================\n",
        "# PAGE CONFIG\n",
        "# ============================================================================\n",
        "st.set_page_config(\n",
        "    page_title=\"ATLAS Terminal v9.2 UNIFIED\",\n",
        "    page_icon=\"üî•\",\n",
        "    layout=\"wide\",\n",
        "    initial_sidebar_state=\"expanded\"\n",
        ")\n",
        "\n",
        "# ============================================================================\n",
        "# PROFESSIONAL THEME SYSTEM\n",
        "# ============================================================================\n",
        "\n",
        "COLORS = {\n",
        "    \"background\": \"#000000\",\n",
        "    \"card_background\": \"#0a1929\",\n",
        "    \"card_background_alt\": \"#050f17\",\n",
        "    \"neon_blue\": \"#00d4ff\",\n",
        "    \"electric_blue\": \"#0080ff\",\n",
        "    \"teal\": \"#00ffcc\",\n",
        "    \"cyan\": \"#00ffff\",\n",
        "    \"success\": \"#00ff88\",\n",
        "    \"warning\": \"#ffaa00\",\n",
        "    \"danger\": \"#ff0044\",\n",
        "    \"info\": \"#00d4ff\",\n",
        "    \"purple\": \"#b794f6\",\n",
        "    \"pink\": \"#ff00ff\",\n",
        "    \"orange\": \"#ff6b00\",\n",
        "    \"chart_primary\": \"#00d4ff\",\n",
        "    \"chart_secondary\": \"#0080ff\",\n",
        "    \"chart_accent\": \"#00ffcc\",\n",
        "    \"chart_grid\": \"#1a3a52\",\n",
        "    \"text_primary\": \"#ffffff\",\n",
        "    \"text_secondary\": \"#b0c4de\",\n",
        "    \"text_muted\": \"#6c8ca8\",\n",
        "    \"border\": \"#00d4ff\",\n",
        "    \"shadow\": \"rgba(0, 212, 255, 0.3)\",\n",
        "    \"shadow_strong\": \"rgba(0, 212, 255, 0.6)\",\n",
        "    \"gain_bg\": \"rgba(0, 255, 136, 0.15)\",\n",
        "    \"gain_text\": \"#00ff88\",\n",
        "    \"loss_bg\": \"rgba(255, 0, 68, 0.15)\",\n",
        "    \"loss_text\": \"#ff0044\",\n",
        "}\n",
        "\n",
        "COLORSCALES = {\n",
        "    \"viridis\": px.colors.sequential.Viridis,\n",
        "    \"plasma\": px.colors.sequential.Plasma,\n",
        "    \"turbo\": px.colors.sequential.Turbo,\n",
        "    \"rdylgn\": px.colors.diverging.RdYlGn,\n",
        "    \"spectral\": px.colors.diverging.Spectral,\n",
        "}\n",
        "\n",
        "# ============================================================================\n",
        "# ENHANCED CSS\n",
        "# ============================================================================\n",
        "st.markdown(f\"\"\"\n",
        "<style>\n",
        "    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;600&display=swap');\n",
        "\n",
        "    * {{\n",
        "        font-family: 'Inter', 'Segoe UI', sans-serif !important;\n",
        "    }}\n",
        "\n",
        "    @keyframes pulseGreen {{\n",
        "        0% {{ background-color: {COLORS['gain_bg']}; transform: scale(1); }}\n",
        "        50% {{ background-color: rgba(0, 255, 136, 0.25); transform: scale(1.02); }}\n",
        "        100% {{ background-color: {COLORS['gain_bg']}; transform: scale(1); }}\n",
        "    }}\n",
        "\n",
        "    @keyframes pulseRed {{\n",
        "        0% {{ background-color: {COLORS['loss_bg']}; transform: scale(1); }}\n",
        "        50% {{ background-color: rgba(255, 0, 68, 0.25); transform: scale(1.02); }}\n",
        "        100% {{ background-color: {COLORS['loss_bg']}; transform: scale(1); }}\n",
        "    }}\n",
        "\n",
        "    .main {{\n",
        "        background: linear-gradient(135deg, #000000 0%, #0a1929 100%);\n",
        "        color: {COLORS['text_primary']};\n",
        "    }}\n",
        "\n",
        "    h1 {{\n",
        "        background: linear-gradient(90deg, #00d4ff, #00ff88, #00d4ff);\n",
        "        background-clip: text;\n",
        "        -webkit-background-clip: text;\n",
        "        -webkit-text-fill-color: transparent;\n",
        "        text-shadow: 0 0 40px rgba(0,212,255,0.8);\n",
        "        font-family: 'Inter', sans-serif !important;\n",
        "        font-weight: 700 !important;\n",
        "        font-size: 3.5em !important;\n",
        "        text-align: center;\n",
        "        animation: glow 2s ease-in-out infinite alternate;\n",
        "    }}\n",
        "\n",
        "    @keyframes glow {{\n",
        "        from {{ text-shadow: 0 0 20px rgba(0,212,255,0.5); }}\n",
        "        to {{ text-shadow: 0 0 30px rgba(0,212,255,1), 0 0 40px rgba(0,255,136,0.5); }}\n",
        "    }}\n",
        "\n",
        "    div[data-testid=\"stDataFrame\"] tbody tr:hover {{\n",
        "        background: linear-gradient(90deg, rgba(0, 212, 255, 0.2) 0%, rgba(0, 212, 255, 0.1) 100%) !important;\n",
        "        transform: scale(1.02) translateX(5px);\n",
        "        box-shadow: 0 5px 20px rgba(0, 212, 255, 0.3);\n",
        "        border-left: 3px solid {COLORS['neon_blue']};\n",
        "    }}\n",
        "\n",
        "    div[data-testid=\"stDataFrame\"] thead th {{\n",
        "        background: linear-gradient(135deg, {COLORS['neon_blue']} 0%, {COLORS['electric_blue']} 100%) !important;\n",
        "        color: {COLORS['background']} !important;\n",
        "        font-weight: 700 !important;\n",
        "        font-size: 14px !important;\n",
        "        text-transform: uppercase !important;\n",
        "    }}\n",
        "\n",
        "    div[data-testid=\"stMetric\"] {{\n",
        "        background: linear-gradient(135deg, {COLORS['card_background']} 0%, {COLORS['card_background_alt']} 100%);\n",
        "        border: 2px solid {COLORS['neon_blue']};\n",
        "        border-radius: 12px;\n",
        "        padding: 20px;\n",
        "        box-shadow: 0 0 30px {COLORS['shadow']};\n",
        "        transition: all 0.3s ease;\n",
        "    }}\n",
        "\n",
        "    div[data-testid=\"stMetric\"]:hover {{\n",
        "        transform: translateY(-5px) scale(1.02);\n",
        "        box-shadow: 0 10px 40px {COLORS['shadow_strong']};\n",
        "    }}\n",
        "\n",
        "    .stSlider {{\n",
        "        padding: 10px 0px;\n",
        "    }}\n",
        "</style>\n",
        "\"\"\", unsafe_allow_html=True)\n",
        "\n",
        "# ============================================================================\n",
        "# CONSTANTS & CONFIG\n",
        "# ============================================================================\n",
        "CACHE_DIR = Path.home() / \".atlas_cache\"\n",
        "CACHE_DIR.mkdir(exist_ok=True)\n",
        "PORTFOLIO_CACHE = CACHE_DIR / \"portfolio.pkl\"\n",
        "TRADE_HISTORY_CACHE = CACHE_DIR / \"trade_history.pkl\"\n",
        "ACCOUNT_HISTORY_CACHE = CACHE_DIR / \"account_history.pkl\"\n",
        "\n",
        "RISK_FREE_RATE = 0.045\n",
        "MARKET_RETURN = 0.10\n",
        "\n",
        "# Global Market Indices\n",
        "GLOBAL_INDICES = {\n",
        "    \"^GSPC\": {\"name\": \"S&P 500\", \"region\": \"US\"},\n",
        "    \"^NDX\": {\"name\": \"Nasdaq 100\", \"region\": \"US\"},\n",
        "    \"^DJI\": {\"name\": \"Dow Jones\", \"region\": \"US\"},\n",
        "    \"^RUT\": {\"name\": \"Russell 2000\", \"region\": \"US\"},\n",
        "    \"^FTSE\": {\"name\": \"FTSE 100\", \"region\": \"UK\"},\n",
        "    \"^GDAXI\": {\"name\": \"DAX\", \"region\": \"Germany\"},\n",
        "    \"^FCHI\": {\"name\": \"CAC 40\", \"region\": \"France\"},\n",
        "    \"^STOXX50E\": {\"name\": \"Euro Stoxx 50\", \"region\": \"Europe\"},\n",
        "    \"^N225\": {\"name\": \"Nikkei 225\", \"region\": \"Japan\"},\n",
        "    \"^HSI\": {\"name\": \"Hang Seng\", \"region\": \"Hong Kong\"},\n",
        "    \"000001.SS\": {\"name\": \"Shanghai Composite\", \"region\": \"China\"},\n",
        "    \"^BSESN\": {\"name\": \"BSE Sensex\", \"region\": \"India\"},\n",
        "    \"^BVSP\": {\"name\": \"Bovespa\", \"region\": \"Brazil\"},\n",
        "    \"^AXJO\": {\"name\": \"ASX 200\", \"region\": \"Australia\"},\n",
        "    \"^GSPTSE\": {\"name\": \"TSX Composite\", \"region\": \"Canada\"}\n",
        "}\n",
        "\n",
        "# Commodities\n",
        "COMMODITIES = {\n",
        "    \"GC=F\": {\"name\": \"Gold\", \"category\": \"Precious Metals\"},\n",
        "    \"SI=F\": {\"name\": \"Silver\", \"category\": \"Precious Metals\"},\n",
        "    \"PL=F\": {\"name\": \"Platinum\", \"category\": \"Precious Metals\"},\n",
        "    \"CL=F\": {\"name\": \"Crude Oil WTI\", \"category\": \"Energy\"},\n",
        "    \"BZ=F\": {\"name\": \"Brent Crude\", \"category\": \"Energy\"},\n",
        "    \"NG=F\": {\"name\": \"Natural Gas\", \"category\": \"Energy\"},\n",
        "    \"HG=F\": {\"name\": \"Copper\", \"category\": \"Industrial Metals\"},\n",
        "    \"ZC=F\": {\"name\": \"Corn\", \"category\": \"Agriculture\"},\n",
        "    \"ZW=F\": {\"name\": \"Wheat\", \"category\": \"Agriculture\"},\n",
        "    \"ZS=F\": {\"name\": \"Soybeans\", \"category\": \"Agriculture\"},\n",
        "    \"KC=F\": {\"name\": \"Coffee\", \"category\": \"Agriculture\"},\n",
        "    \"SB=F\": {\"name\": \"Sugar\", \"category\": \"Agriculture\"},\n",
        "    \"CC=F\": {\"name\": \"Cocoa\", \"category\": \"Agriculture\"},\n",
        "    \"LE=F\": {\"name\": \"Live Cattle\", \"category\": \"Livestock\"},\n",
        "    \"GF=F\": {\"name\": \"Feeder Cattle\", \"category\": \"Livestock\"}\n",
        "}\n",
        "\n",
        "# Factor definitions\n",
        "FACTOR_DEFINITIONS = {\n",
        "    \"Market\": {\"description\": \"Market risk premium\", \"benchmark\": \"SPY\"},\n",
        "    \"Size\": {\"description\": \"Small cap minus large cap\", \"benchmark\": \"IWM\"},\n",
        "    \"Value\": {\"description\": \"Value minus growth\", \"benchmark\": \"IWD\"},\n",
        "    \"Momentum\": {\"description\": \"Winners minus losers\", \"benchmark\": \"MTUM\"},\n",
        "    \"Quality\": {\"description\": \"High quality minus low quality\", \"benchmark\": \"QUAL\"},\n",
        "    \"Volatility\": {\"description\": \"Low vol minus high vol\", \"benchmark\": \"USMV\"}\n",
        "}\n",
        "\n",
        "# ETF sectors\n",
        "ETF_SECTORS = {\n",
        "    \"QQQ\": \"Technology\", \"XLK\": \"Technology\", \"VGT\": \"Technology\",\n",
        "    \"XLF\": \"Financial Services\", \"KRE\": \"Financial Services\",\n",
        "    \"XLV\": \"Healthcare\", \"IBB\": \"Healthcare\", \"XBI\": \"Healthcare\",\n",
        "    \"XLE\": \"Energy\", \"XOP\": \"Energy\", \"USO\": \"Energy\",\n",
        "    \"XLB\": \"Basic Materials\", \"GDX\": \"Basic Materials\",\n",
        "    \"XLY\": \"Consumer Cyclical\", \"XLP\": \"Consumer Defensive\",\n",
        "    \"XLI\": \"Industrials\", \"IYT\": \"Industrials\",\n",
        "    \"VNQ\": \"Real Estate\", \"XLRE\": \"Real Estate\",\n",
        "    \"XLU\": \"Utilities\",\n",
        "    \"SPY\": \"Broad Market\", \"VOO\": \"Broad Market\", \"VTI\": \"Broad Market\"\n",
        "}\n",
        "\n",
        "# Popular ETFs\n",
        "POPULAR_ETFS = {\n",
        "    \"XLK\": {\"name\": \"Technology Select\", \"category\": \"Sector\", \"avg_volume\": 15000000},\n",
        "    \"XLF\": {\"name\": \"Financial Select\", \"category\": \"Sector\", \"avg_volume\": 50000000},\n",
        "    \"XLV\": {\"name\": \"Health Care Select\", \"category\": \"Sector\", \"avg_volume\": 10000000},\n",
        "    \"XLE\": {\"name\": \"Energy Select\", \"category\": \"Sector\", \"avg_volume\": 20000000},\n",
        "    \"XLI\": {\"name\": \"Industrial Select\", \"category\": \"Sector\", \"avg_volume\": 12000000},\n",
        "    \"ARKK\": {\"name\": \"ARK Innovation\", \"category\": \"Thematic\", \"avg_volume\": 8000000},\n",
        "    \"ARKQ\": {\"name\": \"ARK Autonomous Tech\", \"category\": \"Thematic\", \"avg_volume\": 2000000},\n",
        "    \"ICLN\": {\"name\": \"Clean Energy\", \"category\": \"Thematic\", \"avg_volume\": 5000000},\n",
        "    \"TAN\": {\"name\": \"Solar Energy\", \"category\": \"Thematic\", \"avg_volume\": 1500000},\n",
        "    \"HACK\": {\"name\": \"Cybersecurity\", \"category\": \"Thematic\", \"avg_volume\": 800000},\n",
        "}\n",
        "\n",
        "# ============================================================================\n",
        "# HELPER FUNCTIONS\n",
        "# ============================================================================\n",
        "\n",
        "def format_percentage(value, decimals=2):\n",
        "    if pd.isna(value) or value is None:\n",
        "        return \"N/A\"\n",
        "    return f\"{value:.{decimals}f}%\"\n",
        "\n",
        "def format_currency(value):\n",
        "    if pd.isna(value) or value is None:\n",
        "        return \"N/A\"\n",
        "    return f\"${value:,.2f}\"\n",
        "\n",
        "def format_large_number(value):\n",
        "    \"\"\"Format large numbers with B/M/K suffix\"\"\"\n",
        "    if pd.isna(value) or value is None:\n",
        "        return \"N/A\"\n",
        "    if abs(value) >= 1e9:\n",
        "        return f\"${value/1e9:.2f}B\"\n",
        "    elif abs(value) >= 1e6:\n",
        "        return f\"${value/1e6:.2f}M\"\n",
        "    elif abs(value) >= 1e3:\n",
        "        return f\"${value/1e3:.2f}K\"\n",
        "    return f\"${value:.2f}\"\n",
        "\n",
        "def add_arrow_indicator(value):\n",
        "    try:\n",
        "        val = float(str(value).replace('%', '').replace('$', '').replace(',', ''))\n",
        "        if val > 0:\n",
        "            return f\"‚ñ≤ {value}\"\n",
        "        elif val < 0:\n",
        "            return f\"‚ñº {value}\"\n",
        "        return f\"‚îÄ {value}\"\n",
        "    except:\n",
        "        return value\n",
        "\n",
        "# ============================================================================\n",
        "# DATA FUNCTIONS\n",
        "# ============================================================================\n",
        "\n",
        "def save_portfolio_data(data):\n",
        "    with open(PORTFOLIO_CACHE, \"wb\") as f:\n",
        "        pickle.dump(data, f)\n",
        "\n",
        "def load_portfolio_data():\n",
        "    if PORTFOLIO_CACHE.exists():\n",
        "        with open(PORTFOLIO_CACHE, \"rb\") as f:\n",
        "            return pickle.load(f)\n",
        "    return []\n",
        "\n",
        "def save_trade_history(df):\n",
        "    with open(TRADE_HISTORY_CACHE, \"wb\") as f:\n",
        "        pickle.dump(df, f)\n",
        "\n",
        "def load_trade_history():\n",
        "    if TRADE_HISTORY_CACHE.exists():\n",
        "        with open(TRADE_HISTORY_CACHE, \"rb\") as f:\n",
        "            return pickle.load(f)\n",
        "    return None\n",
        "\n",
        "def save_account_history(df):\n",
        "    with open(ACCOUNT_HISTORY_CACHE, \"wb\") as f:\n",
        "        pickle.dump(df, f)\n",
        "\n",
        "def load_account_history():\n",
        "    if ACCOUNT_HISTORY_CACHE.exists():\n",
        "        with open(ACCOUNT_HISTORY_CACHE, \"rb\") as f:\n",
        "            return pickle.load(f)\n",
        "    return None\n",
        "\n",
        "def get_leverage_info():\n",
        "    account_df = load_account_history()\n",
        "    if account_df is not None:\n",
        "        latest_cash = account_df.get('Cash Balance', account_df.get('Cash', pd.Series([0]))).iloc[-1]\n",
        "\n",
        "        if isinstance(latest_cash, str):\n",
        "            latest_cash = latest_cash.replace('$', '').replace(',', '')\n",
        "            if '(' in latest_cash and ')' in latest_cash:\n",
        "                latest_cash = '-' + latest_cash.replace('(', '').replace(')', '')\n",
        "            try:\n",
        "                latest_cash = float(latest_cash)\n",
        "            except:\n",
        "                latest_cash = 0\n",
        "\n",
        "        latest_margin = 0\n",
        "\n",
        "        if 'Margin Used' in account_df.columns:\n",
        "            latest_margin = account_df['Margin Used'].iloc[-1]\n",
        "            if isinstance(latest_margin, str):\n",
        "                latest_margin = latest_margin.replace('$', '').replace(',', '')\n",
        "                if '(' in latest_margin and ')' in latest_margin:\n",
        "                    latest_margin = '-' + latest_margin.replace('(', '').replace(')', '')\n",
        "                try:\n",
        "                    latest_margin = float(latest_margin)\n",
        "                except:\n",
        "                    latest_margin = 0\n",
        "\n",
        "        if latest_cash < 0:\n",
        "            latest_margin = abs(latest_cash)\n",
        "\n",
        "        total_value = 0\n",
        "        if 'Total Value' in account_df.columns:\n",
        "            total_value = account_df['Total Value'].iloc[-1]\n",
        "            if isinstance(total_value, str):\n",
        "                total_value = total_value.replace('$', '').replace(',', '')\n",
        "                if '(' in total_value and ')' in total_value:\n",
        "                    total_value = '-' + total_value.replace('(', '').replace(')', '')\n",
        "                try:\n",
        "                    total_value = float(total_value)\n",
        "                except:\n",
        "                    total_value = abs(latest_cash) + latest_margin\n",
        "        else:\n",
        "            total_value = abs(latest_cash) + latest_margin\n",
        "\n",
        "        leverage_ratio = (total_value / (total_value - latest_margin)) if (total_value - latest_margin) > 0 else 1\n",
        "\n",
        "        return {\n",
        "            'margin_used': latest_margin,\n",
        "            'cash_balance': latest_cash,\n",
        "            'leverage_ratio': leverage_ratio,\n",
        "            'total_value': total_value\n",
        "        }\n",
        "    return None\n",
        "\n",
        "@st.cache_data(ttl=300)\n",
        "def fetch_market_data(ticker):\n",
        "    try:\n",
        "        stock = yf.Ticker(ticker)\n",
        "        info = stock.info\n",
        "        hist = stock.history(period=\"5d\")\n",
        "        if hist.empty:\n",
        "            return None\n",
        "\n",
        "        current_price = hist['Close'].iloc[-1]\n",
        "        prev_close = hist['Close'].iloc[-2] if len(hist) > 1 else current_price\n",
        "        daily_change = current_price - prev_close\n",
        "        daily_change_pct = (daily_change / prev_close * 100) if prev_close else 0\n",
        "\n",
        "        five_day_return = ((current_price / hist['Close'].iloc[0]) - 1) * 100 if len(hist) >= 5 else 0\n",
        "\n",
        "        company_name = info.get('longName', info.get('shortName', ticker))\n",
        "\n",
        "        return {\n",
        "            \"price\": current_price,\n",
        "            \"daily_change\": daily_change,\n",
        "            \"daily_change_pct\": daily_change_pct,\n",
        "            \"five_day_return\": five_day_return,\n",
        "            \"volume\": info.get('volume', 0),\n",
        "            \"avg_volume\": info.get('averageVolume', 0),\n",
        "            \"sector\": info.get('sector', 'Unknown'),\n",
        "            \"beta\": info.get('beta', None),\n",
        "            \"market_cap\": info.get('marketCap', 0),\n",
        "            \"company_name\": company_name,\n",
        "            \"52_week_high\": info.get('fiftyTwoWeekHigh', None),\n",
        "            \"52_week_low\": info.get('fiftyTwoWeekLow', None)\n",
        "        }\n",
        "    except:\n",
        "        return None\n",
        "\n",
        "def is_option_ticker(ticker):\n",
        "    if len(ticker) <= 6:\n",
        "        return False\n",
        "    has_year = any(str(y) in ticker for y in range(2020, 2030))\n",
        "    has_strike = any(c.isdigit() for c in ticker[6:])\n",
        "    has_type = ticker[-1] in ['C', 'P'] or 'C' in ticker[6:] or 'P' in ticker[6:]\n",
        "    return has_year and has_strike and has_type\n",
        "\n",
        "def classify_ticker_sector(ticker, default_sector):\n",
        "    if pd.notna(default_sector) and default_sector != \"Unknown\":\n",
        "        return default_sector\n",
        "\n",
        "    if ticker in ETF_SECTORS:\n",
        "        return ETF_SECTORS[ticker]\n",
        "\n",
        "    return \"Other\"\n",
        "\n",
        "@st.cache_data(ttl=600)\n",
        "def fetch_historical_data(ticker, start_date, end_date):\n",
        "    try:\n",
        "        stock = yf.Ticker(ticker)\n",
        "        hist = stock.history(start=start_date, end=end_date)\n",
        "        if not hist.empty:\n",
        "            return hist\n",
        "    except:\n",
        "        pass\n",
        "    return None\n",
        "\n",
        "@st.cache_data(ttl=3600)\n",
        "def fetch_analyst_data(ticker):\n",
        "    try:\n",
        "        stock = yf.Ticker(ticker)\n",
        "        info = stock.info\n",
        "\n",
        "        rating = info.get('recommendationKey', 'none')\n",
        "        if rating == 'none' or rating is None:\n",
        "            rating = \"No Coverage\"\n",
        "\n",
        "        return {\n",
        "            'rating': rating.upper() if rating != \"No Coverage\" else rating,\n",
        "            'target_price': info.get('targetMeanPrice'),\n",
        "            'num_analysts': info.get('numberOfAnalystOpinions', 0),\n",
        "            'success': True\n",
        "        }\n",
        "    except:\n",
        "        return {'success': False, 'rating': 'No Coverage', 'target_price': None}\n",
        "\n",
        "# ============================================================================\n",
        "# VALUATION HOUSE - DATA FETCHING & CALCULATIONS\n",
        "# ============================================================================\n",
        "\n",
        "@st.cache_data(ttl=3600)\n",
        "def fetch_company_financials(ticker):\n",
        "    \"\"\"Fetch comprehensive financial data for valuation\"\"\"\n",
        "    try:\n",
        "        stock = yf.Ticker(ticker)\n",
        "        info = stock.info\n",
        "\n",
        "        # Basic company info\n",
        "        company_data = {\n",
        "            'ticker': ticker,\n",
        "            'name': info.get('longName', ticker),\n",
        "            'sector': info.get('sector', 'Unknown'),\n",
        "            'industry': info.get('industry', 'Unknown'),\n",
        "            'current_price': info.get('currentPrice', 0),\n",
        "            'market_cap': info.get('marketCap', 0),\n",
        "            'shares_outstanding': info.get('sharesOutstanding', 0),\n",
        "            'beta': info.get('beta', 1.0),\n",
        "            'forward_pe': info.get('forwardPE'),\n",
        "            'trailing_pe': info.get('trailingPE'),\n",
        "        }\n",
        "\n",
        "        # Financial statements\n",
        "        income_stmt = stock.income_stmt\n",
        "        balance_sheet = stock.balance_sheet\n",
        "        cash_flow = stock.cash_flow\n",
        "\n",
        "        # Parse financials (most recent 3 years)\n",
        "        financials = {}\n",
        "\n",
        "        if not income_stmt.empty:\n",
        "            # Get most recent year\n",
        "            latest_col = income_stmt.columns[0]\n",
        "\n",
        "            financials['revenue'] = income_stmt.loc['Total Revenue', latest_col] if 'Total Revenue' in income_stmt.index else 0\n",
        "            financials['ebit'] = income_stmt.loc['EBIT', latest_col] if 'EBIT' in income_stmt.index else 0\n",
        "            financials['net_income'] = income_stmt.loc['Net Income', latest_col] if 'Net Income' in income_stmt.index else 0\n",
        "            financials['tax_expense'] = income_stmt.loc['Tax Provision', latest_col] if 'Tax Provision' in income_stmt.index else 0\n",
        "\n",
        "            # Calculate tax rate\n",
        "            if financials['ebit'] != 0:\n",
        "                financials['tax_rate'] = abs(financials['tax_expense'] / financials['ebit'])\n",
        "            else:\n",
        "                financials['tax_rate'] = 0.21  # Default US corporate tax rate\n",
        "\n",
        "        if not balance_sheet.empty:\n",
        "            latest_col = balance_sheet.columns[0]\n",
        "\n",
        "            financials['total_debt'] = balance_sheet.loc['Total Debt', latest_col] if 'Total Debt' in balance_sheet.index else 0\n",
        "            financials['cash'] = balance_sheet.loc['Cash And Cash Equivalents', latest_col] if 'Cash And Cash Equivalents' in balance_sheet.index else 0\n",
        "            financials['total_equity'] = balance_sheet.loc['Total Equity Gross Minority Interest', latest_col] if 'Total Equity Gross Minority Interest' in balance_sheet.index else 0\n",
        "\n",
        "        if not cash_flow.empty:\n",
        "            latest_col = cash_flow.columns[0]\n",
        "\n",
        "            financials['capex'] = abs(cash_flow.loc['Capital Expenditure', latest_col]) if 'Capital Expenditure' in cash_flow.index else 0\n",
        "            financials['depreciation'] = cash_flow.loc['Depreciation And Amortization', latest_col] if 'Depreciation And Amortization' in cash_flow.index else 0\n",
        "            financials['operating_cf'] = cash_flow.loc['Operating Cash Flow', latest_col] if 'Operating Cash Flow' in cash_flow.index else 0\n",
        "\n",
        "        # Calculate working capital change (simplified)\n",
        "        financials['change_wc'] = 0  # User can adjust\n",
        "\n",
        "        return {\n",
        "            'company': company_data,\n",
        "            'financials': financials,\n",
        "            'success': True\n",
        "        }\n",
        "\n",
        "    except Exception as e:\n",
        "        return {\n",
        "            'success': False,\n",
        "            'error': str(e)\n",
        "        }\n",
        "\n",
        "def calculate_wacc(cost_equity, cost_debt, tax_rate, debt, equity):\n",
        "    \"\"\"Calculate Weighted Average Cost of Capital\"\"\"\n",
        "    total_value = debt + equity\n",
        "    if total_value == 0:\n",
        "        return cost_equity\n",
        "\n",
        "    weight_equity = equity / total_value\n",
        "    weight_debt = debt / total_value\n",
        "\n",
        "    wacc = (cost_equity * weight_equity) + (cost_debt * (1 - tax_rate) * weight_debt)\n",
        "    return wacc\n",
        "\n",
        "def calculate_cost_of_equity(risk_free_rate, beta, market_risk_premium):\n",
        "    \"\"\"Calculate Cost of Equity using CAPM\"\"\"\n",
        "    return risk_free_rate + (beta * market_risk_premium)\n",
        "\n",
        "def calculate_terminal_value(final_fcf, discount_rate, terminal_growth):\n",
        "    \"\"\"Calculate Terminal Value using Gordon Growth Model\"\"\"\n",
        "    if discount_rate <= terminal_growth:\n",
        "        return 0\n",
        "    return final_fcf * (1 + terminal_growth) / (discount_rate - terminal_growth)\n",
        "\n",
        "def project_fcff(base_ebit, revenue_growth, ebit_margin, tax_rate, depreciation,\n",
        "                 capex, change_wc, forecast_years):\n",
        "    \"\"\"Project Free Cash Flow to Firm\"\"\"\n",
        "    projections = []\n",
        "\n",
        "    current_ebit = base_ebit\n",
        "\n",
        "    for year in range(1, forecast_years + 1):\n",
        "        # Grow EBIT\n",
        "        current_ebit = current_ebit * (1 + revenue_growth)\n",
        "\n",
        "        # Calculate NOPAT\n",
        "        nopat = current_ebit * (1 - tax_rate)\n",
        "\n",
        "        # Calculate FCFF\n",
        "        fcff = nopat + depreciation - capex - change_wc\n",
        "\n",
        "        projections.append({\n",
        "            'year': year,\n",
        "            'ebit': current_ebit,\n",
        "            'nopat': nopat,\n",
        "            'depreciation': depreciation,\n",
        "            'capex': capex,\n",
        "            'change_wc': change_wc,\n",
        "            'fcff': fcff\n",
        "        })\n",
        "\n",
        "    return projections\n",
        "\n",
        "def project_fcfe(base_net_income, revenue_growth, tax_rate, depreciation,\n",
        "                 capex, change_wc, net_borrowing, forecast_years):\n",
        "    \"\"\"Project Free Cash Flow to Equity\"\"\"\n",
        "    projections = []\n",
        "\n",
        "    current_ni = base_net_income\n",
        "\n",
        "    for year in range(1, forecast_years + 1):\n",
        "        # Grow net income\n",
        "        current_ni = current_ni * (1 + revenue_growth)\n",
        "\n",
        "        # Calculate FCFE\n",
        "        fcfe = current_ni + depreciation - capex - change_wc + net_borrowing\n",
        "\n",
        "        projections.append({\n",
        "            'year': year,\n",
        "            'net_income': current_ni,\n",
        "            'depreciation': depreciation,\n",
        "            'capex': capex,\n",
        "            'change_wc': change_wc,\n",
        "            'net_borrowing': net_borrowing,\n",
        "            'fcfe': fcfe\n",
        "        })\n",
        "\n",
        "    return projections\n",
        "\n",
        "def calculate_dcf_value(projections, discount_rate, terminal_value, shares_outstanding,\n",
        "                       net_debt=0, method='FCFF'):\n",
        "    \"\"\"Calculate DCF valuation\"\"\"\n",
        "    # Discount projected cash flows\n",
        "    pv_cash_flows = []\n",
        "    total_pv = 0\n",
        "\n",
        "    for proj in projections:\n",
        "        year = proj['year']\n",
        "        cf = proj['fcff'] if method == 'FCFF' else proj['fcfe']\n",
        "        pv = cf / ((1 + discount_rate) ** year)\n",
        "        pv_cash_flows.append(pv)\n",
        "        total_pv += pv\n",
        "\n",
        "    # Discount terminal value\n",
        "    pv_terminal = terminal_value / ((1 + discount_rate) ** len(projections))\n",
        "\n",
        "    # Calculate enterprise/equity value\n",
        "    enterprise_value = total_pv + pv_terminal\n",
        "\n",
        "    if method == 'FCFF':\n",
        "        # For FCFF, subtract net debt to get equity value\n",
        "        equity_value = enterprise_value - net_debt\n",
        "    else:\n",
        "        # For FCFE, enterprise value IS equity value\n",
        "        equity_value = enterprise_value\n",
        "\n",
        "    # Calculate per share value\n",
        "    intrinsic_value_per_share = equity_value / shares_outstanding if shares_outstanding > 0 else 0\n",
        "\n",
        "    return {\n",
        "        'pv_cash_flows': pv_cash_flows,\n",
        "        'total_pv_cash_flows': total_pv,\n",
        "        'terminal_value': terminal_value,\n",
        "        'pv_terminal': pv_terminal,\n",
        "        'enterprise_value': enterprise_value,\n",
        "        'equity_value': equity_value,\n",
        "        'intrinsic_value_per_share': intrinsic_value_per_share\n",
        "    }\n",
        "\n",
        "# ============================================================================\n",
        "# PHOENIX PARSER\n",
        "# ============================================================================\n",
        "\n",
        "def parse_trade_history_file(uploaded_file):\n",
        "    try:\n",
        "        df = pd.read_html(uploaded_file)[0]\n",
        "        required_cols = ['Date', 'Symbol', 'Trade Type', 'Quantity', 'Price']\n",
        "        if not all(col in df.columns for col in required_cols):\n",
        "            return None\n",
        "        df['Price'] = df['Price'].astype(str).str.replace('$', '').str.replace(',', '').astype(float)\n",
        "        df['Date'] = pd.to_datetime(df['Date'])\n",
        "        df = df.sort_values('Date')\n",
        "        return df\n",
        "    except:\n",
        "        return None\n",
        "\n",
        "def parse_account_history_file(uploaded_file):\n",
        "    try:\n",
        "        df = pd.read_html(uploaded_file)[0]\n",
        "        df['Date'] = pd.to_datetime(df['Date'])\n",
        "        df = df.sort_values('Date')\n",
        "        return df\n",
        "    except:\n",
        "        return None\n",
        "\n",
        "def calculate_portfolio_from_trades(trade_df):\n",
        "    holdings = {}\n",
        "    for _, row in trade_df.iterrows():\n",
        "        symbol = row['Symbol']\n",
        "        trade_type = row['Trade Type']\n",
        "        quantity = row['Quantity']\n",
        "        price = row['Price']\n",
        "\n",
        "        if is_option_ticker(symbol):\n",
        "            continue\n",
        "\n",
        "        if symbol not in holdings:\n",
        "            holdings[symbol] = {'total_shares': 0, 'total_cost': 0, 'trades': []}\n",
        "\n",
        "        is_buy = 'Buy' in trade_type\n",
        "\n",
        "        if is_buy:\n",
        "            holdings[symbol]['total_shares'] += quantity\n",
        "            holdings[symbol]['total_cost'] += (quantity * price)\n",
        "            holdings[symbol]['trades'].append({'type': 'BUY', 'quantity': quantity, 'price': price})\n",
        "        else:\n",
        "            remaining_to_sell = quantity\n",
        "            for trade in holdings[symbol]['trades']:\n",
        "                if trade['type'] == 'BUY' and remaining_to_sell > 0:\n",
        "                    if trade['quantity'] <= remaining_to_sell:\n",
        "                        holdings[symbol]['total_cost'] -= (trade['quantity'] * trade['price'])\n",
        "                        holdings[symbol]['total_shares'] -= trade['quantity']\n",
        "                        remaining_to_sell -= trade['quantity']\n",
        "                        trade['quantity'] = 0\n",
        "                    else:\n",
        "                        holdings[symbol]['total_cost'] -= (remaining_to_sell * trade['price'])\n",
        "                        holdings[symbol]['total_shares'] -= remaining_to_sell\n",
        "                        trade['quantity'] -= remaining_to_sell\n",
        "                        remaining_to_sell = 0\n",
        "\n",
        "    portfolio_data = []\n",
        "    for symbol, data in holdings.items():\n",
        "        if data['total_shares'] > 0:\n",
        "            avg_cost = data['total_cost'] / data['total_shares']\n",
        "            portfolio_data.append({\n",
        "                'Ticker': symbol,\n",
        "                'Shares': data['total_shares'],\n",
        "                'Avg Cost': avg_cost\n",
        "            })\n",
        "\n",
        "    if not portfolio_data:\n",
        "        return pd.DataFrame(columns=['Ticker', 'Shares', 'Avg Cost'])\n",
        "    return pd.DataFrame(portfolio_data).sort_values('Ticker')\n",
        "\n",
        "# ============================================================================\n",
        "# PORTFOLIO CALCULATIONS\n",
        "# ============================================================================\n",
        "\n",
        "@st.cache_data(ttl=600)\n",
        "def calculate_portfolio_returns(df, start_date, end_date):\n",
        "    try:\n",
        "        valid_positions = []\n",
        "        for _, row in df.iterrows():\n",
        "            if not is_option_ticker(row['Ticker']):\n",
        "                valid_positions.append(row)\n",
        "\n",
        "        if not valid_positions:\n",
        "            return None\n",
        "\n",
        "        valid_df = pd.DataFrame(valid_positions)\n",
        "        all_data = {}\n",
        "\n",
        "        for _, row in valid_df.iterrows():\n",
        "            ticker = row['Ticker']\n",
        "            data = fetch_historical_data(ticker, start_date, end_date)\n",
        "            if data is not None and len(data) > 0:\n",
        "                all_data[ticker] = data\n",
        "\n",
        "        if not all_data:\n",
        "            return None\n",
        "\n",
        "        common_dates = None\n",
        "        for ticker, data in all_data.items():\n",
        "            dates = set(data.index)\n",
        "            common_dates = dates if common_dates is None else common_dates.intersection(dates)\n",
        "\n",
        "        common_dates = sorted(list(common_dates))\n",
        "        if len(common_dates) < 2:\n",
        "            return None\n",
        "\n",
        "        portfolio_values = []\n",
        "        for date in common_dates:\n",
        "            daily_value = 0\n",
        "            for _, row in valid_df.iterrows():\n",
        "                ticker = row['Ticker']\n",
        "                if ticker in all_data:\n",
        "                    try:\n",
        "                        price = all_data[ticker].loc[date, 'Close']\n",
        "                        daily_value += price * row['Shares']\n",
        "                    except KeyError:\n",
        "                        continue\n",
        "            portfolio_values.append(daily_value)\n",
        "\n",
        "        portfolio_series = pd.Series(portfolio_values, index=common_dates)\n",
        "        returns = portfolio_series.pct_change().dropna()\n",
        "        return returns\n",
        "    except:\n",
        "        return None\n",
        "\n",
        "@st.cache_data(ttl=600)\n",
        "def calculate_benchmark_returns(benchmark_ticker, start_date, end_date):\n",
        "    try:\n",
        "        data = fetch_historical_data(benchmark_ticker, start_date, end_date)\n",
        "        if data is None or data.empty:\n",
        "            return None\n",
        "        returns = data['Close'].pct_change().dropna()\n",
        "        return returns\n",
        "    except:\n",
        "        return None\n",
        "\n",
        "# ============================================================================\n",
        "# ENHANCED HOLDINGS TABLE\n",
        "# ============================================================================\n",
        "\n",
        "def create_enhanced_holdings_table(df):\n",
        "    enhanced_df = df.copy()\n",
        "\n",
        "    for idx, row in enhanced_df.iterrows():\n",
        "        ticker = row['Ticker']\n",
        "        market_data = fetch_market_data(ticker)\n",
        "\n",
        "        if market_data:\n",
        "            enhanced_df.at[idx, 'Asset Name'] = market_data['company_name']\n",
        "            enhanced_df.at[idx, 'Current Price'] = market_data['price']\n",
        "            enhanced_df.at[idx, 'Daily Change'] = market_data['daily_change']\n",
        "            enhanced_df.at[idx, 'Daily Change %'] = market_data['daily_change_pct']\n",
        "            enhanced_df.at[idx, '5D Return %'] = market_data['five_day_return']\n",
        "            enhanced_df.at[idx, 'Beta'] = market_data.get('beta', 'N/A')\n",
        "            enhanced_df.at[idx, 'Volume'] = market_data.get('volume', 0)\n",
        "            base_sector = market_data.get('sector', 'Unknown')\n",
        "            enhanced_df.at[idx, 'Sector'] = classify_ticker_sector(ticker, base_sector)\n",
        "        else:\n",
        "            enhanced_df.at[idx, 'Asset Name'] = ticker\n",
        "            enhanced_df.at[idx, 'Sector'] = 'Other'\n",
        "\n",
        "        analyst_data = fetch_analyst_data(ticker)\n",
        "        if analyst_data['success']:\n",
        "            enhanced_df.at[idx, 'Analyst Rating'] = analyst_data['rating']\n",
        "            enhanced_df.at[idx, 'Price Target'] = analyst_data['target_price']\n",
        "        else:\n",
        "            enhanced_df.at[idx, 'Analyst Rating'] = 'No Coverage'\n",
        "\n",
        "    enhanced_df['Sector'] = enhanced_df['Sector'].fillna('Other')\n",
        "    enhanced_df['Shares'] = enhanced_df['Shares'].round(0).astype(int)\n",
        "\n",
        "    enhanced_df['Total Cost'] = enhanced_df['Shares'] * enhanced_df['Avg Cost']\n",
        "    enhanced_df['Total Value'] = enhanced_df['Shares'] * enhanced_df['Current Price']\n",
        "    enhanced_df['Total Gain/Loss $'] = enhanced_df['Total Value'] - enhanced_df['Total Cost']\n",
        "    enhanced_df['Total Gain/Loss %'] = ((enhanced_df['Current Price'] - enhanced_df['Avg Cost']) / enhanced_df['Avg Cost']) * 100\n",
        "    enhanced_df['Daily P&L $'] = enhanced_df['Shares'] * enhanced_df['Daily Change']\n",
        "\n",
        "    total_value = enhanced_df['Total Value'].sum()\n",
        "    enhanced_df['Weight %'] = (enhanced_df['Total Value'] / total_value * 100) if total_value > 0 else 0\n",
        "\n",
        "    return enhanced_df\n",
        "\n",
        "def style_holdings_dataframe(df):\n",
        "    display_df = df[[\n",
        "        'Ticker', 'Asset Name', 'Shares', 'Avg Cost', 'Current Price',\n",
        "        'Daily Change %', '5D Return %', 'Weight %', 'Daily P&L $',\n",
        "        'Total Gain/Loss $', 'Total Gain/Loss %', 'Beta', 'Analyst Rating'\n",
        "    ]].copy()\n",
        "\n",
        "    pct_cols = ['Daily Change %', '5D Return %', 'Weight %', 'Total Gain/Loss %']\n",
        "    for col in pct_cols:\n",
        "        display_df[col] = display_df[col].apply(lambda x: format_percentage(x))\n",
        "\n",
        "    currency_cols = ['Avg Cost', 'Current Price', 'Daily P&L $', 'Total Gain/Loss $']\n",
        "    for col in currency_cols:\n",
        "        display_df[col] = display_df[col].apply(format_currency)\n",
        "\n",
        "    display_df['Daily Change %'] = display_df['Daily Change %'].apply(add_arrow_indicator)\n",
        "    display_df['Total Gain/Loss %'] = display_df['Total Gain/Loss %'].apply(add_arrow_indicator)\n",
        "\n",
        "    return display_df\n",
        "\n",
        "# ============================================================================\n",
        "# RISK METRICS\n",
        "# ============================================================================\n",
        "\n",
        "def calculate_sharpe_ratio(returns, risk_free_rate=RISK_FREE_RATE):\n",
        "    if not is_valid_series(returns) or len(returns) < 2:\n",
        "        return None\n",
        "    total_return = (1 + returns).prod() - 1\n",
        "    n_years = len(returns) / 252\n",
        "    annualized_return = (1 + total_return) ** (1/n_years) - 1 if n_years > 0 else 0\n",
        "    annualized_vol = returns.std() * np.sqrt(252)\n",
        "    sharpe = (annualized_return - risk_free_rate) / annualized_vol if annualized_vol > 0 else 0\n",
        "    return sharpe\n",
        "\n",
        "def calculate_sortino_ratio(returns, risk_free_rate=RISK_FREE_RATE):\n",
        "    if not is_valid_series(returns) or len(returns) < 2:\n",
        "        return None\n",
        "    total_return = (1 + returns).prod() - 1\n",
        "    n_years = len(returns) / 252\n",
        "    annualized_return = (1 + total_return) ** (1/n_years) - 1 if n_years > 0 else 0\n",
        "    downside_returns = returns[returns < 0]\n",
        "    if len(downside_returns) < 2:\n",
        "        return None\n",
        "    downside_std = downside_returns.std() * np.sqrt(252)\n",
        "    sortino = (annualized_return - risk_free_rate) / downside_std if downside_std > 0 else 0\n",
        "    return sortino\n",
        "\n",
        "def calculate_information_ratio(portfolio_returns, benchmark_returns):\n",
        "    if not is_valid_series(portfolio_returns) or not is_valid_series(benchmark_returns):\n",
        "        return None\n",
        "    if len(portfolio_returns) < 2 or len(benchmark_returns) < 2:\n",
        "        return None\n",
        "    common_dates = portfolio_returns.index.intersection(benchmark_returns.index)\n",
        "    portfolio_returns = portfolio_returns.loc[common_dates]\n",
        "    benchmark_returns = benchmark_returns.loc[common_dates]\n",
        "    excess_returns = portfolio_returns - benchmark_returns\n",
        "    if len(excess_returns) < 2:\n",
        "        return None\n",
        "    total_excess = (1 + excess_returns).prod() - 1\n",
        "    n_years = len(excess_returns) / 252\n",
        "    annualized_excess = (1 + total_excess) ** (1/n_years) - 1 if n_years > 0 else 0\n",
        "    tracking_error = excess_returns.std() * np.sqrt(252)\n",
        "    info_ratio = annualized_excess / tracking_error if tracking_error > 0 else 0\n",
        "    return info_ratio\n",
        "\n",
        "def calculate_var(returns, confidence=0.95):\n",
        "    if not is_valid_series(returns) or len(returns) < 2:\n",
        "        return None\n",
        "    var = np.percentile(returns, (1 - confidence) * 100)\n",
        "    return var * 100\n",
        "\n",
        "def calculate_cvar(returns, confidence=0.95):\n",
        "    if not is_valid_series(returns) or len(returns) < 2:\n",
        "        return None\n",
        "    var = np.percentile(returns, (1 - confidence) * 100)\n",
        "    cvar = returns[returns <= var].mean()\n",
        "    return cvar * 100\n",
        "\n",
        "def calculate_max_drawdown(returns):\n",
        "    if not is_valid_series(returns) or len(returns) < 2:\n",
        "        return None\n",
        "    cumulative = (1 + returns).cumprod()\n",
        "    running_max = cumulative.expanding().max()\n",
        "    drawdown = (cumulative - running_max) / running_max\n",
        "    return drawdown.min() * 100\n",
        "\n",
        "def calculate_calmar_ratio(returns, risk_free_rate=RISK_FREE_RATE):\n",
        "    if not is_valid_series(returns) or len(returns) < 2:\n",
        "        return None\n",
        "    total_return = (1 + returns).prod() - 1\n",
        "    n_years = len(returns) / 252\n",
        "    annualized_return = (1 + total_return) ** (1/n_years) - 1 if n_years > 0 else 0\n",
        "    max_dd = abs(calculate_max_drawdown(returns))\n",
        "    if max_dd == 0:\n",
        "        return 0\n",
        "    return (annualized_return - risk_free_rate) / (max_dd / 100)\n",
        "\n",
        "# ============================================================================\n",
        "# WORLD-CLASS VISUALIZATIONS\n",
        "# ============================================================================\n",
        "\n",
        "def create_rolling_metrics_chart(returns, window=60):\n",
        "    \"\"\"Rolling metrics visualization\"\"\"\n",
        "    if not is_valid_series(returns) or len(returns) < window:\n",
        "        return None\n",
        "\n",
        "    rolling_vol = returns.rolling(window).std() * np.sqrt(252) * 100\n",
        "    rolling_sharpe = (returns.rolling(window).mean() * 252 - RISK_FREE_RATE) / (returns.rolling(window).std() * np.sqrt(252))\n",
        "\n",
        "    fig = make_subplots(\n",
        "        rows=2, cols=1,\n",
        "        subplot_titles=('Rolling Volatility (60-Day)', 'Rolling Sharpe Ratio (60-Day)'),\n",
        "        vertical_spacing=0.15\n",
        "    )\n",
        "\n",
        "    fig.add_trace(\n",
        "        go.Scatter(\n",
        "            x=rolling_vol.index,\n",
        "            y=rolling_vol.values,\n",
        "            fill='tozeroy',\n",
        "            fillcolor='rgba(255, 0, 68, 0.2)',\n",
        "            line=dict(color=COLORS['danger'], width=2),\n",
        "            name='Volatility'\n",
        "        ),\n",
        "        row=1, col=1\n",
        "    )\n",
        "\n",
        "    fig.add_trace(\n",
        "        go.Scatter(\n",
        "            x=rolling_sharpe.index,\n",
        "            y=rolling_sharpe.values,\n",
        "            fill='tozeroy',\n",
        "            fillcolor='rgba(0, 212, 255, 0.2)',\n",
        "            line=dict(color=COLORS['neon_blue'], width=2),\n",
        "            name='Sharpe Ratio'\n",
        "        ),\n",
        "        row=2, col=1\n",
        "    )\n",
        "\n",
        "    fig.add_hline(y=0, line_dash=\"dash\", line_color=COLORS['text_muted'], row=2, col=1)\n",
        "\n",
        "    fig.update_layout(\n",
        "        height=600,\n",
        "        showlegend=False,\n",
        "        title_text=\"üìä Rolling Risk Metrics\",\n",
        "        paper_bgcolor=COLORS['background'],\n",
        "        plot_bgcolor=COLORS['card_background'],\n",
        "        font=dict(color=COLORS['text_primary'])\n",
        "    )\n",
        "\n",
        "    return fig\n",
        "\n",
        "def create_underwater_plot(returns):\n",
        "    \"\"\"Underwater drawdown plot\"\"\"\n",
        "    if not is_valid_series(returns) or len(returns) < 2:\n",
        "        return None\n",
        "\n",
        "    cumulative = (1 + returns).cumprod()\n",
        "    running_max = cumulative.expanding().max()\n",
        "    drawdown = ((cumulative - running_max) / running_max) * 100\n",
        "\n",
        "    fig = go.Figure()\n",
        "\n",
        "    fig.add_trace(go.Scatter(\n",
        "        x=drawdown.index,\n",
        "        y=drawdown.values,\n",
        "        fill='tozeroy',\n",
        "        fillcolor='rgba(255, 0, 68, 0.3)',\n",
        "        line=dict(color=COLORS['danger'], width=2),\n",
        "        name='Drawdown'\n",
        "    ))\n",
        "\n",
        "    fig.add_hline(y=0, line_dash=\"solid\", line_color=COLORS['text_primary'], line_width=1)\n",
        "\n",
        "    max_dd_idx = drawdown.idxmin()\n",
        "    max_dd_val = drawdown.min()\n",
        "\n",
        "    fig.add_annotation(\n",
        "        x=max_dd_idx,\n",
        "        y=max_dd_val,\n",
        "        text=f\"Max DD: {max_dd_val:.2f}%\",\n",
        "        showarrow=True,\n",
        "        arrowhead=2,\n",
        "        arrowcolor=COLORS['danger'],\n",
        "        ax=0,\n",
        "        ay=-40,\n",
        "        bgcolor=COLORS['card_background'],\n",
        "        bordercolor=COLORS['danger'],\n",
        "        borderwidth=2\n",
        "    )\n",
        "\n",
        "    fig.update_layout(\n",
        "        title=\"üåä Underwater Plot\",\n",
        "        xaxis_title=\"Date\",\n",
        "        yaxis_title=\"Drawdown (%)\",\n",
        "        height=500,\n",
        "        paper_bgcolor=COLORS['background'],\n",
        "        plot_bgcolor=COLORS['card_background'],\n",
        "        font=dict(color=COLORS['text_primary'])\n",
        "    )\n",
        "\n",
        "    return fig\n",
        "\n",
        "def create_var_waterfall(returns):\n",
        "    \"\"\"VaR/CVaR waterfall chart\"\"\"\n",
        "    if not is_valid_series(returns) or len(returns) < 2:\n",
        "        return None\n",
        "\n",
        "    var_90 = calculate_var(returns, 0.90)\n",
        "    var_95 = calculate_var(returns, 0.95)\n",
        "    var_99 = calculate_var(returns, 0.99)\n",
        "    cvar_95 = calculate_cvar(returns, 0.95)\n",
        "\n",
        "    categories = ['VaR 90%', 'VaR 95%', 'VaR 99%', 'CVaR 95%']\n",
        "    values = [var_90, var_95, var_99, cvar_95]\n",
        "\n",
        "    colors_list = [COLORS['warning'], COLORS['orange'], COLORS['danger'], COLORS['danger']]\n",
        "\n",
        "    fig = go.Figure()\n",
        "\n",
        "    fig.add_trace(go.Bar(\n",
        "        x=categories,\n",
        "        y=values,\n",
        "        marker=dict(\n",
        "            color=colors_list,\n",
        "            line=dict(color=COLORS['border'], width=2)\n",
        "        ),\n",
        "        text=[f\"{v:.2f}%\" for v in values],\n",
        "        textposition='outside'\n",
        "    ))\n",
        "\n",
        "    fig.update_layout(\n",
        "        title=\"‚ö†Ô∏è Value at Risk Waterfall\",\n",
        "        xaxis_title=\"Risk Measure\",\n",
        "        yaxis_title=\"Expected Loss (%)\",\n",
        "        height=500,\n",
        "        paper_bgcolor=COLORS['background'],\n",
        "        plot_bgcolor=COLORS['card_background'],\n",
        "        font=dict(color=COLORS['text_primary'])\n",
        "    )\n",
        "\n",
        "    return fig\n",
        "\n",
        "def create_risk_contribution_sunburst(df):\n",
        "    \"\"\"Risk contribution sunburst\"\"\"\n",
        "    risk_data = []\n",
        "\n",
        "    for _, row in df.iterrows():\n",
        "        ticker = row['Ticker']\n",
        "        weight = row['Weight %']\n",
        "        sector = row['Sector']\n",
        "\n",
        "        hist_data = fetch_historical_data(ticker, datetime.now() - timedelta(days=365), datetime.now())\n",
        "        if hist_data is not None and len(hist_data) > 30:\n",
        "            returns = hist_data['Close'].pct_change().dropna()\n",
        "            vol = returns.std() * np.sqrt(252) * 100\n",
        "            risk_contribution = weight * vol\n",
        "\n",
        "            risk_data.append({\n",
        "                'Ticker': ticker,\n",
        "                'Sector': sector,\n",
        "                'Weight': weight,\n",
        "                'Volatility': vol,\n",
        "                'Risk Contribution': risk_contribution\n",
        "            })\n",
        "\n",
        "    if not risk_data:\n",
        "        return None\n",
        "\n",
        "    risk_df = pd.DataFrame(risk_data)\n",
        "\n",
        "    fig = px.sunburst(\n",
        "        risk_df,\n",
        "        path=['Sector', 'Ticker'],\n",
        "        values='Risk Contribution',\n",
        "        color='Volatility',\n",
        "        color_continuous_scale='RdYlGn_r',\n",
        "        title=\"‚òÄÔ∏è Risk Contribution Sunburst\"\n",
        "    )\n",
        "\n",
        "    fig.update_layout(\n",
        "        height=600,\n",
        "        paper_bgcolor=COLORS['background'],\n",
        "        font=dict(color=COLORS['text_primary'])\n",
        "    )\n",
        "\n",
        "    return fig\n",
        "\n",
        "def create_risk_reward_plot(df):\n",
        "    \"\"\"Risk-reward scatter plot\"\"\"\n",
        "    risk_reward_data = []\n",
        "\n",
        "    for _, row in df.iterrows():\n",
        "        ticker = row['Ticker']\n",
        "        hist_data = fetch_historical_data(ticker, datetime.now() - timedelta(days=365), datetime.now())\n",
        "\n",
        "        if hist_data is not None and len(hist_data) > 30:\n",
        "            returns = hist_data['Close'].pct_change().dropna()\n",
        "            annual_return = ((1 + returns.mean()) ** 252 - 1) * 100\n",
        "            annual_vol = returns.std() * np.sqrt(252) * 100\n",
        "\n",
        "            risk_reward_data.append({\n",
        "                'Ticker': ticker,\n",
        "                'Asset Name': row['Asset Name'],\n",
        "                'Return': annual_return,\n",
        "                'Risk': annual_vol,\n",
        "                'Weight': row['Weight %'],\n",
        "                'Sector': row['Sector']\n",
        "            })\n",
        "\n",
        "    if not risk_reward_data:\n",
        "        return None\n",
        "\n",
        "    rr_df = pd.DataFrame(risk_reward_data)\n",
        "\n",
        "    fig = px.scatter(\n",
        "        rr_df,\n",
        "        x='Risk',\n",
        "        y='Return',\n",
        "        size='Weight',\n",
        "        color='Sector',\n",
        "        text='Ticker',\n",
        "        hover_data=['Asset Name'],\n",
        "        color_discrete_sequence=px.colors.qualitative.Set3\n",
        "    )\n",
        "\n",
        "    fig.update_traces(\n",
        "        textposition='top center',\n",
        "        marker=dict(line=dict(width=2, color=COLORS['border']))\n",
        "    )\n",
        "\n",
        "    fig.update_layout(\n",
        "        title=\"üìà Risk-Reward Analysis\",\n",
        "        xaxis_title=\"Risk (Annual Volatility %)\",\n",
        "        yaxis_title=\"Expected Return (Annual %)\",\n",
        "        height=500,\n",
        "        paper_bgcolor=COLORS['background'],\n",
        "        plot_bgcolor=COLORS['card_background'],\n",
        "        font=dict(color=COLORS['text_primary'])\n",
        "    )\n",
        "\n",
        "    return fig\n",
        "\n",
        "def create_performance_heatmap(df, period='monthly'):\n",
        "    \"\"\"Performance heatmap\"\"\"\n",
        "    try:\n",
        "        portfolio_values = {}\n",
        "\n",
        "        end_date = datetime.now()\n",
        "        start_date = end_date - timedelta(days=365)\n",
        "\n",
        "        for _, row in df.iterrows():\n",
        "            ticker = row['Ticker']\n",
        "            hist_data = fetch_historical_data(ticker, start_date, end_date)\n",
        "\n",
        "            if hist_data is not None and len(hist_data) > 0:\n",
        "                monthly_data = hist_data['Close'].resample('M').last()\n",
        "                monthly_returns = monthly_data.pct_change() * 100\n",
        "\n",
        "                for month, ret in monthly_returns.items():\n",
        "                    if month.month == end_date.month and month.year == end_date.year:\n",
        "                        continue\n",
        "                    month_str = month.strftime('%b %Y')\n",
        "                    if month_str not in portfolio_values:\n",
        "                        portfolio_values[month_str] = {}\n",
        "                    if pd.notna(ret) and abs(ret) < 50:\n",
        "                        portfolio_values[month_str][ticker] = ret\n",
        "\n",
        "        if not portfolio_values:\n",
        "            return None\n",
        "\n",
        "        tickers = sorted(set(t for months in portfolio_values.values() for t in months))\n",
        "        months = sorted(portfolio_values.keys(), key=lambda x: datetime.strptime(x, '%b %Y'))\n",
        "\n",
        "        months = [m for m in months if datetime.strptime(m, '%b %Y') <= end_date]\n",
        "\n",
        "        matrix = []\n",
        "        for ticker in tickers:\n",
        "            row = []\n",
        "            for month in months:\n",
        "                if ticker in portfolio_values[month]:\n",
        "                    val = portfolio_values[month][ticker]\n",
        "                    val = max(-50, min(50, val))\n",
        "                    row.append(val)\n",
        "                else:\n",
        "                    row.append(0)\n",
        "            matrix.append(row)\n",
        "\n",
        "        fig = go.Figure(data=go.Heatmap(\n",
        "            z=matrix,\n",
        "            x=months,\n",
        "            y=tickers,\n",
        "            colorscale='RdYlGn',\n",
        "            zmid=0,\n",
        "            zmin=-20,\n",
        "            zmax=20,\n",
        "            text=np.round(matrix, 1),\n",
        "            texttemplate='%{text}%',\n",
        "            textfont={\"size\": 14},\n",
        "            colorbar=dict(title=\"Return %\")\n",
        "        ))\n",
        "\n",
        "        fig.update_layout(\n",
        "            title=\"üî• Monthly Performance Heatmap\",\n",
        "            xaxis_title=\"Month\",\n",
        "            yaxis_title=\"Asset\",\n",
        "            height=800,\n",
        "            width=1200,\n",
        "            paper_bgcolor=COLORS['background'],\n",
        "            plot_bgcolor=COLORS['card_background'],\n",
        "            font=dict(color=COLORS['text_primary'], size=14)\n",
        "        )\n",
        "\n",
        "        return fig\n",
        "    except Exception as e:\n",
        "        st.error(f\"Error: {str(e)}\")\n",
        "        return None\n",
        "\n",
        "def create_portfolio_heatmap(df):\n",
        "    \"\"\"Portfolio treemap\"\"\"\n",
        "    df_viz = df[['Ticker', 'Asset Name', 'Weight %', 'Total Gain/Loss %', 'Sector']].copy()\n",
        "    df_viz['Sector'] = df_viz['Sector'].fillna('Other')\n",
        "    df_viz = df_viz.dropna()\n",
        "\n",
        "    if df_viz.empty:\n",
        "        return None\n",
        "\n",
        "    fig = px.treemap(\n",
        "        df_viz,\n",
        "        path=[px.Constant(\"Portfolio\"), 'Sector', 'Ticker'],\n",
        "        values='Weight %',\n",
        "        color='Total Gain/Loss %',\n",
        "        color_continuous_scale='RdYlGn',\n",
        "        color_continuous_midpoint=0,\n",
        "        hover_data={'Asset Name': True, 'Total Gain/Loss %': ':.2f'}\n",
        "    )\n",
        "\n",
        "    fig.update_layout(\n",
        "        title=\"üó∫Ô∏è Portfolio Heatmap\",\n",
        "        height=700,\n",
        "        paper_bgcolor=COLORS['background'],\n",
        "        font=dict(color=COLORS['text_primary'])\n",
        "    )\n",
        "\n",
        "    return fig\n",
        "\n",
        "# ============================================================================\n",
        "# CONTINUING WITH ALL ORIGINAL FEATURES...\n",
        "# ============================================================================\n",
        "\n",
        "@st.cache_data(ttl=600)\n",
        "def fetch_ticker_performance(ticker, start_date, end_date):\n",
        "    try:\n",
        "        data = fetch_historical_data(ticker, start_date, end_date)\n",
        "        if data is not None and not data.empty:\n",
        "            returns = data['Close'].pct_change().fillna(0)\n",
        "            cumulative = (1 + returns).cumprod() - 1\n",
        "            return cumulative * 100, data\n",
        "        return None, None\n",
        "    except:\n",
        "        return None, None\n",
        "\n",
        "def create_interactive_performance_chart(tickers, start_date, end_date):\n",
        "    \"\"\"Interactive performance chart\"\"\"\n",
        "    fig = go.Figure()\n",
        "\n",
        "    colors = [COLORS['neon_blue'], COLORS['electric_blue'], COLORS['teal'],\n",
        "              COLORS['success'], COLORS['warning'], COLORS['danger'],\n",
        "              COLORS['purple'], COLORS['pink'], COLORS['orange']]\n",
        "\n",
        "    for idx, ticker in enumerate(tickers):\n",
        "        cumulative, data = fetch_ticker_performance(ticker, start_date, end_date)\n",
        "        if cumulative is not None:\n",
        "            fig.add_trace(go.Scatter(\n",
        "                x=cumulative.index,\n",
        "                y=cumulative.values,\n",
        "                mode='lines',\n",
        "                name=ticker,\n",
        "                line=dict(width=2.5, color=colors[idx % len(colors)])\n",
        "            ))\n",
        "\n",
        "    if not fig.data:\n",
        "        return None\n",
        "\n",
        "    fig.update_layout(\n",
        "        title=\"üìà Interactive Performance Comparison\",\n",
        "        xaxis_title=\"Date\",\n",
        "        yaxis_title=\"Cumulative Return (%)\",\n",
        "        height=600,\n",
        "        hovermode='x unified',\n",
        "        legend=dict(x=0.01, y=0.99),\n",
        "        paper_bgcolor=COLORS['background'],\n",
        "        plot_bgcolor=COLORS['card_background'],\n",
        "        font=dict(color=COLORS['text_primary'])\n",
        "    )\n",
        "\n",
        "    fig.add_hline(y=0, line_dash=\"dash\", line_color=COLORS['text_muted'], line_width=1)\n",
        "\n",
        "    return fig\n",
        "\n",
        "def run_monte_carlo_simulation(returns, initial_value=100000, days=252, simulations=1000):\n",
        "    if not is_valid_series(returns) or len(returns) < 30:\n",
        "        return None\n",
        "\n",
        "    daily_return = returns.mean()\n",
        "    daily_vol = returns.std()\n",
        "\n",
        "    simulation_results = []\n",
        "\n",
        "    for _ in range(simulations):\n",
        "        prices = [initial_value]\n",
        "        for _ in range(days):\n",
        "            price = prices[-1] * (1 + np.random.normal(daily_return, daily_vol))\n",
        "            prices.append(price)\n",
        "        simulation_results.append(prices)\n",
        "\n",
        "    return np.array(simulation_results)\n",
        "\n",
        "def create_monte_carlo_chart(simulation_results, initial_value=100000):\n",
        "    if simulation_results is None:\n",
        "        return None, None\n",
        "\n",
        "    fig = go.Figure()\n",
        "\n",
        "    for i in range(min(100, len(simulation_results))):\n",
        "        fig.add_trace(go.Scatter(\n",
        "            y=simulation_results[i],\n",
        "            mode='lines',\n",
        "            line=dict(width=0.5, color=COLORS['electric_blue']),\n",
        "            opacity=0.1,\n",
        "            showlegend=False\n",
        "        ))\n",
        "\n",
        "    percentiles = [5, 25, 50, 75, 95]\n",
        "    colors_pct = [COLORS['danger'], COLORS['warning'], COLORS['info'],\n",
        "                  COLORS['teal'], COLORS['success']]\n",
        "\n",
        "    for p, color in zip(percentiles, colors_pct):\n",
        "        values = np.percentile(simulation_results, p, axis=0)\n",
        "        fig.add_trace(go.Scatter(\n",
        "            y=values,\n",
        "            mode='lines',\n",
        "            line=dict(width=3, color=color),\n",
        "            name=f'{p}th Percentile'\n",
        "        ))\n",
        "\n",
        "    fig.update_layout(\n",
        "        title=\"üé≤ Monte Carlo Simulation\",\n",
        "        xaxis_title=\"Trading Days\",\n",
        "        yaxis_title=\"Portfolio Value ($)\",\n",
        "        height=500,\n",
        "        paper_bgcolor=COLORS['background'],\n",
        "        plot_bgcolor=COLORS['card_background'],\n",
        "        font=dict(color=COLORS['text_primary'])\n",
        "    )\n",
        "\n",
        "    final_values = simulation_results[:, -1]\n",
        "    stats = {\n",
        "        'mean': np.mean(final_values),\n",
        "        'median': np.median(final_values),\n",
        "        'percentile_5': np.percentile(final_values, 5),\n",
        "        'percentile_95': np.percentile(final_values, 95),\n",
        "        'prob_profit': (final_values > initial_value).mean() * 100,\n",
        "        'prob_loss_10': (final_values < initial_value * 0.9).mean() * 100,\n",
        "        'prob_gain_20': (final_values > initial_value * 1.2).mean() * 100\n",
        "    }\n",
        "\n",
        "    return fig, stats\n",
        "\n",
        "def create_risk_parity_analysis(df):\n",
        "    risk_contributions = []\n",
        "\n",
        "    for _, row in df.iterrows():\n",
        "        ticker = row['Ticker']\n",
        "        weight = row['Weight %'] / 100\n",
        "\n",
        "        hist_data = fetch_historical_data(ticker, datetime.now() - timedelta(days=365), datetime.now())\n",
        "        if hist_data is not None and len(hist_data) > 30:\n",
        "            returns = hist_data['Close'].pct_change().dropna()\n",
        "            vol = returns.std() * np.sqrt(252)\n",
        "            risk_contribution = weight * vol\n",
        "\n",
        "            risk_contributions.append({\n",
        "                'Ticker': ticker,\n",
        "                'Weight %': row['Weight %'],\n",
        "                'Volatility': vol * 100,\n",
        "                'Risk Contribution': risk_contribution * 100\n",
        "            })\n",
        "\n",
        "    if not risk_contributions:\n",
        "        return None\n",
        "\n",
        "    rc_df = pd.DataFrame(risk_contributions)\n",
        "    total_risk = rc_df['Risk Contribution'].sum()\n",
        "    rc_df['Risk %'] = (rc_df['Risk Contribution'] / total_risk) * 100\n",
        "\n",
        "    fig = go.Figure()\n",
        "\n",
        "    fig.add_trace(go.Bar(\n",
        "        name='Weight %',\n",
        "        x=rc_df['Ticker'],\n",
        "        y=rc_df['Weight %'],\n",
        "        marker_color=COLORS['electric_blue']\n",
        "    ))\n",
        "\n",
        "    fig.add_trace(go.Bar(\n",
        "        name='Risk Contribution %',\n",
        "        x=rc_df['Ticker'],\n",
        "        y=rc_df['Risk %'],\n",
        "        marker_color=COLORS['danger']\n",
        "    ))\n",
        "\n",
        "    fig.update_layout(\n",
        "        title=\"‚öñÔ∏è Risk Parity Analysis\",\n",
        "        xaxis_title=\"Asset\",\n",
        "        yaxis_title=\"Percentage\",\n",
        "        barmode='group',\n",
        "        height=500,\n",
        "        paper_bgcolor=COLORS['background'],\n",
        "        plot_bgcolor=COLORS['card_background'],\n",
        "        font=dict(color=COLORS['text_primary'])\n",
        "    )\n",
        "\n",
        "    return fig\n",
        "\n",
        "def create_correlation_network(df, start_date, end_date):\n",
        "    returns_data = {}\n",
        "\n",
        "    for _, row in df.iterrows():\n",
        "        ticker = row['Ticker']\n",
        "        hist_data = fetch_historical_data(ticker, start_date, end_date)\n",
        "        if hist_data is not None and len(hist_data) > 30:\n",
        "            returns_data[ticker] = hist_data['Close'].pct_change().dropna()\n",
        "\n",
        "    if len(returns_data) < 2:\n",
        "        return None\n",
        "\n",
        "    returns_df = pd.DataFrame(returns_data)\n",
        "    corr_matrix = returns_df.corr()\n",
        "\n",
        "    fig = go.Figure()\n",
        "\n",
        "    G = nx.Graph()\n",
        "    for ticker in corr_matrix.columns:\n",
        "        G.add_node(ticker)\n",
        "\n",
        "    threshold = 0.5\n",
        "    for i, ticker1 in enumerate(corr_matrix.columns):\n",
        "        for j, ticker2 in enumerate(corr_matrix.columns):\n",
        "            if i < j:\n",
        "                corr = corr_matrix.iloc[i, j]\n",
        "                if abs(corr) > threshold:\n",
        "                    G.add_edge(ticker1, ticker2, weight=abs(corr))\n",
        "\n",
        "    pos = nx.spring_layout(G)\n",
        "\n",
        "    for edge in G.edges():\n",
        "        x0, y0 = pos[edge[0]]\n",
        "        x1, y1 = pos[edge[1]]\n",
        "        weight = G[edge[0]][edge[1]]['weight']\n",
        "\n",
        "        fig.add_trace(go.Scatter(\n",
        "            x=[x0, x1],\n",
        "            y=[y0, y1],\n",
        "            mode='lines',\n",
        "            line=dict(width=weight*5, color=COLORS['electric_blue']),\n",
        "            opacity=0.5,\n",
        "            showlegend=False\n",
        "        ))\n",
        "\n",
        "    node_x = []\n",
        "    node_y = []\n",
        "    node_text = []\n",
        "\n",
        "    for node in G.nodes():\n",
        "        x, y = pos[node]\n",
        "        node_x.append(x)\n",
        "        node_y.append(y)\n",
        "        node_text.append(node)\n",
        "\n",
        "    fig.add_trace(go.Scatter(\n",
        "        x=node_x,\n",
        "        y=node_y,\n",
        "        mode='markers+text',\n",
        "        text=node_text,\n",
        "        textposition='top center',\n",
        "        marker=dict(\n",
        "            size=20,\n",
        "            color=COLORS['neon_blue'],\n",
        "            line=dict(width=2, color=COLORS['border'])\n",
        "        ),\n",
        "        showlegend=False\n",
        "    ))\n",
        "\n",
        "    fig.update_layout(\n",
        "        title=\"üîó Correlation Network\",\n",
        "        showlegend=False,\n",
        "        height=600,\n",
        "        paper_bgcolor=COLORS['background'],\n",
        "        plot_bgcolor=COLORS['card_background'],\n",
        "        font=dict(color=COLORS['text_primary']),\n",
        "        xaxis=dict(showgrid=False, zeroline=False, showticklabels=False),\n",
        "        yaxis=dict(showgrid=False, zeroline=False, showticklabels=False)\n",
        "    )\n",
        "\n",
        "    return fig\n",
        "\n",
        "def create_efficient_frontier(df):\n",
        "    \"\"\"FIXED BROADCASTING ERROR\"\"\"\n",
        "    returns_data = {}\n",
        "    expected_returns = []\n",
        "    volatilities = []\n",
        "    tickers = []\n",
        "\n",
        "    for _, row in df.iterrows():\n",
        "        ticker = row['Ticker']\n",
        "        hist_data = fetch_historical_data(ticker, datetime.now() - timedelta(days=365), datetime.now())\n",
        "\n",
        "        if hist_data is not None and len(hist_data) > 30:\n",
        "            returns = hist_data['Close'].pct_change().dropna()\n",
        "            annual_return = ((1 + returns.mean()) ** 252 - 1)\n",
        "            annual_vol = returns.std() * np.sqrt(252)\n",
        "\n",
        "            expected_returns.append(annual_return)\n",
        "            volatilities.append(annual_vol)\n",
        "            tickers.append(ticker)\n",
        "            returns_data[ticker] = returns\n",
        "\n",
        "    if len(expected_returns) < 2:\n",
        "        return None\n",
        "\n",
        "    returns_df = pd.DataFrame(returns_data)\n",
        "    cov_matrix = returns_df.cov() * 252\n",
        "\n",
        "    num_portfolios = 5000\n",
        "    results = np.zeros((3, num_portfolios))\n",
        "\n",
        "    np.random.seed(42)\n",
        "\n",
        "    for i in range(num_portfolios):\n",
        "        weights = np.random.random(len(tickers))\n",
        "        weights /= np.sum(weights)\n",
        "\n",
        "        portfolio_return = np.sum(weights * np.array(expected_returns))\n",
        "        portfolio_vol = np.sqrt(np.dot(weights.T, np.dot(cov_matrix, weights)))\n",
        "        sharpe = (portfolio_return - RISK_FREE_RATE) / portfolio_vol if portfolio_vol > 0 else 0\n",
        "\n",
        "        results[0, i] = portfolio_return * 100\n",
        "        results[1, i] = portfolio_vol * 100\n",
        "        results[2, i] = sharpe\n",
        "\n",
        "    fig = go.Figure()\n",
        "\n",
        "    fig.add_trace(go.Scatter(\n",
        "        x=results[1],\n",
        "        y=results[0],\n",
        "        mode='markers',\n",
        "        marker=dict(\n",
        "            size=5,\n",
        "            color=results[2],\n",
        "            colorscale='Viridis',\n",
        "            showscale=True,\n",
        "            colorbar=dict(title=\"Sharpe Ratio\")\n",
        "        ),\n",
        "        name='Efficient Frontier'\n",
        "    ))\n",
        "\n",
        "    # FIXED: Properly align weights and returns\n",
        "    current_weights = df[df['Ticker'].isin(tickers)]['Weight %'].values / 100\n",
        "    aligned_returns = np.array(expected_returns[:len(current_weights)])\n",
        "    aligned_cov = cov_matrix.iloc[:len(current_weights), :len(current_weights)]\n",
        "\n",
        "    current_return = np.sum(current_weights * aligned_returns) * 100\n",
        "    current_vol = np.sqrt(np.dot(current_weights.T, np.dot(aligned_cov, current_weights))) * 100\n",
        "\n",
        "    fig.add_trace(go.Scatter(\n",
        "        x=[current_vol],\n",
        "        y=[current_return],\n",
        "        mode='markers',\n",
        "        marker=dict(size=20, color=COLORS['danger'], symbol='star'),\n",
        "        name='Current Portfolio'\n",
        "    ))\n",
        "\n",
        "    fig.update_layout(\n",
        "        title=\"üìä Efficient Frontier\",\n",
        "        xaxis_title=\"Risk (Volatility %)\",\n",
        "        yaxis_title=\"Return %\",\n",
        "        height=600,\n",
        "        paper_bgcolor=COLORS['background'],\n",
        "        plot_bgcolor=COLORS['card_background'],\n",
        "        font=dict(color=COLORS['text_primary'])\n",
        "    )\n",
        "\n",
        "    return fig\n",
        "\n",
        "# ============================================================================\n",
        "# MARKET WATCH\n",
        "# ============================================================================\n",
        "\n",
        "@st.cache_data(ttl=300)\n",
        "def fetch_market_watch_data(tickers_dict):\n",
        "    market_data = []\n",
        "\n",
        "    for ticker, info in tickers_dict.items():\n",
        "        try:\n",
        "            stock = yf.Ticker(ticker)\n",
        "            hist = stock.history(period=\"5d\")\n",
        "\n",
        "            if not hist.empty:\n",
        "                current = hist['Close'].iloc[-1]\n",
        "                prev = hist['Close'].iloc[-2] if len(hist) > 1 else current\n",
        "                change = ((current - prev) / prev) * 100\n",
        "\n",
        "                five_day = ((current / hist['Close'].iloc[0]) - 1) * 100 if len(hist) >= 5 else 0\n",
        "\n",
        "                volume = hist['Volume'].iloc[-1]\n",
        "                avg_volume = hist['Volume'].mean()\n",
        "\n",
        "                market_data.append({\n",
        "                    'Symbol': ticker,\n",
        "                    'Name': info.get('name', ticker),\n",
        "                    'Category': info.get('category', info.get('region', '')),\n",
        "                    'Last': current,\n",
        "                    'Change %': change,\n",
        "                    '5D %': five_day,\n",
        "                    'Volume': volume,\n",
        "                    'Avg Volume': avg_volume,\n",
        "                    'Vol/Avg': volume / avg_volume if avg_volume > 0 else 0\n",
        "                })\n",
        "        except:\n",
        "            continue\n",
        "\n",
        "    return pd.DataFrame(market_data)\n",
        "\n",
        "def create_dynamic_market_table(df, filters=None):\n",
        "    if filters:\n",
        "        if 'category' in filters and filters['category']:\n",
        "            df = df[df['Category'] == filters['category']]\n",
        "\n",
        "        if 'min_change' in filters and filters['min_change']:\n",
        "            df = df[df['Change %'] >= filters['min_change']]\n",
        "\n",
        "        if 'sort_by' in filters and filters['sort_by']:\n",
        "            ascending = filters.get('ascending', False)\n",
        "            df = df.sort_values(filters['sort_by'], ascending=ascending)\n",
        "\n",
        "    display_df = df.copy()\n",
        "    display_df['Last'] = display_df['Last'].apply(format_currency)\n",
        "    display_df['Change %'] = display_df['Change %'].apply(lambda x: add_arrow_indicator(format_percentage(x)))\n",
        "    display_df['5D %'] = display_df['5D %'].apply(lambda x: add_arrow_indicator(format_percentage(x)))\n",
        "    display_df['Volume'] = display_df['Volume'].apply(lambda x: f\"{x:,.0f}\")\n",
        "    display_df['Vol/Avg'] = display_df['Vol/Avg'].apply(lambda x: f\"{x:.2f}x\")\n",
        "\n",
        "    return display_df\n",
        "\n",
        "# ============================================================================\n",
        "# PORTFOLIO DEEP DIVE - ENHANCED\n",
        "# ============================================================================\n",
        "\n",
        "def create_sector_rotation_heatmap(df, start_date, end_date):\n",
        "    \"\"\"Sector rotation heatmap\"\"\"\n",
        "    sector_returns = {}\n",
        "\n",
        "    for _, row in df.iterrows():\n",
        "        ticker = row['Ticker']\n",
        "        sector = row['Sector']\n",
        "\n",
        "        hist_data = fetch_historical_data(ticker, start_date, end_date)\n",
        "        if hist_data is not None and len(hist_data) > 30:\n",
        "            monthly_data = hist_data['Close'].resample('M').last()\n",
        "            monthly_returns = monthly_data.pct_change() * 100\n",
        "\n",
        "            if sector not in sector_returns:\n",
        "                sector_returns[sector] = []\n",
        "\n",
        "            sector_returns[sector].append(monthly_returns)\n",
        "\n",
        "    if not sector_returns:\n",
        "        return None\n",
        "\n",
        "    sector_avg = {}\n",
        "    for sector, returns_list in sector_returns.items():\n",
        "        combined = pd.concat(returns_list, axis=1).mean(axis=1)\n",
        "        sector_avg[sector] = combined\n",
        "\n",
        "    sectors = list(sector_avg.keys())\n",
        "    months = sector_avg[sectors[0]].index\n",
        "\n",
        "    matrix = []\n",
        "    for sector in sectors:\n",
        "        matrix.append(sector_avg[sector].values)\n",
        "\n",
        "    fig = go.Figure(data=go.Heatmap(\n",
        "        z=matrix,\n",
        "        x=[m.strftime('%b %Y') for m in months],\n",
        "        y=sectors,\n",
        "        colorscale='RdYlGn',\n",
        "        zmid=0,\n",
        "        text=np.round(matrix, 1),\n",
        "        texttemplate='%{text}%',\n",
        "        textfont={\"size\": 11},\n",
        "        colorbar=dict(title=\"Return %\")\n",
        "    ))\n",
        "\n",
        "    fig.update_layout(\n",
        "        title=\"üîÑ Sector Rotation Heatmap\",\n",
        "        xaxis_title=\"Month\",\n",
        "        yaxis_title=\"Sector\",\n",
        "        height=500,\n",
        "        paper_bgcolor=COLORS['background'],\n",
        "        plot_bgcolor=COLORS['card_background'],\n",
        "        font=dict(color=COLORS['text_primary'])\n",
        "    )\n",
        "\n",
        "    return fig\n",
        "\n",
        "def create_holdings_attribution_waterfall(df):\n",
        "    \"\"\"Holdings attribution waterfall\"\"\"\n",
        "    top_contributors = df.nlargest(10, 'Total Gain/Loss $')\n",
        "\n",
        "    tickers = top_contributors['Ticker'].tolist()\n",
        "    contributions = top_contributors['Total Gain/Loss $'].tolist()\n",
        "\n",
        "    fig = go.Figure()\n",
        "\n",
        "    fig.add_trace(go.Waterfall(\n",
        "        name=\"Attribution\",\n",
        "        orientation=\"v\",\n",
        "        x=tickers,\n",
        "        y=contributions,\n",
        "        connector={\"line\": {\"color\": COLORS['neon_blue']}},\n",
        "        decreasing={\"marker\": {\"color\": COLORS['danger']}},\n",
        "        increasing={\"marker\": {\"color\": COLORS['success']}},\n",
        "        totals={\"marker\": {\"color\": COLORS['electric_blue']}}\n",
        "    ))\n",
        "\n",
        "    fig.update_layout(\n",
        "        title=\"üíß Holdings Attribution Waterfall\",\n",
        "        xaxis_title=\"Ticker\",\n",
        "        yaxis_title=\"Contribution ($)\",\n",
        "        height=500,\n",
        "        paper_bgcolor=COLORS['background'],\n",
        "        plot_bgcolor=COLORS['card_background'],\n",
        "        font=dict(color=COLORS['text_primary'])\n",
        "    )\n",
        "\n",
        "    return fig\n",
        "\n",
        "def create_concentration_gauge(df):\n",
        "    \"\"\"Concentration gauge\"\"\"\n",
        "    top_5_weight = df.nlargest(5, 'Weight %')['Weight %'].sum()\n",
        "\n",
        "    fig = go.Figure(go.Indicator(\n",
        "        mode=\"gauge+number+delta\",\n",
        "        value=top_5_weight,\n",
        "        title={'text': \"Top 5 Concentration\"},\n",
        "        delta={'reference': 50, 'increasing': {'color': COLORS['warning']}},\n",
        "        gauge={\n",
        "            'axis': {'range': [None, 100]},\n",
        "            'bar': {'color': COLORS['neon_blue']},\n",
        "            'steps': [\n",
        "                {'range': [0, 30], 'color': COLORS['success']},\n",
        "                {'range': [30, 50], 'color': COLORS['warning']},\n",
        "                {'range': [50, 100], 'color': COLORS['danger']}\n",
        "            ],\n",
        "            'threshold': {\n",
        "                'line': {'color': \"red\", 'width': 4},\n",
        "                'thickness': 0.75,\n",
        "                'value': 70\n",
        "            }\n",
        "        }\n",
        "    ))\n",
        "\n",
        "    fig.update_layout(\n",
        "        height=400,\n",
        "        paper_bgcolor=COLORS['background'],\n",
        "        font=dict(color=COLORS['text_primary'])\n",
        "    )\n",
        "\n",
        "    return fig\n",
        "\n",
        "# ============================================================================\n",
        "# MULTI-FACTOR ANALYSIS - ENHANCED\n",
        "# ============================================================================\n",
        "\n",
        "def create_factor_momentum_chart(factor_data):\n",
        "    \"\"\"Factor momentum chart\"\"\"\n",
        "    if factor_data is None or 'factor_returns' not in factor_data:\n",
        "        return None\n",
        "\n",
        "    factor_returns = factor_data['factor_returns']\n",
        "\n",
        "    fig = go.Figure()\n",
        "\n",
        "    colors = [COLORS['neon_blue'], COLORS['electric_blue'], COLORS['teal'],\n",
        "              COLORS['success'], COLORS['purple'], COLORS['pink']]\n",
        "\n",
        "    for idx, factor in enumerate(FACTOR_DEFINITIONS.keys()):\n",
        "        if factor in factor_returns.columns:\n",
        "            cumulative = (1 + factor_returns[factor]).cumprod() - 1\n",
        "            fig.add_trace(go.Scatter(\n",
        "                x=cumulative.index,\n",
        "                y=cumulative.values * 100,\n",
        "                mode='lines',\n",
        "                name=factor,\n",
        "                line=dict(width=2, color=colors[idx % len(colors)])\n",
        "            ))\n",
        "\n",
        "    fig.update_layout(\n",
        "        title=\"üìà Factor Momentum\",\n",
        "        xaxis_title=\"Date\",\n",
        "        yaxis_title=\"Cumulative Return (%)\",\n",
        "        height=600,\n",
        "        hovermode='x unified',\n",
        "        legend=dict(x=0.02, y=0.98),\n",
        "        paper_bgcolor=COLORS['background'],\n",
        "        plot_bgcolor=COLORS['card_background'],\n",
        "        font=dict(color=COLORS['text_primary'])\n",
        "    )\n",
        "\n",
        "    return fig\n",
        "\n",
        "def create_factor_exposure_radar(exposures):\n",
        "    \"\"\"Factor exposure radar\"\"\"\n",
        "    if exposures is None or 'exposures' not in exposures:\n",
        "        return None\n",
        "\n",
        "    exp = exposures['exposures']\n",
        "    factors = [f for f in FACTOR_DEFINITIONS.keys() if f in exp.index]\n",
        "    values = [exp[f] for f in factors]\n",
        "\n",
        "    max_abs = max([abs(v) for v in values]) if values else 1\n",
        "    normalized = [(v / max_abs) * 100 if max_abs > 0 else 0 for v in values]\n",
        "\n",
        "    fig = go.Figure()\n",
        "\n",
        "    fig.add_trace(go.Scatterpolar(\n",
        "        r=normalized,\n",
        "        theta=factors,\n",
        "        fill='toself',\n",
        "        fillcolor='rgba(0, 212, 255, 0.2)',\n",
        "        line=dict(color=COLORS['neon_blue'], width=2),\n",
        "        name='Factor Exposure'\n",
        "    ))\n",
        "\n",
        "    fig.update_layout(\n",
        "        polar=dict(\n",
        "            radialaxis=dict(\n",
        "                visible=True,\n",
        "                range=[0, 100],\n",
        "                color=COLORS['text_secondary']\n",
        "            ),\n",
        "            bgcolor=COLORS['card_background']\n",
        "        ),\n",
        "        title=\"üéØ Factor Exposure Radar\",\n",
        "        height=550,\n",
        "        paper_bgcolor=COLORS['background'],\n",
        "        font=dict(color=COLORS['text_primary'])\n",
        "    )\n",
        "\n",
        "    return fig\n",
        "\n",
        "@st.cache_data(ttl=3600)\n",
        "def calculate_factor_exposures(df, start_date, end_date):\n",
        "    try:\n",
        "        portfolio_returns = calculate_portfolio_returns(df, start_date, end_date)\n",
        "        if not is_valid_series(portfolio_returns):\n",
        "            return None\n",
        "\n",
        "        factor_returns = {}\n",
        "        for factor_name, factor_info in FACTOR_DEFINITIONS.items():\n",
        "            benchmark = factor_info['benchmark']\n",
        "            returns = calculate_benchmark_returns(benchmark, start_date, end_date)\n",
        "            if is_valid_series(returns):\n",
        "                factor_returns[factor_name] = returns\n",
        "\n",
        "        if not factor_returns:\n",
        "            return None\n",
        "\n",
        "        common_dates = portfolio_returns.index\n",
        "        for factor_name in factor_returns:\n",
        "            common_dates = common_dates.intersection(factor_returns[factor_name].index)\n",
        "\n",
        "        X = pd.DataFrame({name: returns.loc[common_dates] for name, returns in factor_returns.items()})\n",
        "        y = portfolio_returns.loc[common_dates]\n",
        "\n",
        "        X['Alpha'] = 1\n",
        "\n",
        "        model = LinearRegression()\n",
        "        model.fit(X, y)\n",
        "\n",
        "        exposures = pd.Series(model.coef_, index=X.columns)\n",
        "        r_squared = model.score(X, y)\n",
        "        predicted_returns = model.predict(X)\n",
        "\n",
        "        asset_exposures = {}\n",
        "        for _, row in df.iterrows():\n",
        "            ticker = row['Ticker']\n",
        "            ticker_returns = calculate_benchmark_returns(ticker, start_date, end_date)\n",
        "            if is_valid_series(ticker_returns):\n",
        "                ticker_aligned = ticker_returns.loc[common_dates]\n",
        "\n",
        "                asset_model = LinearRegression()\n",
        "                asset_model.fit(X, ticker_aligned)\n",
        "\n",
        "                asset_exposures[ticker] = pd.Series(asset_model.coef_, index=X.columns)\n",
        "\n",
        "        return {\n",
        "            'exposures': exposures,\n",
        "            'r_squared': r_squared,\n",
        "            'factor_returns': X,\n",
        "            'portfolio_returns': y,\n",
        "            'predicted_returns': predicted_returns,\n",
        "            'asset_exposures': asset_exposures\n",
        "        }\n",
        "    except:\n",
        "        return None\n",
        "\n",
        "def create_factor_attribution_table(exposures, df):\n",
        "    if exposures is None or 'asset_exposures' not in exposures:\n",
        "        return None, None, None\n",
        "\n",
        "    attribution_data = []\n",
        "\n",
        "    for ticker, asset_exp in exposures['asset_exposures'].items():\n",
        "        asset_row = df[df['Ticker'] == ticker]\n",
        "        if asset_row.empty:\n",
        "            continue\n",
        "\n",
        "        weight = asset_row['Weight %'].values[0] / 100\n",
        "        sector = asset_row['Sector'].values[0]\n",
        "\n",
        "        for factor in FACTOR_DEFINITIONS.keys():\n",
        "            if factor in asset_exp:\n",
        "                contribution = weight * asset_exp[factor]\n",
        "                attribution_data.append({\n",
        "                    'Ticker': ticker,\n",
        "                    'Sector': sector,\n",
        "                    'Factor': factor,\n",
        "                    'Weight': weight * 100,\n",
        "                    'Factor Beta': asset_exp[factor],\n",
        "                    'Contribution': contribution\n",
        "                })\n",
        "\n",
        "    if not attribution_data:\n",
        "        return None, None, None\n",
        "\n",
        "    attr_df = pd.DataFrame(attribution_data)\n",
        "\n",
        "    factor_summary = attr_df.groupby('Factor').agg({\n",
        "        'Contribution': 'sum'\n",
        "    }).reset_index()\n",
        "    factor_summary.columns = ['Factor', 'Total Contribution']\n",
        "\n",
        "    sector_summary = attr_df.groupby(['Sector', 'Factor']).agg({\n",
        "        'Contribution': 'sum'\n",
        "    }).reset_index()\n",
        "\n",
        "    return attr_df, factor_summary, sector_summary\n",
        "\n",
        "# ============================================================================\n",
        "# PERFORMANCE METRICS\n",
        "# ============================================================================\n",
        "\n",
        "def calculate_performance_metrics(df, portfolio_returns, benchmark_returns):\n",
        "    if not is_valid_series(portfolio_returns):\n",
        "        return None\n",
        "\n",
        "    total_return = (1 + portfolio_returns).prod() - 1\n",
        "    n_years = len(portfolio_returns) / 252\n",
        "    annualized_return = (1 + total_return) ** (1/n_years) - 1 if n_years > 0 else 0\n",
        "    annualized_vol = portfolio_returns.std() * np.sqrt(252)\n",
        "\n",
        "    sharpe = calculate_sharpe_ratio(portfolio_returns)\n",
        "    sortino = calculate_sortino_ratio(portfolio_returns)\n",
        "    calmar = calculate_calmar_ratio(portfolio_returns)\n",
        "\n",
        "    info_ratio = calculate_information_ratio(portfolio_returns, benchmark_returns)\n",
        "\n",
        "    var_95 = calculate_var(portfolio_returns, 0.95)\n",
        "    cvar_95 = calculate_cvar(portfolio_returns, 0.95)\n",
        "    max_dd = calculate_max_drawdown(portfolio_returns)\n",
        "\n",
        "    winning_days = (portfolio_returns > 0).sum()\n",
        "    losing_days = (portfolio_returns < 0).sum()\n",
        "    win_rate = winning_days / (winning_days + losing_days) * 100 if (winning_days + losing_days) > 0 else 0\n",
        "\n",
        "    avg_win = portfolio_returns[portfolio_returns > 0].mean() * 100 if winning_days > 0 else 0\n",
        "    avg_loss = portfolio_returns[portfolio_returns < 0].mean() * 100 if losing_days > 0 else 0\n",
        "\n",
        "    best_day = portfolio_returns.max() * 100\n",
        "    worst_day = portfolio_returns.min() * 100\n",
        "\n",
        "    return {\n",
        "        'Total Return': total_return * 100,\n",
        "        'Annualized Return': annualized_return * 100,\n",
        "        'Annualized Volatility': annualized_vol * 100,\n",
        "        'Sharpe Ratio': sharpe,\n",
        "        'Sortino Ratio': sortino,\n",
        "        'Calmar Ratio': calmar,\n",
        "        'Information Ratio': info_ratio,\n",
        "        'VaR (95%)': var_95,\n",
        "        'CVaR (95%)': cvar_95,\n",
        "        'Max Drawdown': max_dd,\n",
        "        'Win Rate': win_rate,\n",
        "        'Avg Win': avg_win,\n",
        "        'Avg Loss': avg_loss,\n",
        "        'Best Day': best_day,\n",
        "        'Worst Day': worst_day,\n",
        "        'Winning Days': winning_days,\n",
        "        'Losing Days': losing_days\n",
        "    }\n",
        "\n",
        "def create_performance_dashboard(metrics):\n",
        "    fig = make_subplots(\n",
        "        rows=2, cols=2,\n",
        "        subplot_titles=('Returns Distribution', 'Risk Metrics',\n",
        "                       'Win/Loss Analysis', 'Risk-Adjusted Returns'),\n",
        "        specs=[[{'type': 'bar'}, {'type': 'scatter'}],\n",
        "               [{'type': 'pie'}, {'type': 'bar'}]]\n",
        "    )\n",
        "\n",
        "    fig.add_trace(\n",
        "        go.Bar(x=['Total', 'Annualized'],\n",
        "               y=[metrics['Total Return'], metrics['Annualized Return']],\n",
        "               marker_color=[COLORS['success'], COLORS['electric_blue']]),\n",
        "        row=1, col=1\n",
        "    )\n",
        "\n",
        "    fig.add_trace(\n",
        "        go.Scatter(x=['Volatility', 'VaR', 'CVaR', 'Max DD'],\n",
        "                  y=[metrics['Annualized Volatility'], abs(metrics['VaR (95%)']),\n",
        "                     abs(metrics['CVaR (95%)']), abs(metrics['Max Drawdown'])],\n",
        "                  mode='markers+lines',\n",
        "                  marker=dict(size=15, color=COLORS['danger'])),\n",
        "        row=1, col=2\n",
        "    )\n",
        "\n",
        "    fig.add_trace(\n",
        "        go.Pie(labels=['Winning Days', 'Losing Days'],\n",
        "               values=[metrics['Winning Days'], metrics['Losing Days']],\n",
        "               marker=dict(colors=[COLORS['success'], COLORS['danger']])),\n",
        "        row=2, col=1\n",
        "    )\n",
        "\n",
        "    fig.add_trace(\n",
        "        go.Bar(x=['Sharpe', 'Sortino', 'Calmar', 'Info'],\n",
        "               y=[metrics['Sharpe Ratio'], metrics['Sortino Ratio'],\n",
        "                  metrics['Calmar Ratio'], metrics['Information Ratio']],\n",
        "               marker_color=COLORS['purple']),\n",
        "        row=2, col=2\n",
        "    )\n",
        "\n",
        "    fig.update_layout(\n",
        "        height=700,\n",
        "        showlegend=False,\n",
        "        title_text=\"üìä Performance Dashboard\",\n",
        "        paper_bgcolor=COLORS['background'],\n",
        "        plot_bgcolor=COLORS['card_background'],\n",
        "        font=dict(color=COLORS['text_primary'])\n",
        "    )\n",
        "\n",
        "    return fig\n",
        "\n",
        "# ============================================================================\n",
        "# VALUATION HOUSE VISUALIZATIONS\n",
        "# ============================================================================\n",
        "\n",
        "def create_dcf_waterfall(dcf_results, method='FCFF'):\n",
        "    \"\"\"Create waterfall chart showing DCF buildup\"\"\"\n",
        "\n",
        "    categories = ['PV of Cash Flows', 'PV of Terminal Value']\n",
        "    values = [dcf_results['total_pv_cash_flows'], dcf_results['pv_terminal']]\n",
        "\n",
        "    if method == 'FCFF':\n",
        "        categories.append('Enterprise Value')\n",
        "        categories.append('Less: Net Debt')\n",
        "        categories.append('Equity Value')\n",
        "        values.append(dcf_results['enterprise_value'])\n",
        "        values.append(-dcf_results.get('net_debt', 0))\n",
        "        values.append(dcf_results['equity_value'])\n",
        "\n",
        "    fig = go.Figure(go.Waterfall(\n",
        "        name=\"DCF Buildup\",\n",
        "        orientation=\"v\",\n",
        "        x=categories,\n",
        "        y=values,\n",
        "        connector={\"line\": {\"color\": COLORS['neon_blue']}},\n",
        "        decreasing={\"marker\": {\"color\": COLORS['danger']}},\n",
        "        increasing={\"marker\": {\"color\": COLORS['success']}},\n",
        "    ))\n",
        "\n",
        "    fig.update_layout(\n",
        "        title=f\"üíé {method} Valuation Buildup\",\n",
        "        yaxis_title=\"Value ($)\",\n",
        "        height=500,\n",
        "        paper_bgcolor=COLORS['background'],\n",
        "        plot_bgcolor=COLORS['card_background'],\n",
        "        font=dict(color=COLORS['text_primary'])\n",
        "    )\n",
        "\n",
        "    return fig\n",
        "\n",
        "def create_cash_flow_chart(projections, method='FCFF'):\n",
        "    \"\"\"Create bar chart of projected cash flows\"\"\"\n",
        "\n",
        "    cf_key = 'fcff' if method == 'FCFF' else 'fcfe'\n",
        "\n",
        "    years = [proj['year'] for proj in projections]\n",
        "    cash_flows = [proj[cf_key] for proj in projections]\n",
        "\n",
        "    fig = go.Figure()\n",
        "\n",
        "    fig.add_trace(go.Bar(\n",
        "        x=years,\n",
        "        y=cash_flows,\n",
        "        marker_color=COLORS['electric_blue'],\n",
        "        name=method\n",
        "    ))\n",
        "\n",
        "    fig.update_layout(\n",
        "        title=f\"üìä Projected {method} by Year\",\n",
        "        xaxis_title=\"Year\",\n",
        "        yaxis_title=f\"{method} ($)\",\n",
        "        height=400,\n",
        "        paper_bgcolor=COLORS['background'],\n",
        "        plot_bgcolor=COLORS['card_background'],\n",
        "        font=dict(color=COLORS['text_primary'])\n",
        "    )\n",
        "\n",
        "    return fig\n",
        "\n",
        "def create_sensitivity_table(base_price, base_discount, base_terminal):\n",
        "    \"\"\"Create sensitivity analysis table\"\"\"\n",
        "\n",
        "    discount_rates = np.linspace(base_discount - 0.02, base_discount + 0.02, 5)\n",
        "    terminal_growth_rates = np.linspace(base_terminal - 0.01, base_terminal + 0.01, 5)\n",
        "\n",
        "    # This is simplified - in real implementation would recalculate DCF\n",
        "    sensitivity_matrix = []\n",
        "    for tr in terminal_growth_rates:\n",
        "        row = []\n",
        "        for dr in discount_rates:\n",
        "            # Simplified sensitivity calculation\n",
        "            adjustment = (1 - (dr - base_discount)) * (1 + (tr - base_terminal))\n",
        "            value = base_price * adjustment\n",
        "            row.append(value)\n",
        "        sensitivity_matrix.append(row)\n",
        "\n",
        "    fig = go.Figure(data=go.Heatmap(\n",
        "        z=sensitivity_matrix,\n",
        "        x=[f\"{dr:.1%}\" for dr in discount_rates],\n",
        "        y=[f\"{tg:.1%}\" for tg in terminal_growth_rates],\n",
        "        colorscale='RdYlGn',\n",
        "        text=[[f\"${v:.2f}\" for v in row] for row in sensitivity_matrix],\n",
        "        texttemplate='%{text}',\n",
        "        textfont={\"size\": 10},\n",
        "        colorbar=dict(title=\"Price\")\n",
        "    ))\n",
        "\n",
        "    fig.update_layout(\n",
        "        title=\"üéØ Sensitivity Analysis\",\n",
        "        xaxis_title=\"Discount Rate\",\n",
        "        yaxis_title=\"Terminal Growth Rate\",\n",
        "        height=400,\n",
        "        paper_bgcolor=COLORS['background'],\n",
        "        plot_bgcolor=COLORS['card_background'],\n",
        "        font=dict(color=COLORS['text_primary'])\n",
        "    )\n",
        "\n",
        "    return fig\n",
        "\n",
        "# ============================================================================\n",
        "# MAIN APP - COMPLETE UNIFIED VERSION\n",
        "# ============================================================================\n",
        "\n",
        "def main():\n",
        "    st.markdown(\"<h1>üî• ATLAS TERMINAL v9.2 UNIFIED</h1>\", unsafe_allow_html=True)\n",
        "    st.markdown(\"<p style='text-align: center; color: #00d4ff; font-size: 18px;'>Complete Portfolio Analytics + Valuation House üíé</p>\", unsafe_allow_html=True)\n",
        "\n",
        "    leverage_info = get_leverage_info()\n",
        "    if leverage_info:\n",
        "        st.markdown(f\"\"\"\n",
        "        <div style=\"background: linear-gradient(135deg, #ff6b00 0%, #ff0044 100%);\n",
        "                    border: 2px solid #ff6b00; border-radius: 8px; padding: 10px; margin-bottom: 10px;\n",
        "                    text-align: center;\">\n",
        "            <span style=\"color: white; font-weight: 600;\">‚ö° LEVERAGED ACCOUNT ‚ö°</span>\n",
        "            <span style=\"color: white; margin-left: 20px;\">Margin: ${leverage_info['margin_used']:,.2f}</span>\n",
        "            <span style=\"color: white; margin-left: 20px;\">Leverage: {leverage_info['leverage_ratio']:.2f}x</span>\n",
        "        </div>\n",
        "        \"\"\", unsafe_allow_html=True)\n",
        "\n",
        "    st.sidebar.markdown(\"## üéõÔ∏è NAVIGATION\")\n",
        "    page = st.sidebar.radio(\"Select Module\", [\n",
        "        \"üî• Phoenix Parser\",\n",
        "        \"üè† Portfolio Home\",\n",
        "        \"üåç Market Watch\",\n",
        "        \"üìà Risk Analysis\",\n",
        "        \"üíé Performance Suite\",\n",
        "        \"üî¨ Portfolio Deep Dive\",\n",
        "        \"üìä Multi-Factor Analysis\",\n",
        "        \"üí∞ Valuation House\",\n",
        "        \"‚ÑπÔ∏è About\"\n",
        "    ])\n",
        "\n",
        "    st.sidebar.markdown(\"---\")\n",
        "    st.sidebar.markdown(\"### üìÖ TIME RANGE\")\n",
        "    date_options = [\"1D\", \"1W\", \"1M\", \"3M\", \"6M\", \"YTD\", \"1Y\", \"3Y\", \"5Y\", \"MAX\"]\n",
        "    selected_range = st.sidebar.selectbox(\"Period\", date_options, index=6)\n",
        "\n",
        "    st.sidebar.markdown(\"---\")\n",
        "    st.sidebar.markdown(\"### üéØ BENCHMARK\")\n",
        "    benchmark_options = [\"SPY\", \"QQQ\", \"DIA\", \"IWM\", \"VTI\", \"ACWI\"]\n",
        "    selected_benchmark = st.sidebar.selectbox(\"Compare Against\", benchmark_options, index=0)\n",
        "\n",
        "    if selected_range == \"YTD\":\n",
        "        start_date = datetime(datetime.now().year, 1, 1)\n",
        "        end_date = datetime.now()\n",
        "    elif selected_range == \"MAX\":\n",
        "        start_date = datetime(2000, 1, 1)\n",
        "        end_date = datetime.now()\n",
        "    else:\n",
        "        days_map = {\"1D\": 1, \"1W\": 7, \"1M\": 30, \"3M\": 90, \"6M\": 180, \"1Y\": 365, \"3Y\": 1095, \"5Y\": 1825}\n",
        "        days = days_map.get(selected_range, 365)\n",
        "        end_date = datetime.now()\n",
        "        start_date = end_date - timedelta(days=days)\n",
        "\n",
        "    # ========================================================================\n",
        "    # PHOENIX PARSER\n",
        "    # ========================================================================\n",
        "    if page == \"üî• Phoenix Parser\":\n",
        "        st.markdown(\"## üî• PHOENIX MODE\")\n",
        "\n",
        "        col1, col2 = st.columns(2)\n",
        "\n",
        "        with col1:\n",
        "            st.markdown(\"### üìä Trade History\")\n",
        "            trade_file = st.file_uploader(\"Upload Trade History\", type=['xls', 'xlsx'], key=\"trade\")\n",
        "\n",
        "            if trade_file:\n",
        "                with st.spinner(\"Parsing...\"):\n",
        "                    trade_df = parse_trade_history_file(trade_file)\n",
        "\n",
        "                    if trade_df is not None:\n",
        "                        save_trade_history(trade_df)\n",
        "                        st.success(f\"‚úÖ Parsed {len(trade_df)} trades!\")\n",
        "                        st.dataframe(trade_df.head(10), use_container_width=True)\n",
        "\n",
        "                        portfolio_df = calculate_portfolio_from_trades(trade_df)\n",
        "                        if len(portfolio_df) > 0:\n",
        "                            save_portfolio_data(portfolio_df.to_dict('records'))\n",
        "                            st.success(f\"üéâ Portfolio rebuilt! {len(portfolio_df)} positions\")\n",
        "                            st.dataframe(portfolio_df, use_container_width=True)\n",
        "\n",
        "        with col2:\n",
        "            st.markdown(\"### üí∞ Account History\")\n",
        "            account_file = st.file_uploader(\"Upload Account History\", type=['xls', 'xlsx'], key=\"account\")\n",
        "\n",
        "            if account_file:\n",
        "                with st.spinner(\"Parsing...\"):\n",
        "                    account_df = parse_account_history_file(account_file)\n",
        "\n",
        "                    if account_df is not None:\n",
        "                        save_account_history(account_df)\n",
        "                        st.success(f\"‚úÖ Parsed {len(account_df)} records!\")\n",
        "                        st.dataframe(account_df.head(10), use_container_width=True)\n",
        "\n",
        "                        leverage_info_parsed = get_leverage_info()\n",
        "                        if leverage_info_parsed:\n",
        "                            st.info(f\"\"\"\n",
        "                            üí° Leverage Detected:\n",
        "                            - Margin: ${leverage_info_parsed['margin_used']:,.2f}\n",
        "                            - Leverage: {leverage_info_parsed['leverage_ratio']:.2f}x\n",
        "                            \"\"\")\n",
        "\n",
        "    # ========================================================================\n",
        "    # PORTFOLIO HOME\n",
        "    # ========================================================================\n",
        "    elif page == \"üè† Portfolio Home\":\n",
        "        st.markdown(\"## üè† PORTFOLIO HOME\")\n",
        "\n",
        "        portfolio_data = load_portfolio_data()\n",
        "\n",
        "        if not portfolio_data:\n",
        "            st.warning(\"‚ö†Ô∏è No portfolio data. Please upload via Phoenix Parser.\")\n",
        "            return\n",
        "\n",
        "        df = pd.DataFrame(portfolio_data)\n",
        "\n",
        "        with st.spinner(\"Loading...\"):\n",
        "            enhanced_df = create_enhanced_holdings_table(df)\n",
        "\n",
        "        total_value = enhanced_df['Total Value'].sum()\n",
        "        total_cost = enhanced_df['Total Cost'].sum()\n",
        "        total_gl = total_value - total_cost\n",
        "        total_gl_pct = (total_gl / total_cost) * 100 if total_cost > 0 else 0\n",
        "        daily_pl = enhanced_df['Daily P&L $'].sum()\n",
        "\n",
        "        col1, col2, col3, col4, col5 = st.columns(5)\n",
        "        col1.metric(\"Total Value\", format_currency(total_value))\n",
        "        col2.metric(\"Total Cost\", format_currency(total_cost))\n",
        "        col3.metric(\"Total G/L\", format_currency(total_gl), format_percentage(total_gl_pct))\n",
        "        col4.metric(\"Daily P&L\", format_currency(daily_pl))\n",
        "        col5.metric(\"Positions\", len(enhanced_df))\n",
        "\n",
        "        st.markdown(\"---\")\n",
        "        st.markdown(\"### üìã Holdings\")\n",
        "        display_df = style_holdings_dataframe(enhanced_df)\n",
        "        st.dataframe(display_df, use_container_width=True, hide_index=True, height=500)\n",
        "\n",
        "        st.info(\"üí° **Tip:** Head to the Valuation House to analyze intrinsic values of any ticker!\")\n",
        "\n",
        "        st.markdown(\"---\")\n",
        "\n",
        "        col1, col2 = st.columns([1, 2])\n",
        "\n",
        "        with col1:\n",
        "            risk_reward = create_risk_reward_plot(enhanced_df)\n",
        "            if risk_reward:\n",
        "                st.plotly_chart(risk_reward, use_container_width=True)\n",
        "\n",
        "        with col2:\n",
        "            perf_heatmap = create_performance_heatmap(enhanced_df)\n",
        "            if perf_heatmap:\n",
        "                st.plotly_chart(perf_heatmap, use_container_width=True)\n",
        "\n",
        "    # ========================================================================\n",
        "    # MARKET WATCH\n",
        "    # ========================================================================\n",
        "    elif page == \"üåç Market Watch\":\n",
        "        st.markdown(\"## üåç MARKET WATCH\")\n",
        "\n",
        "        st.markdown(\"### üîç Filters\")\n",
        "        col1, col2, col3, col4 = st.columns(4)\n",
        "\n",
        "        with col1:\n",
        "            filter_category = st.selectbox(\"Category\", [\"All\", \"US\", \"Europe\", \"Asia\"])\n",
        "        with col2:\n",
        "            filter_change = st.slider(\"Min Change %\", -10.0, 10.0, -10.0)\n",
        "        with col3:\n",
        "            filter_volume = st.selectbox(\"Volume\", [\"All\", \"Above Average\"])\n",
        "        with col4:\n",
        "            sort_by = st.selectbox(\"Sort By\", [\"Change %\", \"5D %\", \"Volume\"])\n",
        "\n",
        "        tab1, tab2, tab3 = st.tabs([\"üìà Indices\", \"üè¶ ETFs\", \"üí∞ Commodities\"])\n",
        "\n",
        "        with tab1:\n",
        "            with st.spinner(\"Loading...\"):\n",
        "                indices_df = fetch_market_watch_data(GLOBAL_INDICES)\n",
        "                if not indices_df.empty:\n",
        "                    if filter_category != \"All\":\n",
        "                        indices_df = indices_df[indices_df['Category'] == filter_category]\n",
        "                    indices_df = indices_df[indices_df['Change %'] >= filter_change]\n",
        "\n",
        "                    display_df = create_dynamic_market_table(indices_df, {'sort_by': sort_by, 'ascending': False})\n",
        "                    st.dataframe(display_df, use_container_width=True, hide_index=True, height=500)\n",
        "\n",
        "        with tab2:\n",
        "            with st.spinner(\"Loading...\"):\n",
        "                etf_df = fetch_market_watch_data(POPULAR_ETFS)\n",
        "                if not etf_df.empty:\n",
        "                    display_df = create_dynamic_market_table(etf_df, {'sort_by': sort_by, 'ascending': False})\n",
        "                    st.dataframe(display_df, use_container_width=True, hide_index=True, height=500)\n",
        "\n",
        "        with tab3:\n",
        "            with st.spinner(\"Loading...\"):\n",
        "                comm_df = fetch_market_watch_data(COMMODITIES)\n",
        "                if not comm_df.empty:\n",
        "                    display_df = create_dynamic_market_table(comm_df, {'sort_by': sort_by, 'ascending': False})\n",
        "                    st.dataframe(display_df, use_container_width=True, hide_index=True, height=500)\n",
        "\n",
        "    # ========================================================================\n",
        "    # RISK ANALYSIS - WORLD CLASS\n",
        "    # ========================================================================\n",
        "    elif page == \"üìà Risk Analysis\":\n",
        "        st.markdown(\"## üìà RISK ANALYSIS - WORLD CLASS\")\n",
        "\n",
        "        portfolio_data = load_portfolio_data()\n",
        "\n",
        "        if not portfolio_data:\n",
        "            st.warning(\"‚ö†Ô∏è No portfolio data.\")\n",
        "            return\n",
        "\n",
        "        df = pd.DataFrame(portfolio_data)\n",
        "        enhanced_df = create_enhanced_holdings_table(df)\n",
        "\n",
        "        with st.spinner(\"Calculating...\"):\n",
        "            portfolio_returns = calculate_portfolio_returns(df, start_date, end_date)\n",
        "            benchmark_returns = calculate_benchmark_returns(selected_benchmark, start_date, end_date)\n",
        "\n",
        "            if not is_valid_series(portfolio_returns):\n",
        "                st.warning(\"Insufficient data\")\n",
        "                return\n",
        "\n",
        "            sharpe = calculate_sharpe_ratio(portfolio_returns)\n",
        "            sortino = calculate_sortino_ratio(portfolio_returns)\n",
        "            calmar = calculate_calmar_ratio(portfolio_returns)\n",
        "            var_95 = calculate_var(portfolio_returns, 0.95)\n",
        "            max_dd = calculate_max_drawdown(portfolio_returns)\n",
        "\n",
        "        col1, col2, col3, col4, col5 = st.columns(5)\n",
        "        col1.metric(\"Sharpe\", f\"{sharpe:.2f}\" if sharpe else \"N/A\")\n",
        "        col2.metric(\"Sortino\", f\"{sortino:.2f}\" if sortino else \"N/A\")\n",
        "        col3.metric(\"Calmar\", f\"{calmar:.2f}\" if calmar else \"N/A\")\n",
        "        col4.metric(\"VaR 95%\", format_percentage(var_95) if var_95 else \"N/A\")\n",
        "        col5.metric(\"Max DD\", format_percentage(max_dd) if max_dd else \"N/A\")\n",
        "\n",
        "        st.markdown(\"---\")\n",
        "\n",
        "        tab1, tab2, tab3, tab4 = st.tabs([\n",
        "            \"üìä Core Risk\", \"üé≤ Monte Carlo\", \"üî¨ Advanced Analytics\", \"‚ö° Stress Tests\"\n",
        "        ])\n",
        "\n",
        "        with tab1:\n",
        "            col1, col2 = st.columns(2)\n",
        "\n",
        "            with col1:\n",
        "                var_chart = create_var_waterfall(portfolio_returns)\n",
        "                if var_chart:\n",
        "                    st.plotly_chart(var_chart, use_container_width=True)\n",
        "\n",
        "                risk_parity = create_risk_parity_analysis(enhanced_df)\n",
        "                if risk_parity:\n",
        "                    st.plotly_chart(risk_parity, use_container_width=True)\n",
        "\n",
        "            with col2:\n",
        "                efficient = create_efficient_frontier(enhanced_df)\n",
        "                if efficient:\n",
        "                    st.plotly_chart(efficient, use_container_width=True)\n",
        "\n",
        "        with tab2:\n",
        "            simulations = run_monte_carlo_simulation(portfolio_returns)\n",
        "            if simulations is not None:\n",
        "                monte_carlo_chart, mc_stats = create_monte_carlo_chart(simulations, 100000)\n",
        "\n",
        "                if monte_carlo_chart:\n",
        "                    st.plotly_chart(monte_carlo_chart, use_container_width=True)\n",
        "\n",
        "                if mc_stats:\n",
        "                    st.markdown(\"#### üìä Simulation Results\")\n",
        "                    st.markdown(f\"\"\"\n",
        "                    **Key Statistics:**\n",
        "                    - Expected Value: ${mc_stats['mean']:,.2f}\n",
        "                    - Median: ${mc_stats['median']:,.2f}\n",
        "                    - Best Case (95th): ${mc_stats['percentile_95']:,.2f}\n",
        "                    - Worst Case (5th): ${mc_stats['percentile_5']:,.2f}\n",
        "                    - Prob of Profit: {mc_stats['prob_profit']:.1f}%\n",
        "                    \"\"\")\n",
        "\n",
        "        with tab3:\n",
        "            col1, col2 = st.columns(2)\n",
        "\n",
        "            with col1:\n",
        "                rolling = create_rolling_metrics_chart(portfolio_returns)\n",
        "                if rolling:\n",
        "                    st.plotly_chart(rolling, use_container_width=True)\n",
        "\n",
        "            with col2:\n",
        "                underwater = create_underwater_plot(portfolio_returns)\n",
        "                if underwater:\n",
        "                    st.plotly_chart(underwater, use_container_width=True)\n",
        "\n",
        "            sunburst = create_risk_contribution_sunburst(enhanced_df)\n",
        "            if sunburst:\n",
        "                st.plotly_chart(sunburst, use_container_width=True)\n",
        "\n",
        "            corr_network = create_correlation_network(enhanced_df, start_date, end_date)\n",
        "            if corr_network:\n",
        "                st.plotly_chart(corr_network, use_container_width=True)\n",
        "\n",
        "        with tab4:\n",
        "            st.info(\"Comprehensive stress testing scenarios...\")\n",
        "\n",
        "    # ========================================================================\n",
        "    # PERFORMANCE SUITE\n",
        "    # ========================================================================\n",
        "    elif page == \"üíé Performance Suite\":\n",
        "        st.markdown(\"## üíé PERFORMANCE SUITE\")\n",
        "\n",
        "        portfolio_data = load_portfolio_data()\n",
        "\n",
        "        if not portfolio_data:\n",
        "            st.warning(\"‚ö†Ô∏è No portfolio data.\")\n",
        "            return\n",
        "\n",
        "        df = pd.DataFrame(portfolio_data)\n",
        "        enhanced_df = create_enhanced_holdings_table(df)\n",
        "\n",
        "        with st.spinner(\"Calculating...\"):\n",
        "            portfolio_returns = calculate_portfolio_returns(df, start_date, end_date)\n",
        "            benchmark_returns = calculate_benchmark_returns(selected_benchmark, start_date, end_date)\n",
        "\n",
        "            metrics = None\n",
        "            if is_valid_series(portfolio_returns):\n",
        "                metrics = calculate_performance_metrics(enhanced_df, portfolio_returns, benchmark_returns)\n",
        "\n",
        "        tab1, tab2, tab3 = st.tabs([\"üìà Interactive Chart\", \"üìä Analytics\", \"üìã Metrics\"])\n",
        "\n",
        "        with tab1:\n",
        "            available_tickers = enhanced_df['Ticker'].tolist()\n",
        "\n",
        "            col1, col2 = st.columns([3, 1])\n",
        "            with col1:\n",
        "                selected_tickers = st.multiselect(\n",
        "                    \"Select Tickers\",\n",
        "                    options=available_tickers + [\"SPY\", \"QQQ\", \"VTI\"],\n",
        "                    default=available_tickers[:min(5, len(available_tickers))]\n",
        "                )\n",
        "\n",
        "            with col2:\n",
        "                custom_ticker = st.text_input(\"Add Custom\", placeholder=\"TSLA\")\n",
        "                if custom_ticker:\n",
        "                    selected_tickers.append(custom_ticker.upper())\n",
        "\n",
        "            if selected_tickers:\n",
        "                perf_chart = create_interactive_performance_chart(selected_tickers, start_date, end_date)\n",
        "                if perf_chart:\n",
        "                    st.plotly_chart(perf_chart, use_container_width=True)\n",
        "\n",
        "        with tab2:\n",
        "            if metrics:\n",
        "                dashboard = create_performance_dashboard(metrics)\n",
        "                st.plotly_chart(dashboard, use_container_width=True)\n",
        "\n",
        "        with tab3:\n",
        "            if metrics:\n",
        "                metrics_df = pd.DataFrame([\n",
        "                    ['Total Return', format_percentage(metrics['Total Return'])],\n",
        "                    ['Annualized Return', format_percentage(metrics['Annualized Return'])],\n",
        "                    ['Volatility', format_percentage(metrics['Annualized Volatility'])],\n",
        "                    ['Sharpe Ratio', f\"{metrics['Sharpe Ratio']:.3f}\"],\n",
        "                    ['Sortino Ratio', f\"{metrics['Sortino Ratio']:.3f}\"],\n",
        "                    ['Calmar Ratio', f\"{metrics['Calmar Ratio']:.3f}\"],\n",
        "                    ['VaR (95%)', format_percentage(metrics['VaR (95%)'])],\n",
        "                    ['Max Drawdown', format_percentage(metrics['Max Drawdown'])],\n",
        "                    ['Win Rate', format_percentage(metrics['Win Rate'])],\n",
        "                    ['Best Day', format_percentage(metrics['Best Day'])],\n",
        "                    ['Worst Day', format_percentage(metrics['Worst Day'])]\n",
        "                ], columns=['Metric', 'Value'])\n",
        "\n",
        "                st.dataframe(metrics_df, use_container_width=True, hide_index=True, height=600)\n",
        "\n",
        "    # ========================================================================\n",
        "    # PORTFOLIO DEEP DIVE - ENHANCED\n",
        "    # ========================================================================\n",
        "    elif page == \"üî¨ Portfolio Deep Dive\":\n",
        "        st.markdown(\"## üî¨ PORTFOLIO DEEP DIVE\")\n",
        "\n",
        "        portfolio_data = load_portfolio_data()\n",
        "\n",
        "        if not portfolio_data:\n",
        "            st.warning(\"‚ö†Ô∏è No portfolio data.\")\n",
        "            return\n",
        "\n",
        "        df = pd.DataFrame(portfolio_data)\n",
        "        enhanced_df = create_enhanced_holdings_table(df)\n",
        "\n",
        "        tab1, tab2, tab3 = st.tabs([\n",
        "            \"üéØ Attribution\", \"üîÑ Sector Rotation\", \"üìä Concentration\"\n",
        "        ])\n",
        "\n",
        "        with tab1:\n",
        "            col1, col2 = st.columns(2)\n",
        "\n",
        "            with col1:\n",
        "                heatmap = create_portfolio_heatmap(enhanced_df)\n",
        "                if heatmap:\n",
        "                    st.plotly_chart(heatmap, use_container_width=True)\n",
        "\n",
        "            with col2:\n",
        "                waterfall = create_holdings_attribution_waterfall(enhanced_df)\n",
        "                if waterfall:\n",
        "                    st.plotly_chart(waterfall, use_container_width=True)\n",
        "\n",
        "        with tab2:\n",
        "            rotation = create_sector_rotation_heatmap(enhanced_df, start_date, end_date)\n",
        "            if rotation:\n",
        "                st.plotly_chart(rotation, use_container_width=True)\n",
        "\n",
        "        with tab3:\n",
        "            col1, col2 = st.columns([1, 2])\n",
        "\n",
        "            with col1:\n",
        "                gauge = create_concentration_gauge(enhanced_df)\n",
        "                if gauge:\n",
        "                    st.plotly_chart(gauge, use_container_width=True)\n",
        "\n",
        "            with col2:\n",
        "                st.markdown(\"### Top 10 Holdings\")\n",
        "                top10 = enhanced_df.nlargest(10, 'Weight %')[['Ticker', 'Asset Name', 'Weight %', 'Total Gain/Loss %']]\n",
        "                top10_display = top10.copy()\n",
        "                top10_display['Weight %'] = top10_display['Weight %'].apply(format_percentage)\n",
        "                top10_display['Total Gain/Loss %'] = top10_display['Total Gain/Loss %'].apply(format_percentage)\n",
        "                st.dataframe(top10_display, use_container_width=True, hide_index=True)\n",
        "\n",
        "    # ========================================================================\n",
        "    # MULTI-FACTOR ANALYSIS - ENHANCED\n",
        "    # ========================================================================\n",
        "    elif page == \"üìä Multi-Factor Analysis\":\n",
        "        st.markdown(\"## üìä MULTI-FACTOR ANALYSIS\")\n",
        "\n",
        "        portfolio_data = load_portfolio_data()\n",
        "\n",
        "        if not portfolio_data:\n",
        "            st.warning(\"‚ö†Ô∏è No portfolio data.\")\n",
        "            return\n",
        "\n",
        "        df = pd.DataFrame(portfolio_data)\n",
        "        enhanced_df = create_enhanced_holdings_table(df)\n",
        "\n",
        "        with st.spinner(\"Running analysis...\"):\n",
        "            factor_data = calculate_factor_exposures(enhanced_df, start_date, end_date)\n",
        "\n",
        "        if factor_data:\n",
        "            st.markdown(f\"**Model R¬≤ = {factor_data['r_squared']:.3f}**\")\n",
        "            st.progress(factor_data['r_squared'])\n",
        "\n",
        "            result = create_factor_attribution_table(factor_data, enhanced_df)\n",
        "\n",
        "            tab1, tab2, tab3 = st.tabs([\n",
        "                \"üìà Factor Momentum\", \"üéØ Exposure Radar\", \"üìä Attribution\"\n",
        "            ])\n",
        "\n",
        "            with tab1:\n",
        "                momentum = create_factor_momentum_chart(factor_data)\n",
        "                if momentum:\n",
        "                    st.plotly_chart(momentum, use_container_width=True)\n",
        "\n",
        "            with tab2:\n",
        "                radar = create_factor_exposure_radar(factor_data)\n",
        "                if radar:\n",
        "                    st.plotly_chart(radar, use_container_width=True)\n",
        "\n",
        "            with tab3:\n",
        "                if result is not None:\n",
        "                    attr_df, factor_summary, sector_summary = result\n",
        "\n",
        "                    if factor_summary is not None:\n",
        "                        st.markdown(\"### Factor Summary\")\n",
        "                        factor_display = factor_summary.copy()\n",
        "                        factor_display['Total Contribution'] = factor_display['Total Contribution'].apply(\n",
        "                            lambda x: f\"{x:.4f}\")\n",
        "                        st.dataframe(factor_display, use_container_width=True, hide_index=True)\n",
        "\n",
        "                    if attr_df is not None:\n",
        "                        st.markdown(\"### Holdings Attribution\")\n",
        "                        holdings_attr = attr_df.pivot_table(\n",
        "                            index='Ticker',\n",
        "                            columns='Factor',\n",
        "                            values='Contribution',\n",
        "                            aggfunc='sum'\n",
        "                        ).round(4)\n",
        "\n",
        "                        st.dataframe(holdings_attr, use_container_width=True)\n",
        "\n",
        "                        st.info(\"\"\"\n",
        "                        **Positive values**: Holding increases exposure\n",
        "                        **Negative values**: Holding decreases exposure\n",
        "                        \"\"\")\n",
        "        else:\n",
        "            st.error(\"Unable to calculate factor exposures.\")\n",
        "\n",
        "    # ========================================================================\n",
        "    # VALUATION HOUSE - COMPLETE DCF ENGINE\n",
        "    # ========================================================================\n",
        "    elif page == \"üí∞ Valuation House\":\n",
        "        st.markdown(\"## üí∞ VALUATION HOUSE\")\n",
        "        st.markdown(\"### Professional DCF Valuation Engine\")\n",
        "\n",
        "        st.info(\"üéØ **Quick Start:** Enter a ticker, select valuation method (FCFF/FCFE), adjust assumptions, and calculate intrinsic value.\")\n",
        "\n",
        "        # Company Search Section\n",
        "        st.markdown(\"---\")\n",
        "        st.markdown(\"#### üîç Company Search\")\n",
        "\n",
        "        col1, col2 = st.columns([3, 1])\n",
        "\n",
        "        with col1:\n",
        "            ticker_input = st.text_input(\n",
        "                \"Enter Ticker Symbol\",\n",
        "                placeholder=\"e.g., AAPL, MSFT, GOOGL\",\n",
        "                help=\"Enter any publicly traded company ticker\"\n",
        "            ).upper()\n",
        "\n",
        "        with col2:\n",
        "            search_button = st.button(\"üöÄ Load Company\", type=\"primary\", use_container_width=True)\n",
        "\n",
        "        if search_button and ticker_input:\n",
        "            with st.spinner(f\"üìä Fetching data for {ticker_input}...\"):\n",
        "                company_data = fetch_company_financials(ticker_input)\n",
        "\n",
        "                if company_data['success']:\n",
        "                    st.session_state['valuation_company'] = company_data\n",
        "                    st.success(f\"‚úÖ Loaded {company_data['company']['name']}\")\n",
        "                else:\n",
        "                    st.error(f\"‚ùå Could not fetch data for {ticker_input}: {company_data.get('error', 'Unknown error')}\")\n",
        "\n",
        "        # Display valuation if company is loaded\n",
        "        if 'valuation_company' in st.session_state:\n",
        "            company = st.session_state['valuation_company']['company']\n",
        "            financials = st.session_state['valuation_company']['financials']\n",
        "\n",
        "            st.markdown(\"---\")\n",
        "\n",
        "            # Company Overview\n",
        "            st.markdown(f\"### üìä {company['name']} ({company['ticker']})\")\n",
        "\n",
        "            col1, col2, col3, col4, col5 = st.columns(5)\n",
        "            col1.metric(\"Current Price\", format_currency(company['current_price']))\n",
        "            col2.metric(\"Market Cap\", format_large_number(company['market_cap']))\n",
        "            col3.metric(\"Sector\", company['sector'])\n",
        "            col4.metric(\"Beta\", f\"{company['beta']:.2f}\")\n",
        "            col5.metric(\"Forward P/E\", f\"{company.get('forward_pe', 'N/A'):.1f}\" if company.get('forward_pe') else \"N/A\")\n",
        "\n",
        "            st.markdown(\"---\")\n",
        "\n",
        "            # DCF Method Selection\n",
        "            st.markdown(\"#### üéØ Valuation Method\")\n",
        "\n",
        "            col1, col2 = st.columns([1, 3])\n",
        "\n",
        "            with col1:\n",
        "                dcf_method = st.radio(\n",
        "                    \"Select DCF Method\",\n",
        "                    options=['FCFF', 'FCFE'],\n",
        "                    help=\"FCFF: Free Cash Flow to Firm | FCFE: Free Cash Flow to Equity\"\n",
        "                )\n",
        "\n",
        "            with col2:\n",
        "                st.markdown(f\"\"\"\n",
        "                **{'Free Cash Flow to Firm (FCFF)' if dcf_method == 'FCFF' else 'Free Cash Flow to Equity (FCFE)'}**\n",
        "\n",
        "                {'Cash flows available to all investors (debt + equity holders). Discounted at WACC.' if dcf_method == 'FCFF' else 'Cash flows available to equity holders only. Discounted at cost of equity.'}\n",
        "                \"\"\")\n",
        "\n",
        "            st.markdown(\"---\")\n",
        "\n",
        "            # Assumptions Panel\n",
        "            st.markdown(\"#### üéõÔ∏è Valuation Assumptions\")\n",
        "\n",
        "            tab1, tab2, tab3 = st.tabs([\"üìà Growth & Operations\", \"üí∞ Cost of Capital\", \"üéØ Terminal Value\"])\n",
        "\n",
        "            with tab1:\n",
        "                st.markdown(\"##### Growth & Operating Assumptions\")\n",
        "\n",
        "                col1, col2 = st.columns(2)\n",
        "\n",
        "                with col1:\n",
        "                    revenue_growth = st.slider(\n",
        "                        \"Revenue Growth Rate (%)\",\n",
        "                        min_value=-10.0,\n",
        "                        max_value=30.0,\n",
        "                        value=5.0,\n",
        "                        step=0.5,\n",
        "                        help=\"Expected annual revenue growth rate\"\n",
        "                    ) / 100\n",
        "\n",
        "                    ebit_margin = st.slider(\n",
        "                        \"EBIT Margin (%)\",\n",
        "                        min_value=0.0,\n",
        "                        max_value=50.0,\n",
        "                        value=20.0,\n",
        "                        step=1.0,\n",
        "                        help=\"Operating profit margin\"\n",
        "                    ) / 100\n",
        "\n",
        "                    forecast_years = st.slider(\n",
        "                        \"Forecast Horizon (Years)\",\n",
        "                        min_value=3,\n",
        "                        max_value=15,\n",
        "                        value=5,\n",
        "                        step=1,\n",
        "                        help=\"Number of years to project\"\n",
        "                    )\n",
        "\n",
        "                with col2:\n",
        "                    capex_pct = st.slider(\n",
        "                        \"CapEx (% of Revenue)\",\n",
        "                        min_value=0.0,\n",
        "                        max_value=20.0,\n",
        "                        value=5.0,\n",
        "                        step=0.5,\n",
        "                        help=\"Capital expenditure as % of revenue\"\n",
        "                    ) / 100\n",
        "\n",
        "                    depreciation_pct = st.slider(\n",
        "                        \"Depreciation (% of Revenue)\",\n",
        "                        min_value=0.0,\n",
        "                        max_value=15.0,\n",
        "                        value=3.0,\n",
        "                        step=0.5,\n",
        "                        help=\"Depreciation as % of revenue\"\n",
        "                    ) / 100\n",
        "\n",
        "                    wc_change = st.number_input(\n",
        "                        \"Working Capital Change ($M)\",\n",
        "                        min_value=-1000.0,\n",
        "                        max_value=1000.0,\n",
        "                        value=0.0,\n",
        "                        step=10.0,\n",
        "                        help=\"Annual change in working capital\"\n",
        "                    ) * 1e6\n",
        "\n",
        "            with tab2:\n",
        "                st.markdown(\"##### Cost of Capital Assumptions\")\n",
        "\n",
        "                col1, col2 = st.columns(2)\n",
        "\n",
        "                with col1:\n",
        "                    risk_free = st.slider(\n",
        "                        \"Risk-Free Rate (%)\",\n",
        "                        min_value=0.0,\n",
        "                        max_value=10.0,\n",
        "                        value=4.5,\n",
        "                        step=0.1,\n",
        "                        help=\"10-year Treasury yield\"\n",
        "                    ) / 100\n",
        "\n",
        "                    market_risk_premium = st.slider(\n",
        "                        \"Market Risk Premium (%)\",\n",
        "                        min_value=3.0,\n",
        "                        max_value=10.0,\n",
        "                        value=6.0,\n",
        "                        step=0.5,\n",
        "                        help=\"Expected market return above risk-free rate\"\n",
        "                    ) / 100\n",
        "\n",
        "                    beta = st.number_input(\n",
        "                        \"Beta\",\n",
        "                        min_value=0.0,\n",
        "                        max_value=3.0,\n",
        "                        value=float(company['beta']) if company['beta'] else 1.0,\n",
        "                        step=0.1,\n",
        "                        help=\"Stock's systematic risk\"\n",
        "                    )\n",
        "\n",
        "                with col2:\n",
        "                    if dcf_method == 'FCFF':\n",
        "                        cost_debt = st.slider(\n",
        "                            \"Cost of Debt (%)\",\n",
        "                            min_value=0.0,\n",
        "                            max_value=15.0,\n",
        "                            value=5.0,\n",
        "                            step=0.5,\n",
        "                            help=\"Interest rate on debt\"\n",
        "                        ) / 100\n",
        "\n",
        "                    tax_rate = st.slider(\n",
        "                        \"Tax Rate (%)\",\n",
        "                        min_value=0.0,\n",
        "                        max_value=40.0,\n",
        "                        value=float(financials.get('tax_rate', 0.21) * 100),\n",
        "                        step=1.0,\n",
        "                        help=\"Corporate tax rate\"\n",
        "                    ) / 100\n",
        "\n",
        "                    if dcf_method == 'FCFE':\n",
        "                        net_borrowing = st.number_input(\n",
        "                            \"Net Borrowing ($M)\",\n",
        "                            min_value=-1000.0,\n",
        "                            max_value=1000.0,\n",
        "                            value=0.0,\n",
        "                            step=10.0,\n",
        "                            help=\"Annual net debt increase/(decrease)\"\n",
        "                        ) * 1e6\n",
        "\n",
        "            with tab3:\n",
        "                st.markdown(\"##### Terminal Value Assumptions\")\n",
        "\n",
        "                col1, col2 = st.columns(2)\n",
        "\n",
        "                with col1:\n",
        "                    terminal_growth = st.slider(\n",
        "                        \"Perpetual Growth Rate (%)\",\n",
        "                        min_value=0.0,\n",
        "                        max_value=5.0,\n",
        "                        value=2.5,\n",
        "                        step=0.1,\n",
        "                        help=\"Long-term growth rate for terminal value\"\n",
        "                    ) / 100\n",
        "\n",
        "                with col2:\n",
        "                    st.info(f\"\"\"\n",
        "                    **Terminal Value Method:** Gordon Growth Model\n",
        "\n",
        "                    TV = FCF‚Çô‚Çä‚ÇÅ / (r - g)\n",
        "\n",
        "                    Where:\n",
        "                    - FCF‚Çô‚Çä‚ÇÅ = Final year FCF √ó (1 + g)\n",
        "                    - r = Discount rate\n",
        "                    - g = Perpetual growth rate\n",
        "                    \"\"\")\n",
        "\n",
        "            st.markdown(\"---\")\n",
        "\n",
        "            # Calculate DCF\n",
        "            if st.button(\"üöÄ Calculate Intrinsic Value\", type=\"primary\", use_container_width=True):\n",
        "                with st.spinner(\"üî¨ Running DCF Analysis...\"):\n",
        "\n",
        "                    # Calculate cost of equity\n",
        "                    cost_equity = calculate_cost_of_equity(risk_free, beta, market_risk_premium)\n",
        "\n",
        "                    # Calculate discount rate\n",
        "                    if dcf_method == 'FCFF':\n",
        "                        # Calculate WACC\n",
        "                        total_debt = financials.get('total_debt', 0)\n",
        "                        total_equity = company['market_cap']\n",
        "                        discount_rate = calculate_wacc(cost_equity, cost_debt, tax_rate, total_debt, total_equity)\n",
        "                    else:\n",
        "                        # Use cost of equity for FCFE\n",
        "                        discount_rate = cost_equity\n",
        "\n",
        "                    # Get base financials\n",
        "                    base_revenue = financials.get('revenue', 0)\n",
        "                    base_ebit = financials.get('ebit', 0)\n",
        "                    base_net_income = financials.get('net_income', 0)\n",
        "\n",
        "                    # Calculate per-year amounts\n",
        "                    depreciation = base_revenue * depreciation_pct\n",
        "                    capex = base_revenue * capex_pct\n",
        "\n",
        "                    # Project cash flows\n",
        "                    if dcf_method == 'FCFF':\n",
        "                        projections = project_fcff(\n",
        "                            base_ebit, revenue_growth, ebit_margin, tax_rate,\n",
        "                            depreciation, capex, wc_change, forecast_years\n",
        "                        )\n",
        "                        final_fcf = projections[-1]['fcff']\n",
        "                    else:\n",
        "                        projections = project_fcfe(\n",
        "                            base_net_income, revenue_growth, tax_rate,\n",
        "                            depreciation, capex, wc_change, net_borrowing, forecast_years\n",
        "                        )\n",
        "                        final_fcf = projections[-1]['fcfe']\n",
        "\n",
        "                    # Calculate terminal value\n",
        "                    terminal_value = calculate_terminal_value(final_fcf, discount_rate, terminal_growth)\n",
        "\n",
        "                    # Calculate DCF value\n",
        "                    net_debt = financials.get('total_debt', 0) - financials.get('cash', 0)\n",
        "                    shares = company['shares_outstanding']\n",
        "\n",
        "                    dcf_results = calculate_dcf_value(\n",
        "                        projections, discount_rate, terminal_value, shares,\n",
        "                        net_debt if dcf_method == 'FCFF' else 0, dcf_method\n",
        "                    )\n",
        "\n",
        "                    dcf_results['net_debt'] = net_debt\n",
        "\n",
        "                    # Store results\n",
        "                    st.session_state['dcf_results'] = dcf_results\n",
        "                    st.session_state['dcf_projections'] = projections\n",
        "                    st.session_state['dcf_method'] = dcf_method\n",
        "                    st.session_state['discount_rate'] = discount_rate\n",
        "                    st.session_state['terminal_growth'] = terminal_growth\n",
        "\n",
        "                    st.success(\"‚úÖ Valuation Complete!\")\n",
        "\n",
        "            # Display Results\n",
        "            if 'dcf_results' in st.session_state:\n",
        "                results = st.session_state['dcf_results']\n",
        "                projections = st.session_state['dcf_projections']\n",
        "                method = st.session_state['dcf_method']\n",
        "\n",
        "                st.markdown(\"---\")\n",
        "                st.markdown(\"### üìä Valuation Results\")\n",
        "\n",
        "                # Key metrics\n",
        "                intrinsic_value = results['intrinsic_value_per_share']\n",
        "                current_price = company['current_price']\n",
        "                upside_downside = ((intrinsic_value - current_price) / current_price) * 100\n",
        "\n",
        "                col1, col2, col3, col4 = st.columns(4)\n",
        "\n",
        "                col1.metric(\n",
        "                    \"Intrinsic Value\",\n",
        "                    format_currency(intrinsic_value),\n",
        "                    delta=format_percentage(upside_downside) if abs(upside_downside) < 1000 else \"¬±‚àû\"\n",
        "                )\n",
        "\n",
        "                col2.metric(\n",
        "                    \"Current Price\",\n",
        "                    format_currency(current_price)\n",
        "                )\n",
        "\n",
        "                col3.metric(\n",
        "                    \"Upside/Downside\",\n",
        "                    format_percentage(upside_downside) if abs(upside_downside) < 1000 else \"¬±‚àû\",\n",
        "                    delta=\"Undervalued\" if upside_downside > 0 else \"Overvalued\"\n",
        "                )\n",
        "\n",
        "                col4.metric(\n",
        "                    \"Discount Rate\",\n",
        "                    format_percentage(st.session_state['discount_rate'] * 100)\n",
        "                )\n",
        "\n",
        "                # Valuation interpretation\n",
        "                st.markdown(\"---\")\n",
        "\n",
        "                if upside_downside > 20:\n",
        "                    st.success(f\"\"\"\n",
        "                    ‚úÖ **Significantly Undervalued**\n",
        "\n",
        "                    The intrinsic value of ${intrinsic_value:.2f} suggests the stock is trading at a {abs(upside_downside):.1f}% discount to fair value.\n",
        "                    This represents a potential buying opportunity based on DCF analysis.\n",
        "                    \"\"\")\n",
        "                elif upside_downside > 0:\n",
        "                    st.info(f\"\"\"\n",
        "                    üìä **Slightly Undervalued**\n",
        "\n",
        "                    The intrinsic value of ${intrinsic_value:.2f} suggests modest upside potential of {upside_downside:.1f}%.\n",
        "                    Stock appears fairly valued with some room for appreciation.\n",
        "                    \"\"\")\n",
        "                elif upside_downside > -20:\n",
        "                    st.warning(f\"\"\"\n",
        "                    ‚ö†Ô∏è **Slightly Overvalued**\n",
        "\n",
        "                    The intrinsic value of ${intrinsic_value:.2f} suggests the stock is trading {abs(upside_downside):.1f}% above fair value.\n",
        "                    Consider waiting for better entry points.\n",
        "                    \"\"\")\n",
        "                else:\n",
        "                    st.error(f\"\"\"\n",
        "                    ‚ùå **Significantly Overvalued**\n",
        "\n",
        "                    The intrinsic value of ${intrinsic_value:.2f} suggests the stock is trading at a {abs(upside_downside):.1f}% premium to fair value.\n",
        "                    High risk of downside based on current DCF assumptions.\n",
        "                    \"\"\")\n",
        "\n",
        "                st.markdown(\"---\")\n",
        "\n",
        "                # Visualizations\n",
        "                col1, col2 = st.columns(2)\n",
        "\n",
        "                with col1:\n",
        "                    waterfall = create_dcf_waterfall(results, method)\n",
        "                    st.plotly_chart(waterfall, use_container_width=True)\n",
        "\n",
        "                with col2:\n",
        "                    cf_chart = create_cash_flow_chart(projections, method)\n",
        "                    st.plotly_chart(cf_chart, use_container_width=True)\n",
        "\n",
        "                # Sensitivity Analysis\n",
        "                st.markdown(\"---\")\n",
        "                st.markdown(\"#### üéØ Sensitivity Analysis\")\n",
        "\n",
        "                sensitivity = create_sensitivity_table(\n",
        "                    intrinsic_value,\n",
        "                    st.session_state['discount_rate'],\n",
        "                    st.session_state['terminal_growth']\n",
        "                )\n",
        "                st.plotly_chart(sensitivity, use_container_width=True)\n",
        "\n",
        "                # Detailed Projections Table\n",
        "                st.markdown(\"---\")\n",
        "                st.markdown(\"#### üìã Detailed Cash Flow Projections\")\n",
        "\n",
        "                proj_df = pd.DataFrame(projections)\n",
        "\n",
        "                # Format for display\n",
        "                if method == 'FCFF':\n",
        "                    display_cols = ['year', 'ebit', 'nopat', 'depreciation', 'capex', 'change_wc', 'fcff']\n",
        "                    col_names = ['Year', 'EBIT', 'NOPAT', 'D&A', 'CapEx', 'ŒîWC', 'FCFF']\n",
        "                else:\n",
        "                    display_cols = ['year', 'net_income', 'depreciation', 'capex', 'change_wc', 'net_borrowing', 'fcfe']\n",
        "                    col_names = ['Year', 'Net Income', 'D&A', 'CapEx', 'ŒîWC', 'Borrowing', 'FCFE']\n",
        "\n",
        "                proj_display = proj_df[display_cols].copy()\n",
        "                proj_display.columns = col_names\n",
        "\n",
        "                # Format numbers\n",
        "                for col in proj_display.columns:\n",
        "                    if col != 'Year':\n",
        "                        proj_display[col] = proj_display[col].apply(format_large_number)\n",
        "\n",
        "                st.dataframe(proj_display, use_container_width=True, hide_index=True)\n",
        "\n",
        "                # Export Options\n",
        "                st.markdown(\"---\")\n",
        "                col1, col2, col3 = st.columns(3)\n",
        "\n",
        "                with col1:\n",
        "                    if st.button(\"üì• Export to Excel\", use_container_width=True):\n",
        "                        st.info(\"Excel export feature coming soon!\")\n",
        "\n",
        "                with col2:\n",
        "                    if st.button(\"üìÑ Generate PDF Report\", use_container_width=True):\n",
        "                        st.info(\"PDF export feature coming soon!\")\n",
        "\n",
        "                with col3:\n",
        "                    if st.button(\"üîÑ Reset Valuation\", use_container_width=True):\n",
        "                        if 'dcf_results' in st.session_state:\n",
        "                            del st.session_state['dcf_results']\n",
        "                        if 'dcf_projections' in st.session_state:\n",
        "                            del st.session_state['dcf_projections']\n",
        "                        st.rerun()\n",
        "\n",
        "        else:\n",
        "            # No company loaded - show instructions\n",
        "            st.markdown(\"---\")\n",
        "            st.markdown(\"\"\"\n",
        "            ### üìö How to Use Valuation House\n",
        "\n",
        "            **Step 1: Search for a Company**\n",
        "            - Enter any publicly traded ticker symbol (e.g., AAPL, MSFT, TSLA)\n",
        "            - Click \"Load Company\" to fetch financial data\n",
        "\n",
        "            **Step 2: Choose Valuation Method**\n",
        "            - **FCFF (Free Cash Flow to Firm):** Values entire enterprise, then subtracts debt\n",
        "            - **FCFE (Free Cash Flow to Equity):** Direct equity valuation\n",
        "\n",
        "            **Step 3: Adjust Assumptions**\n",
        "            - Growth rates, margins, capital expenditure\n",
        "            - Cost of capital (WACC or cost of equity)\n",
        "            - Terminal value assumptions\n",
        "\n",
        "            **Step 4: Calculate & Analyze**\n",
        "            - Click \"Calculate Intrinsic Value\"\n",
        "            - Review valuation vs. current price\n",
        "            - Analyze sensitivity to key assumptions\n",
        "\n",
        "            **Step 5: Export Results**\n",
        "            - Export to Excel or PDF for reports\n",
        "            - Save assumptions for future reference\n",
        "\n",
        "            ---\n",
        "\n",
        "            ### üí° Pro Tips\n",
        "\n",
        "            - **Compare Methods:** Run both FCFF and FCFE to cross-check results\n",
        "            - **Sensitivity Analysis:** Test multiple scenarios (bull/base/bear)\n",
        "            - **Quality Check:** Ensure financial data is reasonable and complete\n",
        "            - **Context Matters:** Consider industry dynamics, competitive position, and macro factors\n",
        "\n",
        "            ---\n",
        "\n",
        "            *Ready to start? Enter a ticker symbol above!* üöÄ\n",
        "            \"\"\")\n",
        "\n",
        "    # ========================================================================\n",
        "    # ABOUT\n",
        "    # ========================================================================\n",
        "    elif page == \"‚ÑπÔ∏è About\":\n",
        "        st.markdown(\"### ‚ÑπÔ∏è ATLAS Terminal v9.2 UNIFIED\")\n",
        "        st.success(\"\"\"\n",
        "        **ATLAS v9.2 UNIFIED EDITION** üî•üíé\n",
        "\n",
        "        **COMPLETE INTEGRATION:**\n",
        "        ‚úÖ All v8.8 Core Phoenix Mode Features\n",
        "        ‚úÖ Complete Valuation House DCF Engine\n",
        "        ‚úÖ 8 Complete Modules Fully Functional\n",
        "        ‚úÖ World-Class Visualizations Preserved\n",
        "        ‚úÖ All Enhancements and Optimizations\n",
        "\n",
        "        **MODULE LIST:**\n",
        "        1. **Phoenix Parser** - Exceptional data parsing for trades & account history\n",
        "        2. **Portfolio Home** - Enhanced holdings analysis with analyst ratings\n",
        "        3. **Market Watch** - Global markets, ETFs, and commodities monitoring\n",
        "        4. **Risk Analysis** - World-class risk metrics (8+ visualizations)\n",
        "        5. **Performance Suite** - Comprehensive performance analytics\n",
        "        6. **Portfolio Deep Dive** - Institutional-grade attribution analysis\n",
        "        7. **Multi-Factor Analysis** - Advanced factor exposure & attribution\n",
        "        8. **Valuation House** - Professional DCF valuation engine (FCFF/FCFE)\n",
        "\n",
        "        **KEY FEATURES:**\n",
        "        - 150+ analytics features\n",
        "        - 100+ world-class visualizations\n",
        "        - Real-time market data\n",
        "        - Monte Carlo simulations\n",
        "        - Efficient frontier analysis\n",
        "        - DCF valuation with sensitivity analysis\n",
        "        - Factor attribution models\n",
        "        - Risk parity analysis\n",
        "        - Correlation networks\n",
        "        - And much more!\n",
        "\n",
        "        **WHAT'S UNIFIED:**\n",
        "        - Complete v8.8 Core Phoenix Mode (all modules)\n",
        "        - Complete v9.1 Valuation House (DCF engine)\n",
        "        - Optimized helper functions\n",
        "        - Seamless navigation\n",
        "        - Professional theme throughout\n",
        "\n",
        "        Total: **The Ultimate Investment Analysis Platform!** üöÄ\n",
        "        \"\"\")\n",
        "\n",
        "if __name__ == \"__main__\":\n",
        "    main()\n",
        "'''\n",
        "\n",
        "# Write app\n",
        "with open(\"atlas_app.py\", \"w\", encoding=\"utf-8\") as f:\n",
        "    f.write(app_code)\n",
        "\n",
        "print(\"‚úÖ ATLAS v9.2 UNIFIED EDITION created!\")\n",
        "\n",
        "# ============================================================================\n",
        "# RUN APP\n",
        "# ============================================================================\n",
        "print(\"\\n\" + \"=\"*80)\n",
        "print(\"üöÄ LAUNCHING ATLAS TERMINAL v9.2 UNIFIED EDITION\")\n",
        "print(\"=\"*80)\n",
        "print(\"‚ú® COMPLETE CONSOLIDATION:\")\n",
        "print(\"  ‚úÖ All v8.8 Core Phoenix Mode Features\")\n",
        "print(\"  ‚úÖ Complete Valuation House DCF Engine\")\n",
        "print(\"  ‚úÖ 8 Modules Fully Integrated\")\n",
        "print(\"  ‚úÖ World-Class Visualizations Preserved\")\n",
        "print(\"  ‚úÖ All Enhancements Optimized\")\n",
        "print(\"\\nüìä MODULE LIST:\")\n",
        "print(\"  1. Phoenix Parser\")\n",
        "print(\"  2. Portfolio Home\")\n",
        "print(\"  3. Market Watch\")\n",
        "print(\"  4. Risk Analysis\")\n",
        "print(\"  5. Performance Suite\")\n",
        "print(\"  6. Portfolio Deep Dive\")\n",
        "print(\"  7. Multi-Factor Analysis\")\n",
        "print(\"  8. Valuation House\")\n",
        "print(\"=\"*80)\n",
        "\n",
        "import threading\n",
        "\n",
        "def run_streamlit():\n",
        "    os.system(\"streamlit run atlas_app.py --server.port 8501 --server.headless true\")\n",
        "\n",
        "streamlit_thread = threading.Thread(target=run_streamlit, daemon=True)\n",
        "streamlit_thread.start()\n",
        "\n",
        "time.sleep(8)\n",
        "\n",
        "public_url = ngrok.connect(8501)\n",
        "\n",
        "print(f\"\\n‚úÖ ATLAS TERMINAL v9.2 UNIFIED is LIVE!\")\n",
        "print(f\"üåê Access URL: {public_url}\")\n",
        "print(f\"\\nüéâ THE COMPLETE PLATFORM:\")\n",
        "print(f\"   üî• Core Phoenix Mode - ALL Features\")\n",
        "print(f\"   üíé Valuation House - Complete DCF Engine\")\n",
        "print(f\"   üìä 8 Modules - Fully Integrated\")\n",
        "print(f\"   üåü 150+ Features - All Preserved & Optimized\")\n",
        "print(\"=\"*80)\n",
        "print(\"üíé THE ULTIMATE INVESTMENT ANALYSIS PLATFORM!\")\n",
        "print(\"üî• Everything You Need, Consolidated & Optimized!\")\n",
        "print(\"=\"*80)\n",
        "\n",
        "try:\n",
        "    while True:\n",
        "        time.sleep(1)\n",
        "except KeyboardInterrupt:\n",
        "    print(\"\\n\\nüëã Shutting down...\")\n",
        "    ngrok.disconnect(public_url)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 400
        },
        "id": "HwqtHdGi6IRl",
        "outputId": "35d0c2be-26e3-4bd3-a0e1-c0531b246d99"
      },
      "outputs": [
        {
          "ename": "ModuleNotFoundError",
          "evalue": "No module named 'streamlit'",
          "output_type": "error",
          "traceback": [
            "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
            "\u001b[0;31mModuleNotFoundError\u001b[0m                       Traceback (most recent call last)",
            "\u001b[0;32m/tmp/ipython-input-2956869169.py\u001b[0m in \u001b[0;36m<cell line: 0>\u001b[0;34m()\u001b[0m\n\u001b[1;32m     31\u001b[0m \u001b[0;32mimport\u001b[0m \u001b[0mplotly\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mgraph_objects\u001b[0m \u001b[0;32mas\u001b[0m \u001b[0mgo\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     32\u001b[0m \u001b[0;32mfrom\u001b[0m \u001b[0mplotly\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0msubplots\u001b[0m \u001b[0;32mimport\u001b[0m \u001b[0mmake_subplots\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m---> 33\u001b[0;31m \u001b[0;32mimport\u001b[0m \u001b[0mstreamlit\u001b[0m \u001b[0;32mas\u001b[0m \u001b[0mst\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m     34\u001b[0m \u001b[0;32mimport\u001b[0m \u001b[0myfinance\u001b[0m \u001b[0;32mas\u001b[0m \u001b[0myf\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     35\u001b[0m \u001b[0;32mfrom\u001b[0m \u001b[0mscipy\u001b[0m \u001b[0;32mimport\u001b[0m \u001b[0mstats\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
            "\u001b[0;31mModuleNotFoundError\u001b[0m: No module named 'streamlit'",
            "",
            "\u001b[0;31m---------------------------------------------------------------------------\u001b[0;32m\nNOTE: If your import is failing due to a missing package, you can\nmanually install dependencies using either !pip or !apt.\n\nTo view examples of installing some common dependencies, click the\n\"Open Examples\" button below.\n\u001b[0;31m---------------------------------------------------------------------------\u001b[0m\n"
          ]
        }
      ],
      "source": [
        "#!/usr/bin/env python3\n",
        "\"\"\"\n",
        "ATLAS TERMINAL v9.3 EXCELLENCE EDITION - PART 1 OF 2\n",
        "Complete Portfolio Analytics + Valuation House - Excellence Optimized\n",
        "\n",
        "ENHANCED IN v9.3:\n",
        "‚úÖ Home Page: Top Contributors/Detractors + Enhanced Dashboard\n",
        "‚úÖ Market Watch: COMPLETE REVAMP (Crypto, Bonds, Spreads, Expanded Universe)\n",
        "‚úÖ Chart Theming: ALL charts blend seamlessly with dark background\n",
        "‚úÖ Portfolio Deep Dive: Enhanced visuals + Fixed Nov 2024 columns\n",
        "‚úÖ Valuation House: Analyst-grade fixes (scaling D&A/CapEx, Smart Assumptions, Editable Projections)\n",
        "‚úÖ ALL original features preserved and enhanced\n",
        "\n",
        "THIS IS PART 1 - Contains all imports, functions, calculations, and setup\n",
        "COPY PART 2 BELOW THIS FILE TO COMPLETE THE APP\n",
        "\"\"\"\n",
        "\n",
        "import pickle\n",
        "import warnings\n",
        "import re\n",
        "import time\n",
        "import io\n",
        "import json\n",
        "import random\n",
        "from datetime import datetime, timedelta, date\n",
        "from pathlib import Path\n",
        "from collections import Counter, defaultdict\n",
        "import numpy as np\n",
        "import pandas as pd\n",
        "import plotly.express as px\n",
        "import plotly.graph_objects as go\n",
        "from plotly.subplots import make_subplots\n",
        "import streamlit as st\n",
        "import yfinance as yf\n",
        "from scipy import stats\n",
        "from scipy.optimize import minimize\n",
        "import networkx as nx\n",
        "from sklearn.preprocessing import StandardScaler\n",
        "from sklearn.decomposition import PCA\n",
        "from sklearn.linear_model import LinearRegression\n",
        "\n",
        "warnings.filterwarnings(\"ignore\")\n",
        "\n",
        "# ============================================================================\n",
        "# HELPER FUNCTIONS FOR VALIDATION\n",
        "# ============================================================================\n",
        "def is_valid_series(series):\n",
        "    \"\"\"Safely check if a pandas Series has valid data\"\"\"\n",
        "    return series is not None and isinstance(series, pd.Series) and not series.empty\n",
        "\n",
        "def is_valid_dataframe(df):\n",
        "    \"\"\"Safely check if a pandas DataFrame has valid data\"\"\"\n",
        "    return df is not None and isinstance(df, pd.DataFrame) and not df.empty\n",
        "\n",
        "# ============================================================================\n",
        "# PAGE CONFIG\n",
        "# ============================================================================\n",
        "st.set_page_config(\n",
        "    page_title=\"ATLAS Terminal v9.3 EXCELLENCE\",\n",
        "    page_icon=\"üî•\",\n",
        "    layout=\"wide\",\n",
        "    initial_sidebar_state=\"expanded\"\n",
        ")\n",
        "\n",
        "# ============================================================================\n",
        "# PROFESSIONAL THEME SYSTEM - ENHANCED FOR SEAMLESS CHARTS\n",
        "# ============================================================================\n",
        "\n",
        "COLORS = {\n",
        "    \"background\": \"#000000\",\n",
        "    \"card_background\": \"#0a1929\",\n",
        "    \"card_background_alt\": \"#050f17\",\n",
        "    \"neon_blue\": \"#00d4ff\",\n",
        "    \"electric_blue\": \"#0080ff\",\n",
        "    \"teal\": \"#00ffcc\",\n",
        "    \"cyan\": \"#00ffff\",\n",
        "    \"success\": \"#00ff88\",\n",
        "    \"warning\": \"#ffaa00\",\n",
        "    \"danger\": \"#ff0044\",\n",
        "    \"info\": \"#00d4ff\",\n",
        "    \"purple\": \"#b794f6\",\n",
        "    \"pink\": \"#ff00ff\",\n",
        "    \"orange\": \"#ff6b00\",\n",
        "    \"chart_primary\": \"#00d4ff\",\n",
        "    \"chart_secondary\": \"#0080ff\",\n",
        "    \"chart_accent\": \"#00ffcc\",\n",
        "    \"chart_grid\": \"#1a3a52\",\n",
        "    \"text_primary\": \"#ffffff\",\n",
        "    \"text_secondary\": \"#b0c4de\",\n",
        "    \"text_muted\": \"#6c8ca8\",\n",
        "    \"border\": \"#00d4ff\",\n",
        "    \"shadow\": \"rgba(0, 212, 255, 0.3)\",\n",
        "    \"shadow_strong\": \"rgba(0, 212, 255, 0.6)\",\n",
        "    \"gain_bg\": \"rgba(0, 255, 136, 0.15)\",\n",
        "    \"gain_text\": \"#00ff88\",\n",
        "    \"loss_bg\": \"rgba(255, 0, 68, 0.15)\",\n",
        "    \"loss_text\": \"#ff0044\",\n",
        "}\n",
        "\n",
        "# ============================================================================\n",
        "# CHART THEME CONFIGURATION - SEAMLESS DARK MODE\n",
        "# ============================================================================\n",
        "CHART_THEME = {\n",
        "    'paper_bgcolor': 'rgba(0, 0, 0, 0)',  # Transparent background\n",
        "    'plot_bgcolor': 'rgba(10, 25, 41, 0.3)',  # Semi-transparent plot area\n",
        "    'font': {'color': COLORS['text_primary'], 'family': 'Inter, sans-serif'},\n",
        "    'xaxis': {\n",
        "        'gridcolor': COLORS['chart_grid'],\n",
        "        'linecolor': COLORS['chart_grid'],\n",
        "        'zerolinecolor': COLORS['chart_grid']\n",
        "    },\n",
        "    'yaxis': {\n",
        "        'gridcolor': COLORS['chart_grid'],\n",
        "        'linecolor': COLORS['chart_grid'],\n",
        "        'zerolinecolor': COLORS['chart_grid']\n",
        "    }\n",
        "}\n",
        "\n",
        "def apply_chart_theme(fig):\n",
        "    \"\"\"Apply seamless dark theme to any Plotly figure\"\"\"\n",
        "    fig.update_layout(\n",
        "        paper_bgcolor='rgba(0, 0, 0, 0)',\n",
        "        plot_bgcolor='rgba(10, 25, 41, 0.3)',\n",
        "        font=dict(color=COLORS['text_primary'], family='Inter, sans-serif'),\n",
        "        xaxis=dict(\n",
        "            gridcolor=COLORS['chart_grid'],\n",
        "            linecolor=COLORS['chart_grid'],\n",
        "            zerolinecolor=COLORS['chart_grid']\n",
        "        ),\n",
        "        yaxis=dict(\n",
        "            gridcolor=COLORS['chart_grid'],\n",
        "            linecolor=COLORS['chart_grid'],\n",
        "            zerolinecolor=COLORS['chart_grid']\n",
        "        )\n",
        "    )\n",
        "    return fig\n",
        "\n",
        "COLORSCALES = {\n",
        "    \"viridis\": px.colors.sequential.Viridis,\n",
        "    \"plasma\": px.colors.sequential.Plasma,\n",
        "    \"turbo\": px.colors.sequential.Turbo,\n",
        "    \"rdylgn\": px.colors.diverging.RdYlGn,\n",
        "    \"spectral\": px.colors.diverging.Spectral,\n",
        "}\n",
        "\n",
        "# ============================================================================\n",
        "# ENHANCED CSS\n",
        "# ============================================================================\n",
        "st.markdown(f\"\"\"\n",
        "<style>\n",
        "    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;600&display=swap');\n",
        "\n",
        "    * {{\n",
        "        font-family: 'Inter', 'Segoe UI', sans-serif !important;\n",
        "    }}\n",
        "\n",
        "    @keyframes pulseGreen {{\n",
        "        0% {{ background-color: {COLORS['gain_bg']}; transform: scale(1); }}\n",
        "        50% {{ background-color: rgba(0, 255, 136, 0.25); transform: scale(1.02); }}\n",
        "        100% {{ background-color: {COLORS['gain_bg']}; transform: scale(1); }}\n",
        "    }}\n",
        "\n",
        "    @keyframes pulseRed {{\n",
        "        0% {{ background-color: {COLORS['loss_bg']}; transform: scale(1); }}\n",
        "        50% {{ background-color: rgba(255, 0, 68, 0.25); transform: scale(1.02); }}\n",
        "        100% {{ background-color: {COLORS['loss_bg']}; transform: scale(1); }}\n",
        "    }}\n",
        "\n",
        "    .main {{\n",
        "        background: linear-gradient(135deg, #000000 0%, #0a1929 100%);\n",
        "        color: {COLORS['text_primary']};\n",
        "    }}\n",
        "\n",
        "    h1 {{\n",
        "        background: linear-gradient(90deg, #00d4ff, #00ff88, #00d4ff);\n",
        "        background-clip: text;\n",
        "        -webkit-background-clip: text;\n",
        "        -webkit-text-fill-color: transparent;\n",
        "        text-shadow: 0 0 40px rgba(0,212,255,0.8);\n",
        "        font-family: 'Inter', sans-serif !important;\n",
        "        font-weight: 700 !important;\n",
        "        font-size: 3.5em !important;\n",
        "        text-align: center;\n",
        "        animation: glow 2s ease-in-out infinite alternate;\n",
        "    }}\n",
        "\n",
        "    @keyframes glow {{\n",
        "        from {{ text-shadow: 0 0 20px rgba(0,212,255,0.5); }}\n",
        "        to {{ text-shadow: 0 0 30px rgba(0,212,255,1), 0 0 40px rgba(0,255,136,0.5); }}\n",
        "    }}\n",
        "\n",
        "    div[data-testid=\"stDataFrame\"] tbody tr:hover {{\n",
        "        background: linear-gradient(90deg, rgba(0, 212, 255, 0.2) 0%, rgba(0, 212, 255, 0.1) 100%) !important;\n",
        "        transform: scale(1.02) translateX(5px);\n",
        "        box-shadow: 0 5px 20px rgba(0, 212, 255, 0.3);\n",
        "        border-left: 3px solid {COLORS['neon_blue']};\n",
        "    }}\n",
        "\n",
        "    div[data-testid=\"stDataFrame\"] thead th {{\n",
        "        background: linear-gradient(135deg, {COLORS['neon_blue']} 0%, {COLORS['electric_blue']} 100%) !important;\n",
        "        color: {COLORS['background']} !important;\n",
        "        font-weight: 700 !important;\n",
        "        font-size: 14px !important;\n",
        "        text-transform: uppercase !important;\n",
        "    }}\n",
        "\n",
        "    div[data-testid=\"stMetric\"] {{\n",
        "        background: linear-gradient(135deg, {COLORS['card_background']} 0%, {COLORS['card_background_alt']} 100%);\n",
        "        border: 2px solid {COLORS['neon_blue']};\n",
        "        border-radius: 12px;\n",
        "        padding: 20px;\n",
        "        box-shadow: 0 0 30px {COLORS['shadow']};\n",
        "        transition: all 0.3s ease;\n",
        "    }}\n",
        "\n",
        "    div[data-testid=\"stMetric\"]:hover {{\n",
        "        transform: translateY(-5px) scale(1.02);\n",
        "        box-shadow: 0 10px 40px {COLORS['shadow_strong']};\n",
        "    }}\n",
        "\n",
        "    .stSlider {{\n",
        "        padding: 10px 0px;\n",
        "    }}\n",
        "</style>\n",
        "\"\"\", unsafe_allow_html=True)\n",
        "\n",
        "# ============================================================================\n",
        "# CONSTANTS & CONFIG\n",
        "# ============================================================================\n",
        "CACHE_DIR = Path.home() / \".atlas_cache\"\n",
        "CACHE_DIR.mkdir(exist_ok=True)\n",
        "PORTFOLIO_CACHE = CACHE_DIR / \"portfolio.pkl\"\n",
        "TRADE_HISTORY_CACHE = CACHE_DIR / \"trade_history.pkl\"\n",
        "ACCOUNT_HISTORY_CACHE = CACHE_DIR / \"account_history.pkl\"\n",
        "\n",
        "RISK_FREE_RATE = 0.045\n",
        "MARKET_RETURN = 0.10\n",
        "\n",
        "# ============================================================================\n",
        "# EXPANDED MARKET WATCH UNIVERSE - EXCELLENCE EDITION\n",
        "# ============================================================================\n",
        "\n",
        "# Global Market Indices\n",
        "GLOBAL_INDICES = {\n",
        "    \"^GSPC\": {\"name\": \"S&P 500\", \"region\": \"US\"},\n",
        "    \"^NDX\": {\"name\": \"Nasdaq 100\", \"region\": \"US\"},\n",
        "    \"^DJI\": {\"name\": \"Dow Jones\", \"region\": \"US\"},\n",
        "    \"^RUT\": {\"name\": \"Russell 2000\", \"region\": \"US\"},\n",
        "    \"^FTSE\": {\"name\": \"FTSE 100\", \"region\": \"UK\"},\n",
        "    \"^GDAXI\": {\"name\": \"DAX\", \"region\": \"Germany\"},\n",
        "    \"^FCHI\": {\"name\": \"CAC 40\", \"region\": \"France\"},\n",
        "    \"^STOXX50E\": {\"name\": \"Euro Stoxx 50\", \"region\": \"Europe\"},\n",
        "    \"^N225\": {\"name\": \"Nikkei 225\", \"region\": \"Japan\"},\n",
        "    \"^HSI\": {\"name\": \"Hang Seng\", \"region\": \"Hong Kong\"},\n",
        "    \"000001.SS\": {\"name\": \"Shanghai Composite\", \"region\": \"China\"},\n",
        "    \"^BSESN\": {\"name\": \"BSE Sensex\", \"region\": \"India\"},\n",
        "    \"^BVSP\": {\"name\": \"Bovespa\", \"region\": \"Brazil\"},\n",
        "    \"^AXJO\": {\"name\": \"ASX 200\", \"region\": \"Australia\"},\n",
        "    \"^GSPTSE\": {\"name\": \"TSX Composite\", \"region\": \"Canada\"}\n",
        "}\n",
        "\n",
        "# EXPANDED: Major Cryptocurrencies\n",
        "CRYPTOCURRENCIES = {\n",
        "    \"BTC-USD\": {\"name\": \"Bitcoin\", \"category\": \"Crypto\"},\n",
        "    \"ETH-USD\": {\"name\": \"Ethereum\", \"category\": \"Crypto\"},\n",
        "    \"BNB-USD\": {\"name\": \"Binance Coin\", \"category\": \"Crypto\"},\n",
        "    \"XRP-USD\": {\"name\": \"Ripple\", \"category\": \"Crypto\"},\n",
        "    \"ADA-USD\": {\"name\": \"Cardano\", \"category\": \"Crypto\"},\n",
        "    \"SOL-USD\": {\"name\": \"Solana\", \"category\": \"Crypto\"},\n",
        "    \"DOGE-USD\": {\"name\": \"Dogecoin\", \"category\": \"Crypto\"},\n",
        "    \"MATIC-USD\": {\"name\": \"Polygon\", \"category\": \"Crypto\"},\n",
        "    \"DOT-USD\": {\"name\": \"Polkadot\", \"category\": \"Crypto\"},\n",
        "    \"AVAX-USD\": {\"name\": \"Avalanche\", \"category\": \"Crypto\"}\n",
        "}\n",
        "\n",
        "# EXPANDED: Bond Yields and Rates\n",
        "BOND_YIELDS = {\n",
        "    \"^TNX\": {\"name\": \"US 10Y Treasury\", \"category\": \"Government Bonds\"},\n",
        "    \"^TYX\": {\"name\": \"US 30Y Treasury\", \"category\": \"Government Bonds\"},\n",
        "    \"^FVX\": {\"name\": \"US 5Y Treasury\", \"category\": \"Government Bonds\"},\n",
        "    \"^IRX\": {\"name\": \"US 13W Treasury\", \"category\": \"Government Bonds\"},\n",
        "}\n",
        "\n",
        "# NEW: Credit Spreads (using ETF proxies)\n",
        "CREDIT_SPREADS = {\n",
        "    \"LQD\": {\"name\": \"Investment Grade Credit\", \"category\": \"Credit\"},\n",
        "    \"HYG\": {\"name\": \"High Yield Credit\", \"category\": \"Credit\"},\n",
        "    \"EMB\": {\"name\": \"Emerging Market Bonds\", \"category\": \"Credit\"},\n",
        "    \"TIP\": {\"name\": \"TIPS (Inflation-Protected)\", \"category\": \"Government Bonds\"},\n",
        "    \"MBB\": {\"name\": \"Mortgage-Backed Securities\", \"category\": \"Credit\"},\n",
        "}\n",
        "\n",
        "# EXPANDED: Commodities\n",
        "COMMODITIES = {\n",
        "    \"GC=F\": {\"name\": \"Gold\", \"category\": \"Precious Metals\"},\n",
        "    \"SI=F\": {\"name\": \"Silver\", \"category\": \"Precious Metals\"},\n",
        "    \"PL=F\": {\"name\": \"Platinum\", \"category\": \"Precious Metals\"},\n",
        "    \"PA=F\": {\"name\": \"Palladium\", \"category\": \"Precious Metals\"},\n",
        "    \"CL=F\": {\"name\": \"Crude Oil WTI\", \"category\": \"Energy\"},\n",
        "    \"BZ=F\": {\"name\": \"Brent Crude\", \"category\": \"Energy\"},\n",
        "    \"NG=F\": {\"name\": \"Natural Gas\", \"category\": \"Energy\"},\n",
        "    \"RB=F\": {\"name\": \"Gasoline\", \"category\": \"Energy\"},\n",
        "    \"HG=F\": {\"name\": \"Copper\", \"category\": \"Industrial Metals\"},\n",
        "    \"ALI=F\": {\"name\": \"Aluminum\", \"category\": \"Industrial Metals\"},\n",
        "    \"ZC=F\": {\"name\": \"Corn\", \"category\": \"Agriculture\"},\n",
        "    \"ZW=F\": {\"name\": \"Wheat\", \"category\": \"Agriculture\"},\n",
        "    \"ZS=F\": {\"name\": \"Soybeans\", \"category\": \"Agriculture\"},\n",
        "    \"KC=F\": {\"name\": \"Coffee\", \"category\": \"Agriculture\"},\n",
        "    \"SB=F\": {\"name\": \"Sugar\", \"category\": \"Agriculture\"},\n",
        "    \"CC=F\": {\"name\": \"Cocoa\", \"category\": \"Agriculture\"},\n",
        "    \"LE=F\": {\"name\": \"Live Cattle\", \"category\": \"Livestock\"},\n",
        "    \"GF=F\": {\"name\": \"Feeder Cattle\", \"category\": \"Livestock\"}\n",
        "}\n",
        "\n",
        "# EXPANDED: Popular Stocks (diverse selection)\n",
        "POPULAR_STOCKS = {\n",
        "    # Mega Cap Tech\n",
        "    \"AAPL\": {\"name\": \"Apple\", \"sector\": \"Technology\", \"category\": \"Mega Cap Tech\"},\n",
        "    \"MSFT\": {\"name\": \"Microsoft\", \"sector\": \"Technology\", \"category\": \"Mega Cap Tech\"},\n",
        "    \"GOOGL\": {\"name\": \"Alphabet\", \"sector\": \"Technology\", \"category\": \"Mega Cap Tech\"},\n",
        "    \"AMZN\": {\"name\": \"Amazon\", \"sector\": \"Consumer Cyclical\", \"category\": \"Mega Cap Tech\"},\n",
        "    \"NVDA\": {\"name\": \"NVIDIA\", \"sector\": \"Technology\", \"category\": \"Mega Cap Tech\"},\n",
        "    \"META\": {\"name\": \"Meta\", \"sector\": \"Technology\", \"category\": \"Mega Cap Tech\"},\n",
        "    \"TSLA\": {\"name\": \"Tesla\", \"sector\": \"Consumer Cyclical\", \"category\": \"Mega Cap Tech\"},\n",
        "\n",
        "    # Financials\n",
        "    \"JPM\": {\"name\": \"JPMorgan\", \"sector\": \"Financial Services\", \"category\": \"Financials\"},\n",
        "    \"BAC\": {\"name\": \"Bank of America\", \"sector\": \"Financial Services\", \"category\": \"Financials\"},\n",
        "    \"GS\": {\"name\": \"Goldman Sachs\", \"sector\": \"Financial Services\", \"category\": \"Financials\"},\n",
        "    \"MS\": {\"name\": \"Morgan Stanley\", \"sector\": \"Financial Services\", \"category\": \"Financials\"},\n",
        "\n",
        "    # Healthcare\n",
        "    \"JNJ\": {\"name\": \"Johnson & Johnson\", \"sector\": \"Healthcare\", \"category\": \"Healthcare\"},\n",
        "    \"UNH\": {\"name\": \"UnitedHealth\", \"sector\": \"Healthcare\", \"category\": \"Healthcare\"},\n",
        "    \"PFE\": {\"name\": \"Pfizer\", \"sector\": \"Healthcare\", \"category\": \"Healthcare\"},\n",
        "\n",
        "    # Consumer\n",
        "    \"WMT\": {\"name\": \"Walmart\", \"sector\": \"Consumer Defensive\", \"category\": \"Consumer\"},\n",
        "    \"PG\": {\"name\": \"Procter & Gamble\", \"sector\": \"Consumer Defensive\", \"category\": \"Consumer\"},\n",
        "    \"KO\": {\"name\": \"Coca-Cola\", \"sector\": \"Consumer Defensive\", \"category\": \"Consumer\"},\n",
        "\n",
        "    # Energy\n",
        "    \"XOM\": {\"name\": \"Exxon Mobil\", \"sector\": \"Energy\", \"category\": \"Energy\"},\n",
        "    \"CVX\": {\"name\": \"Chevron\", \"sector\": \"Energy\", \"category\": \"Energy\"},\n",
        "}\n",
        "\n",
        "# EXPANDED: Popular ETFs (now includes thematic and sector)\n",
        "POPULAR_ETFS = {\n",
        "    # Broad Market\n",
        "    \"SPY\": {\"name\": \"SPDR S&P 500\", \"category\": \"Broad Market\", \"avg_volume\": 70000000},\n",
        "    \"QQQ\": {\"name\": \"Invesco QQQ\", \"category\": \"Broad Market\", \"avg_volume\": 40000000},\n",
        "    \"IWM\": {\"name\": \"Russell 2000\", \"category\": \"Broad Market\", \"avg_volume\": 30000000},\n",
        "    \"VTI\": {\"name\": \"Total Stock Market\", \"category\": \"Broad Market\", \"avg_volume\": 5000000},\n",
        "\n",
        "    # Sector SPDRs\n",
        "    \"XLK\": {\"name\": \"Technology Select\", \"category\": \"Sector\", \"avg_volume\": 15000000},\n",
        "    \"XLF\": {\"name\": \"Financial Select\", \"category\": \"Sector\", \"avg_volume\": 50000000},\n",
        "    \"XLV\": {\"name\": \"Health Care Select\", \"category\": \"Sector\", \"avg_volume\": 10000000},\n",
        "    \"XLE\": {\"name\": \"Energy Select\", \"category\": \"Sector\", \"avg_volume\": 20000000},\n",
        "    \"XLI\": {\"name\": \"Industrial Select\", \"category\": \"Sector\", \"avg_volume\": 12000000},\n",
        "    \"XLY\": {\"name\": \"Consumer Discretionary\", \"category\": \"Sector\", \"avg_volume\": 8000000},\n",
        "    \"XLP\": {\"name\": \"Consumer Staples\", \"category\": \"Sector\", \"avg_volume\": 10000000},\n",
        "    \"XLU\": {\"name\": \"Utilities Select\", \"category\": \"Sector\", \"avg_volume\": 12000000},\n",
        "    \"XLRE\": {\"name\": \"Real Estate Select\", \"category\": \"Sector\", \"avg_volume\": 5000000},\n",
        "\n",
        "    # Thematic\n",
        "    \"ARKK\": {\"name\": \"ARK Innovation\", \"category\": \"Thematic\", \"avg_volume\": 8000000},\n",
        "    \"ARKQ\": {\"name\": \"ARK Autonomous Tech\", \"category\": \"Thematic\", \"avg_volume\": 2000000},\n",
        "    \"ARKW\": {\"name\": \"ARK Next Gen Internet\", \"category\": \"Thematic\", \"avg_volume\": 1500000},\n",
        "    \"ICLN\": {\"name\": \"Clean Energy\", \"category\": \"Thematic\", \"avg_volume\": 5000000},\n",
        "    \"TAN\": {\"name\": \"Solar Energy\", \"category\": \"Thematic\", \"avg_volume\": 1500000},\n",
        "    \"HACK\": {\"name\": \"Cybersecurity\", \"category\": \"Thematic\", \"avg_volume\": 800000},\n",
        "    \"ROBO\": {\"name\": \"Robotics & AI\", \"category\": \"Thematic\", \"avg_volume\": 500000},\n",
        "    \"FINX\": {\"name\": \"FinTech\", \"category\": \"Thematic\", \"avg_volume\": 300000},\n",
        "\n",
        "    # International\n",
        "    \"EEM\": {\"name\": \"Emerging Markets\", \"category\": \"International\", \"avg_volume\": 25000000},\n",
        "    \"EFA\": {\"name\": \"EAFE\", \"category\": \"International\", \"avg_volume\": 15000000},\n",
        "    \"VWO\": {\"name\": \"FTSE Emerging Markets\", \"category\": \"International\", \"avg_volume\": 10000000},\n",
        "    \"FXI\": {\"name\": \"China Large-Cap\", \"category\": \"International\", \"avg_volume\": 20000000},\n",
        "}\n",
        "\n",
        "# Factor definitions\n",
        "FACTOR_DEFINITIONS = {\n",
        "    \"Market\": {\"description\": \"Market risk premium\", \"benchmark\": \"SPY\"},\n",
        "    \"Size\": {\"description\": \"Small cap minus large cap\", \"benchmark\": \"IWM\"},\n",
        "    \"Value\": {\"description\": \"Value minus growth\", \"benchmark\": \"IWD\"},\n",
        "    \"Momentum\": {\"description\": \"Winners minus losers\", \"benchmark\": \"MTUM\"},\n",
        "    \"Quality\": {\"description\": \"High quality minus low quality\", \"benchmark\": \"QUAL\"},\n",
        "    \"Volatility\": {\"description\": \"Low vol minus high vol\", \"benchmark\": \"USMV\"}\n",
        "}\n",
        "\n",
        "# ETF sectors\n",
        "ETF_SECTORS = {\n",
        "    \"QQQ\": \"Technology\", \"XLK\": \"Technology\", \"VGT\": \"Technology\",\n",
        "    \"XLF\": \"Financial Services\", \"KRE\": \"Financial Services\",\n",
        "    \"XLV\": \"Healthcare\", \"IBB\": \"Healthcare\", \"XBI\": \"Healthcare\",\n",
        "    \"XLE\": \"Energy\", \"XOP\": \"Energy\", \"USO\": \"Energy\",\n",
        "    \"XLB\": \"Basic Materials\", \"GDX\": \"Basic Materials\",\n",
        "    \"XLY\": \"Consumer Cyclical\", \"XLP\": \"Consumer Defensive\",\n",
        "    \"XLI\": \"Industrials\", \"IYT\": \"Industrials\",\n",
        "    \"VNQ\": \"Real Estate\", \"XLRE\": \"Real Estate\",\n",
        "    \"XLU\": \"Utilities\",\n",
        "    \"SPY\": \"Broad Market\", \"VOO\": \"Broad Market\", \"VTI\": \"Broad Market\"\n",
        "}\n",
        "\n",
        "# ============================================================================\n",
        "# HELPER FUNCTIONS\n",
        "# ============================================================================\n",
        "\n",
        "def format_percentage(value, decimals=2):\n",
        "    if pd.isna(value) or value is None:\n",
        "        return \"N/A\"\n",
        "    return f\"{value:.{decimals}f}%\"\n",
        "\n",
        "def format_currency(value):\n",
        "    if pd.isna(value) or value is None:\n",
        "        return \"N/A\"\n",
        "    return f\"${value:,.2f}\"\n",
        "\n",
        "def format_large_number(value):\n",
        "    \"\"\"Format large numbers with B/M/K suffix\"\"\"\n",
        "    if pd.isna(value) or value is None:\n",
        "        return \"N/A\"\n",
        "    if abs(value) >= 1e9:\n",
        "        return f\"${value/1e9:.2f}B\"\n",
        "    elif abs(value) >= 1e6:\n",
        "        return f\"${value/1e6:.2f}M\"\n",
        "    elif abs(value) >= 1e3:\n",
        "        return f\"${value/1e3:.2f}K\"\n",
        "    return f\"${value:.2f}\"\n",
        "\n",
        "def add_arrow_indicator(value):\n",
        "    try:\n",
        "        val = float(str(value).replace('%', '').replace('$', '').replace(',', ''))\n",
        "        if val > 0:\n",
        "            return f\"‚ñ≤ {value}\"\n",
        "        elif val < 0:\n",
        "            return f\"‚ñº {value}\"\n",
        "        return f\"‚îÄ {value}\"\n",
        "    except:\n",
        "        return value\n",
        "\n",
        "# ============================================================================\n",
        "# DATA FUNCTIONS\n",
        "# ============================================================================\n",
        "\n",
        "def save_portfolio_data(data):\n",
        "    with open(PORTFOLIO_CACHE, \"wb\") as f:\n",
        "        pickle.dump(data, f)\n",
        "\n",
        "def load_portfolio_data():\n",
        "    if PORTFOLIO_CACHE.exists():\n",
        "        with open(PORTFOLIO_CACHE, \"rb\") as f:\n",
        "            return pickle.load(f)\n",
        "    return []\n",
        "\n",
        "def save_trade_history(df):\n",
        "    with open(TRADE_HISTORY_CACHE, \"wb\") as f:\n",
        "        pickle.dump(df, f)\n",
        "\n",
        "def load_trade_history():\n",
        "    if TRADE_HISTORY_CACHE.exists():\n",
        "        with open(TRADE_HISTORY_CACHE, \"rb\") as f:\n",
        "            return pickle.load(f)\n",
        "    return None\n",
        "\n",
        "def save_account_history(df):\n",
        "    with open(ACCOUNT_HISTORY_CACHE, \"wb\") as f:\n",
        "        pickle.dump(df, f)\n",
        "\n",
        "def load_account_history():\n",
        "    if ACCOUNT_HISTORY_CACHE.exists():\n",
        "        with open(ACCOUNT_HISTORY_CACHE, \"rb\") as f:\n",
        "            return pickle.load(f)\n",
        "    return None\n",
        "\n",
        "def get_leverage_info():\n",
        "    account_df = load_account_history()\n",
        "    if account_df is not None:\n",
        "        latest_cash = account_df.get('Cash Balance', account_df.get('Cash', pd.Series([0]))).iloc[-1]\n",
        "\n",
        "        if isinstance(latest_cash, str):\n",
        "            latest_cash = latest_cash.replace('$', '').replace(',', '')\n",
        "            if '(' in latest_cash and ')' in latest_cash:\n",
        "                latest_cash = '-' + latest_cash.replace('(', '').replace(')', '')\n",
        "            try:\n",
        "                latest_cash = float(latest_cash)\n",
        "            except:\n",
        "                latest_cash = 0\n",
        "\n",
        "        latest_margin = 0\n",
        "\n",
        "        if 'Margin Used' in account_df.columns:\n",
        "            latest_margin = account_df['Margin Used'].iloc[-1]\n",
        "            if isinstance(latest_margin, str):\n",
        "                latest_margin = latest_margin.replace('$', '').replace(',', '')\n",
        "                if '(' in latest_margin and ')' in latest_margin:\n",
        "                    latest_margin = '-' + latest_margin.replace('(', '').replace(')', '')\n",
        "                try:\n",
        "                    latest_margin = float(latest_margin)\n",
        "                except:\n",
        "                    latest_margin = 0\n",
        "\n",
        "        if latest_cash < 0:\n",
        "            latest_margin = abs(latest_cash)\n",
        "\n",
        "        total_value = 0\n",
        "        if 'Total Value' in account_df.columns:\n",
        "            total_value = account_df['Total Value'].iloc[-1]\n",
        "            if isinstance(total_value, str):\n",
        "                total_value = total_value.replace('$', '').replace(',', '')\n",
        "                if '(' in total_value and ')' in total_value:\n",
        "                    total_value = '-' + total_value.replace('(', '').replace(')', '')\n",
        "                try:\n",
        "                    total_value = float(total_value)\n",
        "                except:\n",
        "                    total_value = abs(latest_cash) + latest_margin\n",
        "        else:\n",
        "            total_value = abs(latest_cash) + latest_margin\n",
        "\n",
        "        leverage_ratio = (total_value / (total_value - latest_margin)) if (total_value - latest_margin) > 0 else 1\n",
        "\n",
        "        return {\n",
        "            'margin_used': latest_margin,\n",
        "            'cash_balance': latest_cash,\n",
        "            'leverage_ratio': leverage_ratio,\n",
        "            'total_value': total_value\n",
        "        }\n",
        "    return None\n",
        "\n",
        "@st.cache_data(ttl=300)\n",
        "def fetch_market_data(ticker):\n",
        "    try:\n",
        "        stock = yf.Ticker(ticker)\n",
        "        info = stock.info\n",
        "        hist = stock.history(period=\"5d\")\n",
        "        if hist.empty:\n",
        "            return None\n",
        "\n",
        "        current_price = hist['Close'].iloc[-1]\n",
        "        prev_close = hist['Close'].iloc[-2] if len(hist) > 1 else current_price\n",
        "        daily_change = current_price - prev_close\n",
        "        daily_change_pct = (daily_change / prev_close * 100) if prev_close else 0\n",
        "\n",
        "        five_day_return = ((current_price / hist['Close'].iloc[0]) - 1) * 100 if len(hist) >= 5 else 0\n",
        "\n",
        "        company_name = info.get('longName', info.get('shortName', ticker))\n",
        "\n",
        "        return {\n",
        "            \"price\": current_price,\n",
        "            \"daily_change\": daily_change,\n",
        "            \"daily_change_pct\": daily_change_pct,\n",
        "            \"five_day_return\": five_day_return,\n",
        "            \"volume\": info.get('volume', 0),\n",
        "            \"avg_volume\": info.get('averageVolume', 0),\n",
        "            \"sector\": info.get('sector', 'Unknown'),\n",
        "            \"beta\": info.get('beta', None),\n",
        "            \"market_cap\": info.get('marketCap', 0),\n",
        "            \"company_name\": company_name,\n",
        "            \"52_week_high\": info.get('fiftyTwoWeekHigh', None),\n",
        "            \"52_week_low\": info.get('fiftyTwoWeekLow', None)\n",
        "        }\n",
        "    except:\n",
        "        return None\n",
        "\n",
        "def is_option_ticker(ticker):\n",
        "    if len(ticker) <= 6:\n",
        "        return False\n",
        "    has_year = any(str(y) in ticker for y in range(2020, 2030))\n",
        "    has_strike = any(c.isdigit() for c in ticker[6:])\n",
        "    has_type = ticker[-1] in ['C', 'P'] or 'C' in ticker[6:] or 'P' in ticker[6:]\n",
        "    return has_year and has_strike and has_type\n",
        "\n",
        "def classify_ticker_sector(ticker, default_sector):\n",
        "    if pd.notna(default_sector) and default_sector != \"Unknown\":\n",
        "        return default_sector\n",
        "\n",
        "    if ticker in ETF_SECTORS:\n",
        "        return ETF_SECTORS[ticker]\n",
        "\n",
        "    return \"Other\"\n",
        "\n",
        "@st.cache_data(ttl=600)\n",
        "def fetch_historical_data(ticker, start_date, end_date):\n",
        "    try:\n",
        "        stock = yf.Ticker(ticker)\n",
        "        hist = stock.history(start=start_date, end=end_date)\n",
        "        if not hist.empty:\n",
        "            return hist\n",
        "    except:\n",
        "        pass\n",
        "    return None\n",
        "\n",
        "@st.cache_data(ttl=3600)\n",
        "def fetch_analyst_data(ticker):\n",
        "    try:\n",
        "        stock = yf.Ticker(ticker)\n",
        "        info = stock.info\n",
        "\n",
        "        rating = info.get('recommendationKey', 'none')\n",
        "        if rating == 'none' or rating is None:\n",
        "            rating = \"No Coverage\"\n",
        "\n",
        "        return {\n",
        "            'rating': rating.upper() if rating != \"No Coverage\" else rating,\n",
        "            'target_price': info.get('targetMeanPrice'),\n",
        "            'num_analysts': info.get('numberOfAnalystOpinions', 0),\n",
        "            'success': True\n",
        "        }\n",
        "    except:\n",
        "        return {'success': False, 'rating': 'No Coverage', 'target_price': None}\n",
        "\n",
        "# ============================================================================\n",
        "# VALUATION HOUSE - ENHANCED WITH SMART ASSUMPTIONS\n",
        "# ============================================================================\n",
        "\n",
        "@st.cache_data(ttl=3600)\n",
        "def fetch_company_financials(ticker):\n",
        "    \"\"\"Fetch comprehensive financial data for valuation\"\"\"\n",
        "    try:\n",
        "        stock = yf.Ticker(ticker)\n",
        "        info = stock.info\n",
        "\n",
        "        # Basic company info\n",
        "        company_data = {\n",
        "            'ticker': ticker,\n",
        "            'name': info.get('longName', ticker),\n",
        "            'sector': info.get('sector', 'Unknown'),\n",
        "            'industry': info.get('industry', 'Unknown'),\n",
        "            'current_price': info.get('currentPrice', 0),\n",
        "            'market_cap': info.get('marketCap', 0),\n",
        "            'shares_outstanding': info.get('sharesOutstanding', 0),\n",
        "            'beta': info.get('beta', 1.0),\n",
        "            'forward_pe': info.get('forwardPE'),\n",
        "            'trailing_pe': info.get('trailingPE'),\n",
        "        }\n",
        "\n",
        "        # Financial statements\n",
        "        income_stmt = stock.income_stmt\n",
        "        balance_sheet = stock.balance_sheet\n",
        "        cash_flow = stock.cash_flow\n",
        "\n",
        "        # Parse financials (most recent 3 years)\n",
        "        financials = {}\n",
        "\n",
        "        if not income_stmt.empty:\n",
        "            # Get most recent year\n",
        "            latest_col = income_stmt.columns[0]\n",
        "\n",
        "            financials['revenue'] = income_stmt.loc['Total Revenue', latest_col] if 'Total Revenue' in income_stmt.index else 0\n",
        "            financials['ebit'] = income_stmt.loc['EBIT', latest_col] if 'EBIT' in income_stmt.index else 0\n",
        "            financials['net_income'] = income_stmt.loc['Net Income', latest_col] if 'Net Income' in income_stmt.index else 0\n",
        "            financials['tax_expense'] = income_stmt.loc['Tax Provision', latest_col] if 'Tax Provision' in income_stmt.index else 0\n",
        "\n",
        "            # Calculate tax rate\n",
        "            if financials['ebit'] != 0:\n",
        "                financials['tax_rate'] = abs(financials['tax_expense'] / financials['ebit'])\n",
        "            else:\n",
        "                financials['tax_rate'] = 0.21  # Default US corporate tax rate\n",
        "\n",
        "        if not balance_sheet.empty:\n",
        "            latest_col = balance_sheet.columns[0]\n",
        "\n",
        "            financials['total_debt'] = balance_sheet.loc['Total Debt', latest_col] if 'Total Debt' in balance_sheet.index else 0\n",
        "            financials['cash'] = balance_sheet.loc['Cash And Cash Equivalents', latest_col] if 'Cash And Cash Equivalents' in balance_sheet.index else 0\n",
        "            financials['total_equity'] = balance_sheet.loc['Total Equity Gross Minority Interest', latest_col] if 'Total Equity Gross Minority Interest' in balance_sheet.index else 0\n",
        "\n",
        "        if not cash_flow.empty:\n",
        "            latest_col = cash_flow.columns[0]\n",
        "\n",
        "            financials['capex'] = abs(cash_flow.loc['Capital Expenditure', latest_col]) if 'Capital Expenditure' in cash_flow.index else 0\n",
        "            financials['depreciation'] = cash_flow.loc['Depreciation And Amortization', latest_col] if 'Depreciation And Amortization' in cash_flow.index else 0\n",
        "            financials['operating_cf'] = cash_flow.loc['Operating Cash Flow', latest_col] if 'Operating Cash Flow' in cash_flow.index else 0\n",
        "\n",
        "        # Calculate working capital change (simplified)\n",
        "        financials['change_wc'] = 0  # User can adjust\n",
        "\n",
        "        return {\n",
        "            'company': company_data,\n",
        "            'financials': financials,\n",
        "            'success': True\n",
        "        }\n",
        "\n",
        "    except Exception as e:\n",
        "        return {\n",
        "            'success': False,\n",
        "            'error': str(e)\n",
        "        }\n",
        "\n",
        "def calculate_smart_assumptions(company_data, financials):\n",
        "    \"\"\"\n",
        "    NEW: Calculate realistic, economically grounded assumptions\n",
        "    based on company fundamentals, sector averages, and economic reality\n",
        "    \"\"\"\n",
        "    sector = company_data.get('sector', 'Unknown')\n",
        "    revenue = financials.get('revenue', 0)\n",
        "    ebit = financials.get('ebit', 0)\n",
        "\n",
        "    # Smart revenue growth (based on sector and size)\n",
        "    sector_growth_rates = {\n",
        "        'Technology': 0.08,\n",
        "        'Healthcare': 0.06,\n",
        "        'Financial Services': 0.05,\n",
        "        'Consumer Cyclical': 0.04,\n",
        "        'Consumer Defensive': 0.03,\n",
        "        'Energy': 0.03,\n",
        "        'Industrials': 0.04,\n",
        "        'Basic Materials': 0.03,\n",
        "        'Real Estate': 0.03,\n",
        "        'Utilities': 0.02,\n",
        "        'Communication Services': 0.05,\n",
        "        'Unknown': 0.04\n",
        "    }\n",
        "\n",
        "    base_growth = sector_growth_rates.get(sector, 0.04)\n",
        "\n",
        "    # Adjust for company size (larger = slower growth)\n",
        "    market_cap = company_data.get('market_cap', 0)\n",
        "    if market_cap > 500e9:  # Mega cap\n",
        "        size_adjustment = -0.02\n",
        "    elif market_cap > 100e9:  # Large cap\n",
        "        size_adjustment = -0.01\n",
        "    elif market_cap > 10e9:  # Mid cap\n",
        "        size_adjustment = 0\n",
        "    else:  # Small cap\n",
        "        size_adjustment = 0.01\n",
        "\n",
        "    smart_revenue_growth = base_growth + size_adjustment\n",
        "\n",
        "    # Smart EBIT margin (sector averages)\n",
        "    sector_ebit_margins = {\n",
        "        'Technology': 0.25,\n",
        "        'Healthcare': 0.20,\n",
        "        'Financial Services': 0.30,\n",
        "        'Consumer Cyclical': 0.10,\n",
        "        'Consumer Defensive': 0.08,\n",
        "        'Energy': 0.15,\n",
        "        'Industrials': 0.12,\n",
        "        'Basic Materials': 0.15,\n",
        "        'Real Estate': 0.40,\n",
        "        'Utilities': 0.20,\n",
        "        'Communication Services': 0.18,\n",
        "        'Unknown': 0.15\n",
        "    }\n",
        "\n",
        "    smart_ebit_margin = sector_ebit_margins.get(sector, 0.15)\n",
        "\n",
        "    # Smart CapEx (as % of revenue, sector-based)\n",
        "    sector_capex_rates = {\n",
        "        'Technology': 0.03,\n",
        "        'Healthcare': 0.04,\n",
        "        'Financial Services': 0.02,\n",
        "        'Consumer Cyclical': 0.05,\n",
        "        'Consumer Defensive': 0.04,\n",
        "        'Energy': 0.12,\n",
        "        'Industrials': 0.06,\n",
        "        'Basic Materials': 0.10,\n",
        "        'Real Estate': 0.08,\n",
        "        'Utilities': 0.15,\n",
        "        'Communication Services': 0.07,\n",
        "        'Unknown': 0.05\n",
        "    }\n",
        "\n",
        "    smart_capex_pct = sector_capex_rates.get(sector, 0.05)\n",
        "\n",
        "    # Smart Depreciation (typically 60-80% of CapEx for mature companies)\n",
        "    smart_depreciation_pct = smart_capex_pct * 0.7\n",
        "\n",
        "    # Smart Terminal Growth (conservative)\n",
        "    smart_terminal_growth = 0.025  # Long-term GDP growth\n",
        "\n",
        "    # Smart Tax Rate (based on geography and sector)\n",
        "    smart_tax_rate = 0.21  # US corporate rate\n",
        "\n",
        "    return {\n",
        "        'revenue_growth': smart_revenue_growth,\n",
        "        'ebit_margin': smart_ebit_margin,\n",
        "        'capex_pct': smart_capex_pct,\n",
        "        'depreciation_pct': smart_depreciation_pct,\n",
        "        'terminal_growth': smart_terminal_growth,\n",
        "        'tax_rate': smart_tax_rate,\n",
        "        'wc_change': 0,  # Assume neutral\n",
        "        'forecast_years': 5\n",
        "    }\n",
        "\n",
        "def calculate_wacc(cost_equity, cost_debt, tax_rate, debt, equity):\n",
        "    \"\"\"Calculate Weighted Average Cost of Capital\"\"\"\n",
        "    total_value = debt + equity\n",
        "    if total_value == 0:\n",
        "        return cost_equity\n",
        "\n",
        "    weight_equity = equity / total_value\n",
        "    weight_debt = debt / total_value\n",
        "\n",
        "    wacc = (cost_equity * weight_equity) + (cost_debt * (1 - tax_rate) * weight_debt)\n",
        "    return wacc\n",
        "\n",
        "def calculate_cost_of_equity(risk_free_rate, beta, market_risk_premium):\n",
        "    \"\"\"Calculate Cost of Equity using CAPM\"\"\"\n",
        "    return risk_free_rate + (beta * market_risk_premium)\n",
        "\n",
        "def calculate_terminal_value(final_fcf, discount_rate, terminal_growth):\n",
        "    \"\"\"Calculate Terminal Value using Gordon Growth Model\"\"\"\n",
        "    if discount_rate <= terminal_growth:\n",
        "        return 0\n",
        "    return final_fcf * (1 + terminal_growth) / (discount_rate - terminal_growth)\n",
        "\n",
        "def project_fcff_enhanced(base_revenue, base_ebit, revenue_growth, ebit_margin, tax_rate,\n",
        "                         depreciation_pct, capex_pct, change_wc, forecast_years):\n",
        "    \"\"\"\n",
        "    ENHANCED: Project FCFF with D&A and CapEx scaling with revenue\n",
        "    \"\"\"\n",
        "    projections = []\n",
        "\n",
        "    current_revenue = base_revenue\n",
        "\n",
        "    for year in range(1, forecast_years + 1):\n",
        "        # Grow revenue\n",
        "        current_revenue = current_revenue * (1 + revenue_growth)\n",
        "\n",
        "        # Calculate EBIT based on margin\n",
        "        current_ebit = current_revenue * ebit_margin\n",
        "\n",
        "        # Calculate NOPAT\n",
        "        nopat = current_ebit * (1 - tax_rate)\n",
        "\n",
        "        # FIXED: Scale D&A and CapEx with revenue\n",
        "        depreciation = current_revenue * depreciation_pct\n",
        "        capex = current_revenue * capex_pct\n",
        "\n",
        "        # Calculate FCFF\n",
        "        fcff = nopat + depreciation - capex - change_wc\n",
        "\n",
        "        projections.append({\n",
        "            'year': year,\n",
        "            'revenue': current_revenue,\n",
        "            'ebit': current_ebit,\n",
        "            'nopat': nopat,\n",
        "            'depreciation': depreciation,\n",
        "            'capex': capex,\n",
        "            'change_wc': change_wc,\n",
        "            'fcff': fcff\n",
        "        })\n",
        "\n",
        "    return projections\n",
        "\n",
        "def project_fcfe_enhanced(base_revenue, base_net_income, revenue_growth, tax_rate,\n",
        "                         depreciation_pct, capex_pct, change_wc, net_borrowing, forecast_years):\n",
        "    \"\"\"\n",
        "    ENHANCED: Project FCFE with D&A and CapEx scaling with revenue\n",
        "    \"\"\"\n",
        "    projections = []\n",
        "\n",
        "    current_revenue = base_revenue\n",
        "    current_ni = base_net_income\n",
        "\n",
        "    # Calculate initial NI margin\n",
        "    ni_margin = current_ni / current_revenue if current_revenue > 0 else 0\n",
        "\n",
        "    for year in range(1, forecast_years + 1):\n",
        "        # Grow revenue\n",
        "        current_revenue = current_revenue * (1 + revenue_growth)\n",
        "\n",
        "        # Grow net income\n",
        "        current_ni = current_revenue * ni_margin\n",
        "\n",
        "        # FIXED: Scale D&A and CapEx with revenue\n",
        "        depreciation = current_revenue * depreciation_pct\n",
        "        capex = current_revenue * capex_pct\n",
        "\n",
        "        # Calculate FCFE\n",
        "        fcfe = current_ni + depreciation - capex - change_wc + net_borrowing\n",
        "\n",
        "        projections.append({\n",
        "            'year': year,\n",
        "            'revenue': current_revenue,\n",
        "            'net_income': current_ni,\n",
        "            'depreciation': depreciation,\n",
        "            'capex': capex,\n",
        "            'change_wc': change_wc,\n",
        "            'net_borrowing': net_borrowing,\n",
        "            'fcfe': fcfe\n",
        "        })\n",
        "\n",
        "    return projections\n",
        "\n",
        "def calculate_dcf_value(projections, discount_rate, terminal_value, shares_outstanding,\n",
        "                       net_debt=0, method='FCFF'):\n",
        "    \"\"\"Calculate DCF valuation\"\"\"\n",
        "    # Discount projected cash flows\n",
        "    pv_cash_flows = []\n",
        "    total_pv = 0\n",
        "\n",
        "    for proj in projections:\n",
        "        year = proj['year']\n",
        "        cf = proj['fcff'] if method == 'FCFF' else proj['fcfe']\n",
        "        pv = cf / ((1 + discount_rate) ** year)\n",
        "        pv_cash_flows.append(pv)\n",
        "        total_pv += pv\n",
        "\n",
        "    # Discount terminal value\n",
        "    pv_terminal = terminal_value / ((1 + discount_rate) ** len(projections))\n",
        "\n",
        "    # Calculate enterprise/equity value\n",
        "    enterprise_value = total_pv + pv_terminal\n",
        "\n",
        "    if method == 'FCFF':\n",
        "        # For FCFF, subtract net debt to get equity value\n",
        "        equity_value = enterprise_value - net_debt\n",
        "    else:\n",
        "        # For FCFE, enterprise value IS equity value\n",
        "        equity_value = enterprise_value\n",
        "\n",
        "    # Calculate per share value\n",
        "    intrinsic_value_per_share = equity_value / shares_outstanding if shares_outstanding > 0 else 0\n",
        "\n",
        "    return {\n",
        "        'pv_cash_flows': pv_cash_flows,\n",
        "        'total_pv_cash_flows': total_pv,\n",
        "        'terminal_value': terminal_value,\n",
        "        'pv_terminal': pv_terminal,\n",
        "        'enterprise_value': enterprise_value,\n",
        "        'equity_value': equity_value,\n",
        "        'intrinsic_value_per_share': intrinsic_value_per_share\n",
        "    }\n",
        "\n",
        "# ============================================================================\n",
        "# PHOENIX PARSER\n",
        "# ============================================================================\n",
        "\n",
        "def parse_trade_history_file(uploaded_file):\n",
        "    try:\n",
        "        df = pd.read_html(uploaded_file)[0]\n",
        "        required_cols = ['Date', 'Symbol', 'Trade Type', 'Quantity', 'Price']\n",
        "        if not all(col in df.columns for col in required_cols):\n",
        "            return None\n",
        "        df['Price'] = df['Price'].astype(str).str.replace('$', '').str.replace(',', '').astype(float)\n",
        "        df['Date'] = pd.to_datetime(df['Date'])\n",
        "        df = df.sort_values('Date')\n",
        "        return df\n",
        "    except:\n",
        "        return None\n",
        "\n",
        "def parse_account_history_file(uploaded_file):\n",
        "    try:\n",
        "        df = pd.read_html(uploaded_file)[0]\n",
        "        df['Date'] = pd.to_datetime(df['Date'])\n",
        "        df = df.sort_values('Date')\n",
        "        return df\n",
        "    except:\n",
        "        return None\n",
        "\n",
        "def calculate_portfolio_from_trades(trade_df):\n",
        "    holdings = {}\n",
        "    for _, row in trade_df.iterrows():\n",
        "        symbol = row['Symbol']\n",
        "        trade_type = row['Trade Type']\n",
        "        quantity = row['Quantity']\n",
        "        price = row['Price']\n",
        "\n",
        "        if is_option_ticker(symbol):\n",
        "            continue\n",
        "\n",
        "        if symbol not in holdings:\n",
        "            holdings[symbol] = {'total_shares': 0, 'total_cost': 0, 'trades': []}\n",
        "\n",
        "        is_buy = 'Buy' in trade_type\n",
        "\n",
        "        if is_buy:\n",
        "            holdings[symbol]['total_shares'] += quantity\n",
        "            holdings[symbol]['total_cost'] += (quantity * price)\n",
        "            holdings[symbol]['trades'].append({'type': 'BUY', 'quantity': quantity, 'price': price})\n",
        "        else:\n",
        "            remaining_to_sell = quantity\n",
        "            for trade in holdings[symbol]['trades']:\n",
        "                if trade['type'] == 'BUY' and remaining_to_sell > 0:\n",
        "                    if trade['quantity'] <= remaining_to_sell:\n",
        "                        holdings[symbol]['total_cost'] -= (trade['quantity'] * trade['price'])\n",
        "                        holdings[symbol]['total_shares'] -= trade['quantity']\n",
        "                        remaining_to_sell -= trade['quantity']\n",
        "                        trade['quantity'] = 0\n",
        "                    else:\n",
        "                        holdings[symbol]['total_cost'] -= (remaining_to_sell * trade['price'])\n",
        "                        holdings[symbol]['total_shares'] -= remaining_to_sell\n",
        "                        trade['quantity'] -= remaining_to_sell\n",
        "                        remaining_to_sell = 0\n",
        "\n",
        "    portfolio_data = []\n",
        "    for symbol, data in holdings.items():\n",
        "        if data['total_shares'] > 0:\n",
        "            avg_cost = data['total_cost'] / data['total_shares']\n",
        "            portfolio_data.append({\n",
        "                'Ticker': symbol,\n",
        "                'Shares': data['total_shares'],\n",
        "                'Avg Cost': avg_cost\n",
        "            })\n",
        "\n",
        "    if not portfolio_data:\n",
        "        return pd.DataFrame(columns=['Ticker', 'Shares', 'Avg Cost'])\n",
        "    return pd.DataFrame(portfolio_data).sort_values('Ticker')\n",
        "\n",
        "# ============================================================================\n",
        "# PORTFOLIO CALCULATIONS\n",
        "# ============================================================================\n",
        "\n",
        "@st.cache_data(ttl=600)\n",
        "def calculate_portfolio_returns(df, start_date, end_date):\n",
        "    try:\n",
        "        valid_positions = []\n",
        "        for _, row in df.iterrows():\n",
        "            if not is_option_ticker(row['Ticker']):\n",
        "                valid_positions.append(row)\n",
        "\n",
        "        if not valid_positions:\n",
        "            return None\n",
        "\n",
        "        valid_df = pd.DataFrame(valid_positions)\n",
        "        all_data = {}\n",
        "\n",
        "        for _, row in valid_df.iterrows():\n",
        "            ticker = row['Ticker']\n",
        "            data = fetch_historical_data(ticker, start_date, end_date)\n",
        "            if data is not None and len(data) > 0:\n",
        "                all_data[ticker] = data\n",
        "\n",
        "        if not all_data:\n",
        "            return None\n",
        "\n",
        "        common_dates = None\n",
        "        for ticker, data in all_data.items():\n",
        "            dates = set(data.index)\n",
        "            common_dates = dates if common_dates is None else common_dates.intersection(dates)\n",
        "\n",
        "        common_dates = sorted(list(common_dates))\n",
        "        if len(common_dates) < 2:\n",
        "            return None\n",
        "\n",
        "        portfolio_values = []\n",
        "        for date in common_dates:\n",
        "            daily_value = 0\n",
        "            for _, row in valid_df.iterrows():\n",
        "                ticker = row['Ticker']\n",
        "                if ticker in all_data:\n",
        "                    try:\n",
        "                        price = all_data[ticker].loc[date, 'Close']\n",
        "                        daily_value += price * row['Shares']\n",
        "                    except KeyError:\n",
        "                        continue\n",
        "            portfolio_values.append(daily_value)\n",
        "\n",
        "        portfolio_series = pd.Series(portfolio_values, index=common_dates)\n",
        "        returns = portfolio_series.pct_change().dropna()\n",
        "        return returns\n",
        "    except:\n",
        "        return None\n",
        "\n",
        "@st.cache_data(ttl=600)\n",
        "def calculate_benchmark_returns(benchmark_ticker, start_date, end_date):\n",
        "    try:\n",
        "        data = fetch_historical_data(benchmark_ticker, start_date, end_date)\n",
        "        if data is None or data.empty:\n",
        "            return None\n",
        "        returns = data['Close'].pct_change().dropna()\n",
        "        return returns\n",
        "    except:\n",
        "        return None\n",
        "\n",
        "# ============================================================================\n",
        "# ENHANCED HOLDINGS TABLE\n",
        "# ============================================================================\n",
        "\n",
        "def create_enhanced_holdings_table(df):\n",
        "    enhanced_df = df.copy()\n",
        "\n",
        "    for idx, row in enhanced_df.iterrows():\n",
        "        ticker = row['Ticker']\n",
        "        market_data = fetch_market_data(ticker)\n",
        "\n",
        "        if market_data:\n",
        "            enhanced_df.at[idx, 'Asset Name'] = market_data['company_name']\n",
        "            enhanced_df.at[idx, 'Current Price'] = market_data['price']\n",
        "            enhanced_df.at[idx, 'Daily Change'] = market_data['daily_change']\n",
        "            enhanced_df.at[idx, 'Daily Change %'] = market_data['daily_change_pct']\n",
        "            enhanced_df.at[idx, '5D Return %'] = market_data['five_day_return']\n",
        "            enhanced_df.at[idx, 'Beta'] = market_data.get('beta', 'N/A')\n",
        "            enhanced_df.at[idx, 'Volume'] = market_data.get('volume', 0)\n",
        "            base_sector = market_data.get('sector', 'Unknown')\n",
        "            enhanced_df.at[idx, 'Sector'] = classify_ticker_sector(ticker, base_sector)\n",
        "        else:\n",
        "            enhanced_df.at[idx, 'Asset Name'] = ticker\n",
        "            enhanced_df.at[idx, 'Sector'] = 'Other'\n",
        "\n",
        "        analyst_data = fetch_analyst_data(ticker)\n",
        "        if analyst_data['success']:\n",
        "            enhanced_df.at[idx, 'Analyst Rating'] = analyst_data['rating']\n",
        "            enhanced_df.at[idx, 'Price Target'] = analyst_data['target_price']\n",
        "        else:\n",
        "            enhanced_df.at[idx, 'Analyst Rating'] = 'No Coverage'\n",
        "\n",
        "    enhanced_df['Sector'] = enhanced_df['Sector'].fillna('Other')\n",
        "    enhanced_df['Shares'] = enhanced_df['Shares'].round(0).astype(int)\n",
        "\n",
        "    enhanced_df['Total Cost'] = enhanced_df['Shares'] * enhanced_df['Avg Cost']\n",
        "    enhanced_df['Total Value'] = enhanced_df['Shares'] * enhanced_df['Current Price']\n",
        "    enhanced_df['Total Gain/Loss $'] = enhanced_df['Total Value'] - enhanced_df['Total Cost']\n",
        "    enhanced_df['Total Gain/Loss %'] = ((enhanced_df['Current Price'] - enhanced_df['Avg Cost']) / enhanced_df['Avg Cost']) * 100\n",
        "    enhanced_df['Daily P&L $'] = enhanced_df['Shares'] * enhanced_df['Daily Change']\n",
        "\n",
        "    total_value = enhanced_df['Total Value'].sum()\n",
        "    enhanced_df['Weight %'] = (enhanced_df['Total Value'] / total_value * 100) if total_value > 0 else 0\n",
        "\n",
        "    return enhanced_df\n",
        "\n",
        "def style_holdings_dataframe(df):\n",
        "    display_df = df[[\n",
        "        'Ticker', 'Asset Name', 'Shares', 'Avg Cost', 'Current Price',\n",
        "        'Daily Change %', '5D Return %', 'Weight %', 'Daily P&L $',\n",
        "        'Total Gain/Loss $', 'Total Gain/Loss %', 'Beta', 'Analyst Rating'\n",
        "    ]].copy()\n",
        "\n",
        "    pct_cols = ['Daily Change %', '5D Return %', 'Weight %', 'Total Gain/Loss %']\n",
        "    for col in pct_cols:\n",
        "        display_df[col] = display_df[col].apply(lambda x: format_percentage(x))\n",
        "\n",
        "    currency_cols = ['Avg Cost', 'Current Price', 'Daily P&L $', 'Total Gain/Loss $']\n",
        "    for col in currency_cols:\n",
        "        display_df[col] = display_df[col].apply(format_currency)\n",
        "\n",
        "    display_df['Daily Change %'] = display_df['Daily Change %'].apply(add_arrow_indicator)\n",
        "    display_df['Total Gain/Loss %'] = display_df['Total Gain/Loss %'].apply(add_arrow_indicator)\n",
        "\n",
        "    return display_df\n",
        "\n",
        "# ============================================================================\n",
        "# RISK METRICS\n",
        "# ============================================================================\n",
        "\n",
        "def calculate_sharpe_ratio(returns, risk_free_rate=RISK_FREE_RATE):\n",
        "    if not is_valid_series(returns) or len(returns) < 2:\n",
        "        return None\n",
        "    total_return = (1 + returns).prod() - 1\n",
        "    n_years = len(returns) / 252\n",
        "    annualized_return = (1 + total_return) ** (1/n_years) - 1 if n_years > 0 else 0\n",
        "    annualized_vol = returns.std() * np.sqrt(252)\n",
        "    sharpe = (annualized_return - risk_free_rate) / annualized_vol if annualized_vol > 0 else 0\n",
        "    return sharpe\n",
        "\n",
        "def calculate_sortino_ratio(returns, risk_free_rate=RISK_FREE_RATE):\n",
        "    if not is_valid_series(returns) or len(returns) < 2:\n",
        "        return None\n",
        "    total_return = (1 + returns).prod() - 1\n",
        "    n_years = len(returns) / 252\n",
        "    annualized_return = (1 + total_return) ** (1/n_years) - 1 if n_years > 0 else 0\n",
        "    downside_returns = returns[returns < 0]\n",
        "    if len(downside_returns) < 2:\n",
        "        return None\n",
        "    downside_std = downside_returns.std() * np.sqrt(252)\n",
        "    sortino = (annualized_return - risk_free_rate) / downside_std if downside_std > 0 else 0\n",
        "    return sortino\n",
        "\n",
        "def calculate_information_ratio(portfolio_returns, benchmark_returns):\n",
        "    if not is_valid_series(portfolio_returns) or not is_valid_series(benchmark_returns):\n",
        "        return None\n",
        "    if len(portfolio_returns) < 2 or len(benchmark_returns) < 2:\n",
        "        return None\n",
        "    common_dates = portfolio_returns.index.intersection(benchmark_returns.index)\n",
        "    portfolio_returns = portfolio_returns.loc[common_dates]\n",
        "    benchmark_returns = benchmark_returns.loc[common_dates]\n",
        "    excess_returns = portfolio_returns - benchmark_returns\n",
        "    if len(excess_returns) < 2:\n",
        "        return None\n",
        "    total_excess = (1 + excess_returns).prod() - 1\n",
        "    n_years = len(excess_returns) / 252\n",
        "    annualized_excess = (1 + total_excess) ** (1/n_years) - 1 if n_years > 0 else 0\n",
        "    tracking_error = excess_returns.std() * np.sqrt(252)\n",
        "    info_ratio = annualized_excess / tracking_error if tracking_error > 0 else 0\n",
        "    return info_ratio\n",
        "\n",
        "def calculate_var(returns, confidence=0.95):\n",
        "    if not is_valid_series(returns) or len(returns) < 2:\n",
        "        return None\n",
        "    var = np.percentile(returns, (1 - confidence) * 100)\n",
        "    return var * 100\n",
        "\n",
        "def calculate_cvar(returns, confidence=0.95):\n",
        "    if not is_valid_series(returns) or len(returns) < 2:\n",
        "        return None\n",
        "    var = np.percentile(returns, (1 - confidence) * 100)\n",
        "    cvar = returns[returns <= var].mean()\n",
        "    return cvar * 100\n",
        "\n",
        "def calculate_max_drawdown(returns):\n",
        "    if not is_valid_series(returns) or len(returns) < 2:\n",
        "        return None\n",
        "    cumulative = (1 + returns).cumprod()\n",
        "    running_max = cumulative.expanding().max()\n",
        "    drawdown = (cumulative - running_max) / running_max\n",
        "    return drawdown.min() * 100\n",
        "\n",
        "def calculate_calmar_ratio(returns, risk_free_rate=RISK_FREE_RATE):\n",
        "    if not is_valid_series(returns) or len(returns) < 2:\n",
        "        return None\n",
        "    total_return = (1 + returns).prod() - 1\n",
        "    n_years = len(returns) / 252\n",
        "    annualized_return = (1 + total_return) ** (1/n_years) - 1 if n_years > 0 else 0\n",
        "    max_dd = abs(calculate_max_drawdown(returns))\n",
        "    if max_dd == 0:\n",
        "        return 0\n",
        "    return (annualized_return - risk_free_rate) / (max_dd / 100)\n",
        "\n",
        "# ============================================================================\n",
        "# CONTINUING IN PART 2...\n",
        "# ============================================================================\n",
        "# Part 2 will contain all visualizations and page implementations\n",
        "# Save this file and paste Part 2 below it!\n",
        "\n",
        "\"\"\"\n",
        "ATLAS TERMINAL v9.3 EXCELLENCE EDITION - PART 2 OF 2\n",
        "All Visualizations and Page Implementations\n",
        "\n",
        "PASTE THIS FILE BELOW PART 1 TO COMPLETE THE APP!\n",
        "\"\"\"\n",
        "\n",
        "# ============================================================================\n",
        "# WORLD-CLASS VISUALIZATIONS - ENHANCED WITH SEAMLESS THEMING\n",
        "# ============================================================================\n",
        "\n",
        "def create_top_contributors_chart(df, top_n=5):\n",
        "    \"\"\"NEW: Top contributors visualization for Home Page\"\"\"\n",
        "    top_contributors = df.nlargest(top_n, 'Total Gain/Loss $')[['Ticker', 'Asset Name', 'Total Gain/Loss $', 'Total Gain/Loss %']]\n",
        "\n",
        "    fig = go.Figure()\n",
        "\n",
        "    fig.add_trace(go.Bar(\n",
        "        x=top_contributors['Total Gain/Loss $'],\n",
        "        y=top_contributors['Ticker'],\n",
        "        orientation='h',\n",
        "        marker=dict(\n",
        "            color=top_contributors['Total Gain/Loss $'],\n",
        "            colorscale=[[0, COLORS['success']], [1, COLORS['success']]],\n",
        "            line=dict(color=COLORS['border'], width=2)\n",
        "        ),\n",
        "        text=[f\"${x:,.0f}\" for x in top_contributors['Total Gain/Loss $']],\n",
        "        textposition='auto',\n",
        "        hovertemplate='<b>%{y}</b><br>P&L: %{text}<extra></extra>'\n",
        "    ))\n",
        "\n",
        "    fig.update_layout(\n",
        "        title=\"üéØ Top 5 Contributors\",\n",
        "        xaxis_title=\"Total Gain ($)\",\n",
        "        yaxis_title=\"\",\n",
        "        height=400,\n",
        "        showlegend=False\n",
        "    )\n",
        "\n",
        "    apply_chart_theme(fig)\n",
        "    return fig\n",
        "\n",
        "def create_top_detractors_chart(df, top_n=5):\n",
        "    \"\"\"NEW: Top detractors visualization for Home Page\"\"\"\n",
        "    top_detractors = df.nsmallest(top_n, 'Total Gain/Loss $')[['Ticker', 'Asset Name', 'Total Gain/Loss $', 'Total Gain/Loss %']]\n",
        "\n",
        "    fig = go.Figure()\n",
        "\n",
        "    fig.add_trace(go.Bar(\n",
        "        x=top_detractors['Total Gain/Loss $'],\n",
        "        y=top_detractors['Ticker'],\n",
        "        orientation='h',\n",
        "        marker=dict(\n",
        "            color=top_detractors['Total Gain/Loss $'],\n",
        "            colorscale=[[0, COLORS['danger']], [1, COLORS['danger']]],\n",
        "            line=dict(color=COLORS['border'], width=2)\n",
        "        ),\n",
        "        text=[f\"${x:,.0f}\" for x in top_detractors['Total Gain/Loss $']],\n",
        "        textposition='auto',\n",
        "        hovertemplate='<b>%{y}</b><br>P&L: %{text}<extra></extra>'\n",
        "    ))\n",
        "\n",
        "    fig.update_layout(\n",
        "        title=\"‚ö†Ô∏è Top 5 Detractors\",\n",
        "        xaxis_title=\"Total Loss ($)\",\n",
        "        yaxis_title=\"\",\n",
        "        height=400,\n",
        "        showlegend=False\n",
        "    )\n",
        "\n",
        "    apply_chart_theme(fig)\n",
        "    return fig\n",
        "\n",
        "def create_sector_allocation_donut(df):\n",
        "    \"\"\"NEW: Sector allocation donut chart for Home Page\"\"\"\n",
        "    sector_allocation = df.groupby('Sector')['Total Value'].sum().reset_index()\n",
        "    sector_allocation = sector_allocation.sort_values('Total Value', ascending=False)\n",
        "\n",
        "    fig = go.Figure(data=[go.Pie(\n",
        "        labels=sector_allocation['Sector'],\n",
        "        values=sector_allocation['Total Value'],\n",
        "        hole=0.5,\n",
        "        marker=dict(\n",
        "            colors=px.colors.qualitative.Set3,\n",
        "            line=dict(color=COLORS['border'], width=2)\n",
        "        ),\n",
        "        textinfo='label+percent',\n",
        "        textfont=dict(size=12)\n",
        "    )])\n",
        "\n",
        "    fig.update_layout(\n",
        "        title=\"üìä Sector Allocation\",\n",
        "        height=400,\n",
        "        showlegend=True,\n",
        "        legend=dict(x=0.85, y=0.5)\n",
        "    )\n",
        "\n",
        "    apply_chart_theme(fig)\n",
        "    return fig\n",
        "\n",
        "def create_rolling_metrics_chart(returns, window=60):\n",
        "    \"\"\"Rolling metrics visualization - ENHANCED THEMING\"\"\"\n",
        "    if not is_valid_series(returns) or len(returns) < window:\n",
        "        return None\n",
        "\n",
        "    rolling_vol = returns.rolling(window).std() * np.sqrt(252) * 100\n",
        "    rolling_sharpe = (returns.rolling(window).mean() * 252 - RISK_FREE_RATE) / (returns.rolling(window).std() * np.sqrt(252))\n",
        "\n",
        "    fig = make_subplots(\n",
        "        rows=2, cols=1,\n",
        "        subplot_titles=('Rolling Volatility (60-Day)', 'Rolling Sharpe Ratio (60-Day)'),\n",
        "        vertical_spacing=0.15\n",
        "    )\n",
        "\n",
        "    fig.add_trace(\n",
        "        go.Scatter(\n",
        "            x=rolling_vol.index,\n",
        "            y=rolling_vol.values,\n",
        "            fill='tozeroy',\n",
        "            fillcolor='rgba(255, 0, 68, 0.2)',\n",
        "            line=dict(color=COLORS['danger'], width=2),\n",
        "            name='Volatility'\n",
        "        ),\n",
        "        row=1, col=1\n",
        "    )\n",
        "\n",
        "    fig.add_trace(\n",
        "        go.Scatter(\n",
        "            x=rolling_sharpe.index,\n",
        "            y=rolling_sharpe.values,\n",
        "            fill='tozeroy',\n",
        "            fillcolor='rgba(0, 212, 255, 0.2)',\n",
        "            line=dict(color=COLORS['neon_blue'], width=2),\n",
        "            name='Sharpe Ratio'\n",
        "        ),\n",
        "        row=2, col=1\n",
        "    )\n",
        "\n",
        "    fig.add_hline(y=0, line_dash=\"dash\", line_color=COLORS['text_muted'], row=2, col=1)\n",
        "\n",
        "    fig.update_layout(\n",
        "        height=600,\n",
        "        showlegend=False,\n",
        "        title_text=\"üìä Rolling Risk Metrics\"\n",
        "    )\n",
        "\n",
        "    apply_chart_theme(fig)\n",
        "    return fig\n",
        "\n",
        "def create_underwater_plot(returns):\n",
        "    \"\"\"Underwater drawdown plot - ENHANCED THEMING\"\"\"\n",
        "    if not is_valid_series(returns) or len(returns) < 2:\n",
        "        return None\n",
        "\n",
        "    cumulative = (1 + returns).cumprod()\n",
        "    running_max = cumulative.expanding().max()\n",
        "    drawdown = ((cumulative - running_max) / running_max) * 100\n",
        "\n",
        "    fig = go.Figure()\n",
        "\n",
        "    fig.add_trace(go.Scatter(\n",
        "        x=drawdown.index,\n",
        "        y=drawdown.values,\n",
        "        fill='tozeroy',\n",
        "        fillcolor='rgba(255, 0, 68, 0.3)',\n",
        "        line=dict(color=COLORS['danger'], width=2),\n",
        "        name='Drawdown'\n",
        "    ))\n",
        "\n",
        "    fig.add_hline(y=0, line_dash=\"solid\", line_color=COLORS['text_primary'], line_width=1)\n",
        "\n",
        "    max_dd_idx = drawdown.idxmin()\n",
        "    max_dd_val = drawdown.min()\n",
        "\n",
        "    fig.add_annotation(\n",
        "        x=max_dd_idx,\n",
        "        y=max_dd_val,\n",
        "        text=f\"Max DD: {max_dd_val:.2f}%\",\n",
        "        showarrow=True,\n",
        "        arrowhead=2,\n",
        "        arrowcolor=COLORS['danger'],\n",
        "        ax=0,\n",
        "        ay=-40,\n",
        "        bgcolor=COLORS['card_background'],\n",
        "        bordercolor=COLORS['danger'],\n",
        "        borderwidth=2\n",
        "    )\n",
        "\n",
        "    fig.update_layout(\n",
        "        title=\"üåä Underwater Plot\",\n",
        "        xaxis_title=\"Date\",\n",
        "        yaxis_title=\"Drawdown (%)\",\n",
        "        height=500\n",
        "    )\n",
        "\n",
        "    apply_chart_theme(fig)\n",
        "    return fig\n",
        "\n",
        "def create_var_waterfall(returns):\n",
        "    \"\"\"VaR/CVaR waterfall chart - ENHANCED THEMING\"\"\"\n",
        "    if not is_valid_series(returns) or len(returns) < 2:\n",
        "        return None\n",
        "\n",
        "    var_90 = calculate_var(returns, 0.90)\n",
        "    var_95 = calculate_var(returns, 0.95)\n",
        "    var_99 = calculate_var(returns, 0.99)\n",
        "    cvar_95 = calculate_cvar(returns, 0.95)\n",
        "\n",
        "    categories = ['VaR 90%', 'VaR 95%', 'VaR 99%', 'CVaR 95%']\n",
        "    values = [var_90, var_95, var_99, cvar_95]\n",
        "\n",
        "    colors_list = [COLORS['warning'], COLORS['orange'], COLORS['danger'], COLORS['danger']]\n",
        "\n",
        "    fig = go.Figure()\n",
        "\n",
        "    fig.add_trace(go.Bar(\n",
        "        x=categories,\n",
        "        y=values,\n",
        "        marker=dict(\n",
        "            color=colors_list,\n",
        "            line=dict(color=COLORS['border'], width=2)\n",
        "        ),\n",
        "        text=[f\"{v:.2f}%\" for v in values],\n",
        "        textposition='outside'\n",
        "    ))\n",
        "\n",
        "    fig.update_layout(\n",
        "        title=\"‚ö†Ô∏è Value at Risk Waterfall\",\n",
        "        xaxis_title=\"Risk Measure\",\n",
        "        yaxis_title=\"Expected Loss (%)\",\n",
        "        height=500\n",
        "    )\n",
        "\n",
        "    apply_chart_theme(fig)\n",
        "    return fig\n",
        "\n",
        "def create_risk_contribution_sunburst(df):\n",
        "    \"\"\"Risk contribution sunburst - ENHANCED THEMING\"\"\"\n",
        "    risk_data = []\n",
        "\n",
        "    for _, row in df.iterrows():\n",
        "        ticker = row['Ticker']\n",
        "        weight = row['Weight %']\n",
        "        sector = row['Sector']\n",
        "\n",
        "        hist_data = fetch_historical_data(ticker, datetime.now() - timedelta(days=365), datetime.now())\n",
        "        if hist_data is not None and len(hist_data) > 30:\n",
        "            returns = hist_data['Close'].pct_change().dropna()\n",
        "            vol = returns.std() * np.sqrt(252) * 100\n",
        "            risk_contribution = weight * vol\n",
        "\n",
        "            risk_data.append({\n",
        "                'Ticker': ticker,\n",
        "                'Sector': sector,\n",
        "                'Weight': weight,\n",
        "                'Volatility': vol,\n",
        "                'Risk Contribution': risk_contribution\n",
        "            })\n",
        "\n",
        "    if not risk_data:\n",
        "        return None\n",
        "\n",
        "    risk_df = pd.DataFrame(risk_data)\n",
        "\n",
        "    fig = px.sunburst(\n",
        "        risk_df,\n",
        "        path=['Sector', 'Ticker'],\n",
        "        values='Risk Contribution',\n",
        "        color='Volatility',\n",
        "        color_continuous_scale='RdYlGn_r',\n",
        "        title=\"‚òÄÔ∏è Risk Contribution Sunburst\"\n",
        "    )\n",
        "\n",
        "    fig.update_layout(height=600)\n",
        "    apply_chart_theme(fig)\n",
        "    return fig\n",
        "\n",
        "def create_risk_reward_plot(df):\n",
        "    \"\"\"Risk-reward scatter plot - ENHANCED THEMING\"\"\"\n",
        "    risk_reward_data = []\n",
        "\n",
        "    for _, row in df.iterrows():\n",
        "        ticker = row['Ticker']\n",
        "        hist_data = fetch_historical_data(ticker, datetime.now() - timedelta(days=365), datetime.now())\n",
        "\n",
        "        if hist_data is not None and len(hist_data) > 30:\n",
        "            returns = hist_data['Close'].pct_change().dropna()\n",
        "            annual_return = ((1 + returns.mean()) ** 252 - 1) * 100\n",
        "            annual_vol = returns.std() * np.sqrt(252) * 100\n",
        "\n",
        "            risk_reward_data.append({\n",
        "                'Ticker': ticker,\n",
        "                'Asset Name': row['Asset Name'],\n",
        "                'Return': annual_return,\n",
        "                'Risk': annual_vol,\n",
        "                'Weight': row['Weight %'],\n",
        "                'Sector': row['Sector']\n",
        "            })\n",
        "\n",
        "    if not risk_reward_data:\n",
        "        return None\n",
        "\n",
        "    rr_df = pd.DataFrame(risk_reward_data)\n",
        "\n",
        "    fig = px.scatter(\n",
        "        rr_df,\n",
        "        x='Risk',\n",
        "        y='Return',\n",
        "        size='Weight',\n",
        "        color='Sector',\n",
        "        text='Ticker',\n",
        "        hover_data=['Asset Name'],\n",
        "        color_discrete_sequence=px.colors.qualitative.Set3\n",
        "    )\n",
        "\n",
        "    fig.update_traces(\n",
        "        textposition='top center',\n",
        "        marker=dict(line=dict(width=2, color=COLORS['border']))\n",
        "    )\n",
        "\n",
        "    fig.update_layout(\n",
        "        title=\"üìà Risk-Reward Analysis\",\n",
        "        xaxis_title=\"Risk (Annual Volatility %)\",\n",
        "        yaxis_title=\"Expected Return (Annual %)\",\n",
        "        height=500\n",
        "    )\n",
        "\n",
        "    apply_chart_theme(fig)\n",
        "    return fig\n",
        "\n",
        "def create_performance_heatmap(df, period='monthly'):\n",
        "    \"\"\"Performance heatmap - ENHANCED THEMING & FIXED NOV 2024\"\"\"\n",
        "    try:\n",
        "        portfolio_values = {}\n",
        "\n",
        "        end_date = datetime.now()\n",
        "        start_date = end_date - timedelta(days=365)\n",
        "\n",
        "        for _, row in df.iterrows():\n",
        "            ticker = row['Ticker']\n",
        "            hist_data = fetch_historical_data(ticker, start_date, end_date)\n",
        "\n",
        "            if hist_data is not None and len(hist_data) > 0:\n",
        "                monthly_data = hist_data['Close'].resample('M').last()\n",
        "                monthly_returns = monthly_data.pct_change() * 100\n",
        "\n",
        "                for month, ret in monthly_returns.items():\n",
        "                    # FIXED: Skip current incomplete month\n",
        "                    if month.month == end_date.month and month.year == end_date.year:\n",
        "                        continue\n",
        "                    month_str = month.strftime('%b %Y')\n",
        "                    if month_str not in portfolio_values:\n",
        "                        portfolio_values[month_str] = {}\n",
        "                    if pd.notna(ret) and abs(ret) < 50:\n",
        "                        portfolio_values[month_str][ticker] = ret\n",
        "\n",
        "        if not portfolio_values:\n",
        "            return None\n",
        "\n",
        "        tickers = sorted(set(t for months in portfolio_values.values() for t in months))\n",
        "        months = sorted(portfolio_values.keys(), key=lambda x: datetime.strptime(x, '%b %Y'))\n",
        "\n",
        "        # FIXED: Remove current incomplete month\n",
        "        months = [m for m in months if datetime.strptime(m, '%b %Y') < end_date.replace(day=1)]\n",
        "\n",
        "        matrix = []\n",
        "        for ticker in tickers:\n",
        "            row = []\n",
        "            for month in months:\n",
        "                if ticker in portfolio_values[month]:\n",
        "                    val = portfolio_values[month][ticker]\n",
        "                    val = max(-50, min(50, val))\n",
        "                    row.append(val)\n",
        "                else:\n",
        "                    row.append(0)\n",
        "            matrix.append(row)\n",
        "\n",
        "        fig = go.Figure(data=go.Heatmap(\n",
        "            z=matrix,\n",
        "            x=months,\n",
        "            y=tickers,\n",
        "            colorscale='RdYlGn',\n",
        "            zmid=0,\n",
        "            zmin=-20,\n",
        "            zmax=20,\n",
        "            text=np.round(matrix, 1),\n",
        "            texttemplate='%{text}%',\n",
        "            textfont={\"size\": 14},\n",
        "            colorbar=dict(title=\"Return %\")\n",
        "        ))\n",
        "\n",
        "        fig.update_layout(\n",
        "            title=\"üî• Monthly Performance Heatmap\",\n",
        "            xaxis_title=\"Month\",\n",
        "            yaxis_title=\"Asset\",\n",
        "            height=800,\n",
        "            width=1200\n",
        "        )\n",
        "\n",
        "        apply_chart_theme(fig)\n",
        "        return fig\n",
        "    except Exception as e:\n",
        "        st.error(f\"Error: {str(e)}\")\n",
        "        return None\n",
        "\n",
        "def create_portfolio_heatmap(df):\n",
        "    \"\"\"Portfolio treemap - ENHANCED THEMING\"\"\"\n",
        "    df_viz = df[['Ticker', 'Asset Name', 'Weight %', 'Total Gain/Loss %', 'Sector']].copy()\n",
        "    df_viz['Sector'] = df_viz['Sector'].fillna('Other')\n",
        "    df_viz = df_viz.dropna()\n",
        "\n",
        "    if df_viz.empty:\n",
        "        return None\n",
        "\n",
        "    fig = px.treemap(\n",
        "        df_viz,\n",
        "        path=[px.Constant(\"Portfolio\"), 'Sector', 'Ticker'],\n",
        "        values='Weight %',\n",
        "        color='Total Gain/Loss %',\n",
        "        color_continuous_scale='RdYlGn',\n",
        "        color_continuous_midpoint=0,\n",
        "        hover_data={'Asset Name': True, 'Total Gain/Loss %': ':.2f'}\n",
        "    )\n",
        "\n",
        "    fig.update_layout(\n",
        "        title=\"üó∫Ô∏è Portfolio Heatmap\",\n",
        "        height=700\n",
        "    )\n",
        "\n",
        "    apply_chart_theme(fig)\n",
        "    return fig\n",
        "\n",
        "@st.cache_data(ttl=600)\n",
        "def fetch_ticker_performance(ticker, start_date, end_date):\n",
        "    try:\n",
        "        data = fetch_historical_data(ticker, start_date, end_date)\n",
        "        if data is not None and not data.empty:\n",
        "            returns = data['Close'].pct_change().fillna(0)\n",
        "            cumulative = (1 + returns).cumprod() - 1\n",
        "            return cumulative * 100, data\n",
        "        return None, None\n",
        "    except:\n",
        "        return None, None\n",
        "\n",
        "def create_interactive_performance_chart(tickers, start_date, end_date):\n",
        "    \"\"\"Interactive performance chart - ENHANCED THEMING\"\"\"\n",
        "    fig = go.Figure()\n",
        "\n",
        "    colors = [COLORS['neon_blue'], COLORS['electric_blue'], COLORS['teal'],\n",
        "              COLORS['success'], COLORS['warning'], COLORS['danger'],\n",
        "              COLORS['purple'], COLORS['pink'], COLORS['orange']]\n",
        "\n",
        "    for idx, ticker in enumerate(tickers):\n",
        "        cumulative, data = fetch_ticker_performance(ticker, start_date, end_date)\n",
        "        if cumulative is not None:\n",
        "            fig.add_trace(go.Scatter(\n",
        "                x=cumulative.index,\n",
        "                y=cumulative.values,\n",
        "                mode='lines',\n",
        "                name=ticker,\n",
        "                line=dict(width=2.5, color=colors[idx % len(colors)])\n",
        "            ))\n",
        "\n",
        "    if not fig.data:\n",
        "        return None\n",
        "\n",
        "    fig.update_layout(\n",
        "        title=\"üìà Interactive Performance Comparison\",\n",
        "        xaxis_title=\"Date\",\n",
        "        yaxis_title=\"Cumulative Return (%)\",\n",
        "        height=600,\n",
        "        hovermode='x unified',\n",
        "        legend=dict(x=0.01, y=0.99)\n",
        "    )\n",
        "\n",
        "    fig.add_hline(y=0, line_dash=\"dash\", line_color=COLORS['text_muted'], line_width=1)\n",
        "\n",
        "    apply_chart_theme(fig)\n",
        "    return fig\n",
        "\n",
        "def run_monte_carlo_simulation(returns, initial_value=100000, days=252, simulations=1000):\n",
        "    if not is_valid_series(returns) or len(returns) < 30:\n",
        "        return None\n",
        "\n",
        "    daily_return = returns.mean()\n",
        "    daily_vol = returns.std()\n",
        "\n",
        "    simulation_results = []\n",
        "\n",
        "    for _ in range(simulations):\n",
        "        prices = [initial_value]\n",
        "        for _ in range(days):\n",
        "            price = prices[-1] * (1 + np.random.normal(daily_return, daily_vol))\n",
        "            prices.append(price)\n",
        "        simulation_results.append(prices)\n",
        "\n",
        "    return np.array(simulation_results)\n",
        "\n",
        "def create_monte_carlo_chart(simulation_results, initial_value=100000):\n",
        "    if simulation_results is None:\n",
        "        return None, None\n",
        "\n",
        "    fig = go.Figure()\n",
        "\n",
        "    for i in range(min(100, len(simulation_results))):\n",
        "        fig.add_trace(go.Scatter(\n",
        "            y=simulation_results[i],\n",
        "            mode='lines',\n",
        "            line=dict(width=0.5, color=COLORS['electric_blue']),\n",
        "            opacity=0.1,\n",
        "            showlegend=False\n",
        "        ))\n",
        "\n",
        "    percentiles = [5, 25, 50, 75, 95]\n",
        "    colors_pct = [COLORS['danger'], COLORS['warning'], COLORS['info'],\n",
        "                  COLORS['teal'], COLORS['success']]\n",
        "\n",
        "    for p, color in zip(percentiles, colors_pct):\n",
        "        values = np.percentile(simulation_results, p, axis=0)\n",
        "        fig.add_trace(go.Scatter(\n",
        "            y=values,\n",
        "            mode='lines',\n",
        "            line=dict(width=3, color=color),\n",
        "            name=f'{p}th Percentile'\n",
        "        ))\n",
        "\n",
        "    fig.update_layout(\n",
        "        title=\"üé≤ Monte Carlo Simulation\",\n",
        "        xaxis_title=\"Trading Days\",\n",
        "        yaxis_title=\"Portfolio Value ($)\",\n",
        "        height=500\n",
        "    )\n",
        "\n",
        "    apply_chart_theme(fig)\n",
        "\n",
        "    final_values = simulation_results[:, -1]\n",
        "    stats = {\n",
        "        'mean': np.mean(final_values),\n",
        "        'median': np.median(final_values),\n",
        "        'percentile_5': np.percentile(final_values, 5),\n",
        "        'percentile_95': np.percentile(final_values, 95),\n",
        "        'prob_profit': (final_values > initial_value).mean() * 100,\n",
        "        'prob_loss_10': (final_values < initial_value * 0.9).mean() * 100,\n",
        "        'prob_gain_20': (final_values > initial_value * 1.2).mean() * 100\n",
        "    }\n",
        "\n",
        "    return fig, stats\n",
        "\n",
        "def create_risk_parity_analysis(df):\n",
        "    risk_contributions = []\n",
        "\n",
        "    for _, row in df.iterrows():\n",
        "        ticker = row['Ticker']\n",
        "        weight = row['Weight %'] / 100\n",
        "\n",
        "        hist_data = fetch_historical_data(ticker, datetime.now() - timedelta(days=365), datetime.now())\n",
        "        if hist_data is not None and len(hist_data) > 30:\n",
        "            returns = hist_data['Close'].pct_change().dropna()\n",
        "            vol = returns.std() * np.sqrt(252)\n",
        "            risk_contribution = weight * vol\n",
        "\n",
        "            risk_contributions.append({\n",
        "                'Ticker': ticker,\n",
        "                'Weight %': row['Weight %'],\n",
        "                'Volatility': vol * 100,\n",
        "                'Risk Contribution': risk_contribution * 100\n",
        "            })\n",
        "\n",
        "    if not risk_contributions:\n",
        "        return None\n",
        "\n",
        "    rc_df = pd.DataFrame(risk_contributions)\n",
        "    total_risk = rc_df['Risk Contribution'].sum()\n",
        "    rc_df['Risk %'] = (rc_df['Risk Contribution'] / total_risk) * 100\n",
        "\n",
        "    fig = go.Figure()\n",
        "\n",
        "    fig.add_trace(go.Bar(\n",
        "        name='Weight %',\n",
        "        x=rc_df['Ticker'],\n",
        "        y=rc_df['Weight %'],\n",
        "        marker_color=COLORS['electric_blue']\n",
        "    ))\n",
        "\n",
        "    fig.add_trace(go.Bar(\n",
        "        name='Risk Contribution %',\n",
        "        x=rc_df['Ticker'],\n",
        "        y=rc_df['Risk %'],\n",
        "        marker_color=COLORS['danger']\n",
        "    ))\n",
        "\n",
        "    fig.update_layout(\n",
        "        title=\"‚öñÔ∏è Risk Parity Analysis\",\n",
        "        xaxis_title=\"Asset\",\n",
        "        yaxis_title=\"Percentage\",\n",
        "        barmode='group',\n",
        "        height=500\n",
        "    )\n",
        "\n",
        "    apply_chart_theme(fig)\n",
        "    return fig\n",
        "\n",
        "def create_correlation_network(df, start_date, end_date):\n",
        "    returns_data = {}\n",
        "\n",
        "    for _, row in df.iterrows():\n",
        "        ticker = row['Ticker']\n",
        "        hist_data = fetch_historical_data(ticker, start_date, end_date)\n",
        "        if hist_data is not None and len(hist_data) > 30:\n",
        "            returns_data[ticker] = hist_data['Close'].pct_change().dropna()\n",
        "\n",
        "    if len(returns_data) < 2:\n",
        "        return None\n",
        "\n",
        "    returns_df = pd.DataFrame(returns_data)\n",
        "    corr_matrix = returns_df.corr()\n",
        "\n",
        "    fig = go.Figure()\n",
        "\n",
        "    G = nx.Graph()\n",
        "    for ticker in corr_matrix.columns:\n",
        "        G.add_node(ticker)\n",
        "\n",
        "    threshold = 0.5\n",
        "    for i, ticker1 in enumerate(corr_matrix.columns):\n",
        "        for j, ticker2 in enumerate(corr_matrix.columns):\n",
        "            if i < j:\n",
        "                corr = corr_matrix.iloc[i, j]\n",
        "                if abs(corr) > threshold:\n",
        "                    G.add_edge(ticker1, ticker2, weight=abs(corr))\n",
        "\n",
        "    pos = nx.spring_layout(G)\n",
        "\n",
        "    for edge in G.edges():\n",
        "        x0, y0 = pos[edge[0]]\n",
        "        x1, y1 = pos[edge[1]]\n",
        "        weight = G[edge[0]][edge[1]]['weight']\n",
        "\n",
        "        fig.add_trace(go.Scatter(\n",
        "            x=[x0, x1],\n",
        "            y=[y0, y1],\n",
        "            mode='lines',\n",
        "            line=dict(width=weight*5, color=COLORS['electric_blue']),\n",
        "            opacity=0.5,\n",
        "            showlegend=False\n",
        "        ))\n",
        "\n",
        "    node_x = []\n",
        "    node_y = []\n",
        "    node_text = []\n",
        "\n",
        "    for node in G.nodes():\n",
        "        x, y = pos[node]\n",
        "        node_x.append(x)\n",
        "        node_y.append(y)\n",
        "        node_text.append(node)\n",
        "\n",
        "    fig.add_trace(go.Scatter(\n",
        "        x=node_x,\n",
        "        y=node_y,\n",
        "        mode='markers+text',\n",
        "        text=node_text,\n",
        "        textposition='top center',\n",
        "        marker=dict(\n",
        "            size=20,\n",
        "            color=COLORS['neon_blue'],\n",
        "            line=dict(width=2, color=COLORS['border'])\n",
        "        ),\n",
        "        showlegend=False\n",
        "    ))\n",
        "\n",
        "    fig.update_layout(\n",
        "        title=\"üîó Correlation Network\",\n",
        "        showlegend=False,\n",
        "        height=600,\n",
        "        xaxis=dict(showgrid=False, zeroline=False, showticklabels=False),\n",
        "        yaxis=dict(showgrid=False, zeroline=False, showticklabels=False)\n",
        "    )\n",
        "\n",
        "    apply_chart_theme(fig)\n",
        "    return fig\n",
        "\n",
        "def create_efficient_frontier(df):\n",
        "    \"\"\"FIXED BROADCASTING ERROR - ENHANCED THEMING\"\"\"\n",
        "    returns_data = {}\n",
        "    expected_returns = []\n",
        "    volatilities = []\n",
        "    tickers = []\n",
        "\n",
        "    for _, row in df.iterrows():\n",
        "        ticker = row['Ticker']\n",
        "        hist_data = fetch_historical_data(ticker, datetime.now() - timedelta(days=365), datetime.now())\n",
        "\n",
        "        if hist_data is not None and len(hist_data) > 30:\n",
        "            returns = hist_data['Close'].pct_change().dropna()\n",
        "            annual_return = ((1 + returns.mean()) ** 252 - 1)\n",
        "            annual_vol = returns.std() * np.sqrt(252)\n",
        "\n",
        "            expected_returns.append(annual_return)\n",
        "            volatilities.append(annual_vol)\n",
        "            tickers.append(ticker)\n",
        "            returns_data[ticker] = returns\n",
        "\n",
        "    if len(expected_returns) < 2:\n",
        "        return None\n",
        "\n",
        "    returns_df = pd.DataFrame(returns_data)\n",
        "    cov_matrix = returns_df.cov() * 252\n",
        "\n",
        "    num_portfolios = 5000\n",
        "    results = np.zeros((3, num_portfolios))\n",
        "\n",
        "    np.random.seed(42)\n",
        "\n",
        "    for i in range(num_portfolios):\n",
        "        weights = np.random.random(len(tickers))\n",
        "        weights /= np.sum(weights)\n",
        "\n",
        "        portfolio_return = np.sum(weights * np.array(expected_returns))\n",
        "        portfolio_vol = np.sqrt(np.dot(weights.T, np.dot(cov_matrix, weights)))\n",
        "        sharpe = (portfolio_return - RISK_FREE_RATE) / portfolio_vol if portfolio_vol > 0 else 0\n",
        "\n",
        "        results[0, i] = portfolio_return * 100\n",
        "        results[1, i] = portfolio_vol * 100\n",
        "        results[2, i] = sharpe\n",
        "\n",
        "    fig = go.Figure()\n",
        "\n",
        "    fig.add_trace(go.Scatter(\n",
        "        x=results[1],\n",
        "        y=results[0],\n",
        "        mode='markers',\n",
        "        marker=dict(\n",
        "            size=5,\n",
        "            color=results[2],\n",
        "            colorscale='Viridis',\n",
        "            showscale=True,\n",
        "            colorbar=dict(title=\"Sharpe Ratio\")\n",
        "        ),\n",
        "        name='Efficient Frontier'\n",
        "    ))\n",
        "\n",
        "    # FIXED: Properly align weights and returns\n",
        "    current_weights = df[df['Ticker'].isin(tickers)]['Weight %'].values / 100\n",
        "    aligned_returns = np.array(expected_returns[:len(current_weights)])\n",
        "    aligned_cov = cov_matrix.iloc[:len(current_weights), :len(current_weights)]\n",
        "\n",
        "    current_return = np.sum(current_weights * aligned_returns) * 100\n",
        "    current_vol = np.sqrt(np.dot(current_weights.T, np.dot(aligned_cov, current_weights))) * 100\n",
        "\n",
        "    fig.add_trace(go.Scatter(\n",
        "        x=[current_vol],\n",
        "        y=[current_return],\n",
        "        mode='markers',\n",
        "        marker=dict(size=20, color=COLORS['danger'], symbol='star'),\n",
        "        name='Current Portfolio'\n",
        "    ))\n",
        "\n",
        "    fig.update_layout(\n",
        "        title=\"üìä Efficient Frontier\",\n",
        "        xaxis_title=\"Risk (Volatility %)\",\n",
        "        yaxis_title=\"Return %\",\n",
        "        height=600\n",
        "    )\n",
        "\n",
        "    apply_chart_theme(fig)\n",
        "    return fig\n",
        "\n",
        "# ============================================================================\n",
        "# MARKET WATCH - ENHANCED\n",
        "# ============================================================================\n",
        "\n",
        "@st.cache_data(ttl=300)\n",
        "def fetch_market_watch_data(tickers_dict):\n",
        "    market_data = []\n",
        "\n",
        "    for ticker, info in tickers_dict.items():\n",
        "        try:\n",
        "            stock = yf.Ticker(ticker)\n",
        "            hist = stock.history(period=\"5d\")\n",
        "\n",
        "            if not hist.empty:\n",
        "                current = hist['Close'].iloc[-1]\n",
        "                prev = hist['Close'].iloc[-2] if len(hist) > 1 else current\n",
        "                change = ((current - prev) / prev) * 100\n",
        "\n",
        "                five_day = ((current / hist['Close'].iloc[0]) - 1) * 100 if len(hist) >= 5 else 0\n",
        "\n",
        "                volume = hist['Volume'].iloc[-1]\n",
        "                avg_volume = hist['Volume'].mean()\n",
        "\n",
        "                market_data.append({\n",
        "                    'Symbol': ticker,\n",
        "                    'Name': info.get('name', ticker),\n",
        "                    'Category': info.get('category', info.get('region', '')),\n",
        "                    'Last': current,\n",
        "                    'Change %': change,\n",
        "                    '5D %': five_day,\n",
        "                    'Volume': volume,\n",
        "                    'Avg Volume': avg_volume,\n",
        "                    'Vol/Avg': volume / avg_volume if avg_volume > 0 else 0\n",
        "                })\n",
        "        except:\n",
        "            continue\n",
        "\n",
        "    return pd.DataFrame(market_data)\n",
        "\n",
        "def create_dynamic_market_table(df, filters=None):\n",
        "    if filters:\n",
        "        if 'category' in filters and filters['category']:\n",
        "            df = df[df['Category'] == filters['category']]\n",
        "\n",
        "        if 'min_change' in filters and filters['min_change']:\n",
        "            df = df[df['Change %'] >= filters['min_change']]\n",
        "\n",
        "        if 'sort_by' in filters and filters['sort_by']:\n",
        "            ascending = filters.get('ascending', False)\n",
        "            df = df.sort_values(filters['sort_by'], ascending=ascending)\n",
        "\n",
        "    display_df = df.copy()\n",
        "    display_df['Last'] = display_df['Last'].apply(format_currency)\n",
        "    display_df['Change %'] = display_df['Change %'].apply(lambda x: add_arrow_indicator(format_percentage(x)))\n",
        "    display_df['5D %'] = display_df['5D %'].apply(lambda x: add_arrow_indicator(format_percentage(x)))\n",
        "    display_df['Volume'] = display_df['Volume'].apply(lambda x: f\"{x:,.0f}\")\n",
        "    display_df['Vol/Avg'] = display_df['Vol/Avg'].apply(lambda x: f\"{x:.2f}x\")\n",
        "\n",
        "    return display_df\n",
        "\n",
        "# ============================================================================\n",
        "# PORTFOLIO DEEP DIVE - ENHANCED\n",
        "# ============================================================================\n",
        "\n",
        "def create_sector_rotation_heatmap(df, start_date, end_date):\n",
        "    \"\"\"Sector rotation heatmap - FIXED NOV 2024\"\"\"\n",
        "    sector_returns = {}\n",
        "\n",
        "    end_date_cutoff = datetime.now().replace(day=1)  # First day of current month\n",
        "\n",
        "    for _, row in df.iterrows():\n",
        "        ticker = row['Ticker']\n",
        "        sector = row['Sector']\n",
        "\n",
        "        hist_data = fetch_historical_data(ticker, start_date, end_date)\n",
        "        if hist_data is not None and len(hist_data) > 30:\n",
        "            monthly_data = hist_data['Close'].resample('M').last()\n",
        "            monthly_returns = monthly_data.pct_change() * 100\n",
        "\n",
        "            # FIXED: Filter out current incomplete month\n",
        "            monthly_returns = monthly_returns[monthly_returns.index < end_date_cutoff]\n",
        "\n",
        "            if sector not in sector_returns:\n",
        "                sector_returns[sector] = []\n",
        "\n",
        "            sector_returns[sector].append(monthly_returns)\n",
        "\n",
        "    if not sector_returns:\n",
        "        return None\n",
        "\n",
        "    sector_avg = {}\n",
        "    for sector, returns_list in sector_returns.items():\n",
        "        combined = pd.concat(returns_list, axis=1).mean(axis=1)\n",
        "        sector_avg[sector] = combined\n",
        "\n",
        "    sectors = list(sector_avg.keys())\n",
        "    months = sector_avg[sectors[0]].index\n",
        "\n",
        "    matrix = []\n",
        "    for sector in sectors:\n",
        "        matrix.append(sector_avg[sector].values)\n",
        "\n",
        "    fig = go.Figure(data=go.Heatmap(\n",
        "        z=matrix,\n",
        "        x=[m.strftime('%b %Y') for m in months],\n",
        "        y=sectors,\n",
        "        colorscale='RdYlGn',\n",
        "        zmid=0,\n",
        "        text=np.round(matrix, 1),\n",
        "        texttemplate='%{text}%',\n",
        "        textfont={\"size\": 11},\n",
        "        colorbar=dict(title=\"Return %\")\n",
        "    ))\n",
        "\n",
        "    fig.update_layout(\n",
        "        title=\"üîÑ Sector Rotation Heatmap\",\n",
        "        xaxis_title=\"Month\",\n",
        "        yaxis_title=\"Sector\",\n",
        "        height=500\n",
        "    )\n",
        "\n",
        "    apply_chart_theme(fig)\n",
        "    return fig\n",
        "\n",
        "def create_holdings_attribution_waterfall(df):\n",
        "    \"\"\"Holdings attribution waterfall - ENHANCED THEMING\"\"\"\n",
        "    top_contributors = df.nlargest(10, 'Total Gain/Loss $')\n",
        "\n",
        "    tickers = top_contributors['Ticker'].tolist()\n",
        "    contributions = top_contributors['Total Gain/Loss $'].tolist()\n",
        "\n",
        "    fig = go.Figure()\n",
        "\n",
        "    fig.add_trace(go.Waterfall(\n",
        "        name=\"Attribution\",\n",
        "        orientation=\"v\",\n",
        "        x=tickers,\n",
        "        y=contributions,\n",
        "        connector={\"line\": {\"color\": COLORS['neon_blue']}},\n",
        "        decreasing={\"marker\": {\"color\": COLORS['danger']}},\n",
        "        increasing={\"marker\": {\"color\": COLORS['success']}},\n",
        "        totals={\"marker\": {\"color\": COLORS['electric_blue']}}\n",
        "    ))\n",
        "\n",
        "    fig.update_layout(\n",
        "        title=\"üíß Holdings Attribution Waterfall\",\n",
        "        xaxis_title=\"Ticker\",\n",
        "        yaxis_title=\"Contribution ($)\",\n",
        "        height=500\n",
        "    )\n",
        "\n",
        "    apply_chart_theme(fig)\n",
        "    return fig\n",
        "\n",
        "def create_concentration_gauge(df):\n",
        "    \"\"\"Concentration gauge - ENHANCED THEMING\"\"\"\n",
        "    top_5_weight = df.nlargest(5, 'Weight %')['Weight %'].sum()\n",
        "\n",
        "    fig = go.Figure(go.Indicator(\n",
        "        mode=\"gauge+number+delta\",\n",
        "        value=top_5_weight,\n",
        "        title={'text': \"Top 5 Concentration\"},\n",
        "        delta={'reference': 50, 'increasing': {'color': COLORS['warning']}},\n",
        "        gauge={\n",
        "            'axis': {'range': [None, 100]},\n",
        "            'bar': {'color': COLORS['neon_blue']},\n",
        "            'steps': [\n",
        "                {'range': [0, 30], 'color': COLORS['success']},\n",
        "                {'range': [30, 50], 'color': COLORS['warning']},\n",
        "                {'range': [50, 100], 'color': COLORS['danger']}\n",
        "            ],\n",
        "            'threshold': {\n",
        "                'line': {'color': \"red\", 'width': 4},\n",
        "                'thickness': 0.75,\n",
        "                'value': 70\n",
        "            }\n",
        "        }\n",
        "    ))\n",
        "\n",
        "    fig.update_layout(height=400)\n",
        "    apply_chart_theme(fig)\n",
        "    return fig\n",
        "\n",
        "def create_concentration_analysis(df):\n",
        "    \"\"\"NEW: Enhanced concentration analysis with multiple visuals\"\"\"\n",
        "\n",
        "    # Top 10 Holdings Bar Chart\n",
        "    top_10 = df.nlargest(10, 'Weight %')\n",
        "\n",
        "    fig = go.Figure()\n",
        "\n",
        "    fig.add_trace(go.Bar(\n",
        "        x=top_10['Weight %'],\n",
        "        y=top_10['Ticker'],\n",
        "        orientation='h',\n",
        "        marker=dict(\n",
        "            color=top_10['Weight %'],\n",
        "            colorscale='Blues',\n",
        "            line=dict(color=COLORS['border'], width=2)\n",
        "        ),\n",
        "        text=[f\"{x:.1f}%\" for x in top_10['Weight %']],\n",
        "        textposition='auto'\n",
        "    ))\n",
        "\n",
        "    fig.update_layout(\n",
        "        title=\"üìä Top 10 Holdings Concentration\",\n",
        "        xaxis_title=\"Weight (%)\",\n",
        "        yaxis_title=\"\",\n",
        "        height=500,\n",
        "        showlegend=False\n",
        "    )\n",
        "\n",
        "    apply_chart_theme(fig)\n",
        "    return fig\n",
        "\n",
        "# ============================================================================\n",
        "# MULTI-FACTOR ANALYSIS - ENHANCED\n",
        "# ============================================================================\n",
        "\n",
        "def create_factor_momentum_chart(factor_data):\n",
        "    \"\"\"Factor momentum chart - ENHANCED THEMING\"\"\"\n",
        "    if factor_data is None or 'factor_returns' not in factor_data:\n",
        "        return None\n",
        "\n",
        "    factor_returns = factor_data['factor_returns']\n",
        "\n",
        "    fig = go.Figure()\n",
        "\n",
        "    colors = [COLORS['neon_blue'], COLORS['electric_blue'], COLORS['teal'],\n",
        "              COLORS['success'], COLORS['purple'], COLORS['pink']]\n",
        "\n",
        "    for idx, factor in enumerate(FACTOR_DEFINITIONS.keys()):\n",
        "        if factor in factor_returns.columns:\n",
        "            cumulative = (1 + factor_returns[factor]).cumprod() - 1\n",
        "            fig.add_trace(go.Scatter(\n",
        "                x=cumulative.index,\n",
        "                y=cumulative.values * 100,\n",
        "                mode='lines',\n",
        "                name=factor,\n",
        "                line=dict(width=2, color=colors[idx % len(colors)])\n",
        "            ))\n",
        "\n",
        "    fig.update_layout(\n",
        "        title=\"üìà Factor Momentum\",\n",
        "        xaxis_title=\"Date\",\n",
        "        yaxis_title=\"Cumulative Return (%)\",\n",
        "        height=600,\n",
        "        hovermode='x unified',\n",
        "        legend=dict(x=0.02, y=0.98)\n",
        "    )\n",
        "\n",
        "    apply_chart_theme(fig)\n",
        "    return fig\n",
        "\n",
        "def create_factor_exposure_radar(exposures):\n",
        "    \"\"\"Factor exposure radar - ENHANCED THEMING\"\"\"\n",
        "    if exposures is None or 'exposures' not in exposures:\n",
        "        return None\n",
        "\n",
        "    exp = exposures['exposures']\n",
        "    factors = [f for f in FACTOR_DEFINITIONS.keys() if f in exp.index]\n",
        "    values = [exp[f] for f in factors]\n",
        "\n",
        "    max_abs = max([abs(v) for v in values]) if values else 1\n",
        "    normalized = [(v / max_abs) * 100 if max_abs > 0 else 0 for v in values]\n",
        "\n",
        "    fig = go.Figure()\n",
        "\n",
        "    fig.add_trace(go.Scatterpolar(\n",
        "        r=normalized,\n",
        "        theta=factors,\n",
        "        fill='toself',\n",
        "        fillcolor='rgba(0, 212, 255, 0.2)',\n",
        "        line=dict(color=COLORS['neon_blue'], width=2),\n",
        "        name='Factor Exposure'\n",
        "    ))\n",
        "\n",
        "    fig.update_layout(\n",
        "        polar=dict(\n",
        "            radialaxis=dict(\n",
        "                visible=True,\n",
        "                range=[0, 100],\n",
        "                color=COLORS['text_secondary']\n",
        "            ),\n",
        "            bgcolor='rgba(10, 25, 41, 0.3)'\n",
        "        ),\n",
        "        title=\"üéØ Factor Exposure Radar\",\n",
        "        height=550\n",
        "    )\n",
        "\n",
        "    apply_chart_theme(fig)\n",
        "    return fig\n",
        "\n",
        "@st.cache_data(ttl=3600)\n",
        "def calculate_factor_exposures(df, start_date, end_date):\n",
        "    try:\n",
        "        portfolio_returns = calculate_portfolio_returns(df, start_date, end_date)\n",
        "        if not is_valid_series(portfolio_returns):\n",
        "            return None\n",
        "\n",
        "        factor_returns = {}\n",
        "        for factor_name, factor_info in FACTOR_DEFINITIONS.items():\n",
        "            benchmark = factor_info['benchmark']\n",
        "            returns = calculate_benchmark_returns(benchmark, start_date, end_date)\n",
        "            if is_valid_series(returns):\n",
        "                factor_returns[factor_name] = returns\n",
        "\n",
        "        if not factor_returns:\n",
        "            return None\n",
        "\n",
        "        common_dates = portfolio_returns.index\n",
        "        for factor_name in factor_returns:\n",
        "            common_dates = common_dates.intersection(factor_returns[factor_name].index)\n",
        "\n",
        "        X = pd.DataFrame({name: returns.loc[common_dates] for name, returns in factor_returns.items()})\n",
        "        y = portfolio_returns.loc[common_dates]\n",
        "\n",
        "        X['Alpha'] = 1\n",
        "\n",
        "        model = LinearRegression()\n",
        "        model.fit(X, y)\n",
        "\n",
        "        exposures = pd.Series(model.coef_, index=X.columns)\n",
        "        r_squared = model.score(X, y)\n",
        "        predicted_returns = model.predict(X)\n",
        "\n",
        "        asset_exposures = {}\n",
        "        for _, row in df.iterrows():\n",
        "            ticker = row['Ticker']\n",
        "            ticker_returns = calculate_benchmark_returns(ticker, start_date, end_date)\n",
        "            if is_valid_series(ticker_returns):\n",
        "                ticker_aligned = ticker_returns.loc[common_dates]\n",
        "\n",
        "                asset_model = LinearRegression()\n",
        "                asset_model.fit(X, ticker_aligned)\n",
        "\n",
        "                asset_exposures[ticker] = pd.Series(asset_model.coef_, index=X.columns)\n",
        "\n",
        "        return {\n",
        "            'exposures': exposures,\n",
        "            'r_squared': r_squared,\n",
        "            'factor_returns': X,\n",
        "            'portfolio_returns': y,\n",
        "            'predicted_returns': predicted_returns,\n",
        "            'asset_exposures': asset_exposures\n",
        "        }\n",
        "    except:\n",
        "        return None\n",
        "\n",
        "def create_factor_attribution_table(exposures, df):\n",
        "    if exposures is None or 'asset_exposures' not in exposures:\n",
        "        return None, None, None\n",
        "\n",
        "    attribution_data = []\n",
        "\n",
        "    for ticker, asset_exp in exposures['asset_exposures'].items():\n",
        "        asset_row = df[df['Ticker'] == ticker]\n",
        "        if asset_row.empty:\n",
        "            continue\n",
        "\n",
        "        weight = asset_row['Weight %'].values[0] / 100\n",
        "        sector = asset_row['Sector'].values[0]\n",
        "\n",
        "        for factor in FACTOR_DEFINITIONS.keys():\n",
        "            if factor in asset_exp:\n",
        "                contribution = weight * asset_exp[factor]\n",
        "                attribution_data.append({\n",
        "                    'Ticker': ticker,\n",
        "                    'Sector': sector,\n",
        "                    'Factor': factor,\n",
        "                    'Weight': weight * 100,\n",
        "                    'Factor Beta': asset_exp[factor],\n",
        "                    'Contribution': contribution\n",
        "                })\n",
        "\n",
        "    if not attribution_data:\n",
        "        return None, None, None\n",
        "\n",
        "    attr_df = pd.DataFrame(attribution_data)\n",
        "\n",
        "    factor_summary = attr_df.groupby('Factor').agg({\n",
        "        'Contribution': 'sum'\n",
        "    }).reset_index()\n",
        "    factor_summary.columns = ['Factor', 'Total Contribution']\n",
        "\n",
        "    sector_summary = attr_df.groupby(['Sector', 'Factor']).agg({\n",
        "        'Contribution': 'sum'\n",
        "    }).reset_index()\n",
        "\n",
        "    return attr_df, factor_summary, sector_summary\n",
        "\n",
        "# ============================================================================\n",
        "# PERFORMANCE METRICS\n",
        "# ============================================================================\n",
        "\n",
        "def calculate_performance_metrics(df, portfolio_returns, benchmark_returns):\n",
        "    if not is_valid_series(portfolio_returns):\n",
        "        return None\n",
        "\n",
        "    total_return = (1 + portfolio_returns).prod() - 1\n",
        "    n_years = len(portfolio_returns) / 252\n",
        "    annualized_return = (1 + total_return) ** (1/n_years) - 1 if n_years > 0 else 0\n",
        "    annualized_vol = portfolio_returns.std() * np.sqrt(252)\n",
        "\n",
        "    sharpe = calculate_sharpe_ratio(portfolio_returns)\n",
        "    sortino = calculate_sortino_ratio(portfolio_returns)\n",
        "    calmar = calculate_calmar_ratio(portfolio_returns)\n",
        "\n",
        "    info_ratio = calculate_information_ratio(portfolio_returns, benchmark_returns)\n",
        "\n",
        "    var_95 = calculate_var(portfolio_returns, 0.95)\n",
        "    cvar_95 = calculate_cvar(portfolio_returns, 0.95)\n",
        "    max_dd = calculate_max_drawdown(portfolio_returns)\n",
        "\n",
        "    winning_days = (portfolio_returns > 0).sum()\n",
        "    losing_days = (portfolio_returns < 0).sum()\n",
        "    win_rate = winning_days / (winning_days + losing_days) * 100 if (winning_days + losing_days) > 0 else 0\n",
        "\n",
        "    avg_win = portfolio_returns[portfolio_returns > 0].mean() * 100 if winning_days > 0 else 0\n",
        "    avg_loss = portfolio_returns[portfolio_returns < 0].mean() * 100 if losing_days > 0 else 0\n",
        "\n",
        "    best_day = portfolio_returns.max() * 100\n",
        "    worst_day = portfolio_returns.min() * 100\n",
        "\n",
        "    return {\n",
        "        'Total Return': total_return * 100,\n",
        "        'Annualized Return': annualized_return * 100,\n",
        "        'Annualized Volatility': annualized_vol * 100,\n",
        "        'Sharpe Ratio': sharpe,\n",
        "        'Sortino Ratio': sortino,\n",
        "        'Calmar Ratio': calmar,\n",
        "        'Information Ratio': info_ratio,\n",
        "        'VaR (95%)': var_95,\n",
        "        'CVaR (95%)': cvar_95,\n",
        "        'Max Drawdown': max_dd,\n",
        "        'Win Rate': win_rate,\n",
        "        'Avg Win': avg_win,\n",
        "        'Avg Loss': avg_loss,\n",
        "        'Best Day': best_day,\n",
        "        'Worst Day': worst_day,\n",
        "        'Winning Days': winning_days,\n",
        "        'Losing Days': losing_days\n",
        "    }\n",
        "\n",
        "def create_performance_dashboard(metrics):\n",
        "    fig = make_subplots(\n",
        "        rows=2, cols=2,\n",
        "        subplot_titles=('Returns Distribution', 'Risk Metrics',\n",
        "                       'Win/Loss Analysis', 'Risk-Adjusted Returns'),\n",
        "        specs=[[{'type': 'bar'}, {'type': 'scatter'}],\n",
        "               [{'type': 'pie'}, {'type': 'bar'}]]\n",
        "    )\n",
        "\n",
        "    fig.add_trace(\n",
        "        go.Bar(x=['Total', 'Annualized'],\n",
        "               y=[metrics['Total Return'], metrics['Annualized Return']],\n",
        "               marker_color=[COLORS['success'], COLORS['electric_blue']]),\n",
        "        row=1, col=1\n",
        "    )\n",
        "\n",
        "    fig.add_trace(\n",
        "        go.Scatter(x=['Volatility', 'VaR', 'CVaR', 'Max DD'],\n",
        "                  y=[metrics['Annualized Volatility'], abs(metrics['VaR (95%)']),\n",
        "                     abs(metrics['CVaR (95%)']), abs(metrics['Max Drawdown'])],\n",
        "                  mode='markers+lines',\n",
        "                  marker=dict(size=15, color=COLORS['danger'])),\n",
        "        row=1, col=2\n",
        "    )\n",
        "\n",
        "    fig.add_trace(\n",
        "        go.Pie(labels=['Winning Days', 'Losing Days'],\n",
        "               values=[metrics['Winning Days'], metrics['Losing Days']],\n",
        "               marker=dict(colors=[COLORS['success'], COLORS['danger']])),\n",
        "        row=2, col=1\n",
        "    )\n",
        "\n",
        "    fig.add_trace(\n",
        "        go.Bar(x=['Sharpe', 'Sortino', 'Calmar', 'Info'],\n",
        "               y=[metrics['Sharpe Ratio'], metrics['Sortino Ratio'],\n",
        "                  metrics['Calmar Ratio'], metrics['Information Ratio']],\n",
        "               marker_color=COLORS['purple']),\n",
        "        row=2, col=2\n",
        "    )\n",
        "\n",
        "    fig.update_layout(\n",
        "        height=700,\n",
        "        showlegend=False,\n",
        "        title_text=\"üìä Performance Dashboard\"\n",
        "    )\n",
        "\n",
        "    apply_chart_theme(fig)\n",
        "    return fig\n",
        "\n",
        "# ============================================================================\n",
        "# VALUATION HOUSE VISUALIZATIONS - ENHANCED\n",
        "# ============================================================================\n",
        "\n",
        "def create_dcf_waterfall(dcf_results, method='FCFF'):\n",
        "    \"\"\"Create waterfall chart showing DCF buildup - ENHANCED THEMING\"\"\"\n",
        "\n",
        "    categories = ['PV of Cash Flows', 'PV of Terminal Value']\n",
        "    values = [dcf_results['total_pv_cash_flows'], dcf_results['pv_terminal']]\n",
        "\n",
        "    if method == 'FCFF':\n",
        "        categories.append('Enterprise Value')\n",
        "        categories.append('Less: Net Debt')\n",
        "        categories.append('Equity Value')\n",
        "        values.append(dcf_results['enterprise_value'])\n",
        "        values.append(-dcf_results.get('net_debt', 0))\n",
        "        values.append(dcf_results['equity_value'])\n",
        "\n",
        "    fig = go.Figure(go.Waterfall(\n",
        "        name=\"DCF Buildup\",\n",
        "        orientation=\"v\",\n",
        "        x=categories,\n",
        "        y=values,\n",
        "        connector={\"line\": {\"color\": COLORS['neon_blue']}},\n",
        "        decreasing={\"marker\": {\"color\": COLORS['danger']}},\n",
        "        increasing={\"marker\": {\"color\": COLORS['success']}},\n",
        "    ))\n",
        "\n",
        "    fig.update_layout(\n",
        "        title=f\"üíé {method} Valuation Buildup\",\n",
        "        yaxis_title=\"Value ($)\",\n",
        "        height=500\n",
        "    )\n",
        "\n",
        "    apply_chart_theme(fig)\n",
        "    return fig\n",
        "\n",
        "def create_cash_flow_chart(projections, method='FCFF'):\n",
        "    \"\"\"Create bar chart of projected cash flows - ENHANCED THEMING\"\"\"\n",
        "\n",
        "    cf_key = 'fcff' if method == 'FCFF' else 'fcfe'\n",
        "\n",
        "    years = [proj['year'] for proj in projections]\n",
        "    cash_flows = [proj[cf_key] for proj in projections]\n",
        "\n",
        "    fig = go.Figure()\n",
        "\n",
        "    fig.add_trace(go.Bar(\n",
        "        x=years,\n",
        "        y=cash_flows,\n",
        "        marker_color=COLORS['electric_blue'],\n",
        "        name=method,\n",
        "        marker=dict(line=dict(color=COLORS['border'], width=2))\n",
        "    ))\n",
        "\n",
        "    fig.update_layout(\n",
        "        title=f\"üìä Projected {method} by Year\",\n",
        "        xaxis_title=\"Year\",\n",
        "        yaxis_title=f\"{method} ($)\",\n",
        "        height=400\n",
        "    )\n",
        "\n",
        "    apply_chart_theme(fig)\n",
        "    return fig\n",
        "\n",
        "def create_sensitivity_table(base_price, base_discount, base_terminal):\n",
        "    \"\"\"Create sensitivity analysis table - ENHANCED THEMING\"\"\"\n",
        "\n",
        "    discount_rates = np.linspace(base_discount - 0.02, base_discount + 0.02, 5)\n",
        "    terminal_growth_rates = np.linspace(base_terminal - 0.01, base_terminal + 0.01, 5)\n",
        "\n",
        "    # This is simplified - in real implementation would recalculate DCF\n",
        "    sensitivity_matrix = []\n",
        "    for tr in terminal_growth_rates:\n",
        "        row = []\n",
        "        for dr in discount_rates:\n",
        "            # Simplified sensitivity calculation\n",
        "            adjustment = (1 - (dr - base_discount)) * (1 + (tr - base_terminal))\n",
        "            value = base_price * adjustment\n",
        "            row.append(value)\n",
        "        sensitivity_matrix.append(row)\n",
        "\n",
        "    fig = go.Figure(data=go.Heatmap(\n",
        "        z=sensitivity_matrix,\n",
        "        x=[f\"{dr:.1%}\" for dr in discount_rates],\n",
        "        y=[f\"{tg:.1%}\" for tg in terminal_growth_rates],\n",
        "        colorscale='RdYlGn',\n",
        "        text=[[f\"${v:.2f}\" for v in row] for row in sensitivity_matrix],\n",
        "        texttemplate='%{text}',\n",
        "        textfont={\"size\": 10},\n",
        "        colorbar=dict(title=\"Price\")\n",
        "    ))\n",
        "\n",
        "    fig.update_layout(\n",
        "        title=\"üéØ Sensitivity Analysis\",\n",
        "        xaxis_title=\"Discount Rate\",\n",
        "        yaxis_title=\"Terminal Growth Rate\",\n",
        "        height=400\n",
        "    )\n",
        "\n",
        "    apply_chart_theme(fig)\n",
        "    return fig\n",
        "\n",
        "# ============================================================================\n",
        "# MAIN APP - EXCELLENCE EDITION\n",
        "# ============================================================================\n",
        "\n",
        "def main():\n",
        "    st.markdown(\"<h1>üî• ATLAS TERMINAL v9.3 EXCELLENCE</h1>\", unsafe_allow_html=True)\n",
        "    st.markdown(\"<p style='text-align: center; color: #00d4ff; font-size: 18px;'>Complete Portfolio Analytics + Valuation House üíé</p>\", unsafe_allow_html=True)\n",
        "\n",
        "    leverage_info = get_leverage_info()\n",
        "    if leverage_info:\n",
        "        st.markdown(f\"\"\"\n",
        "        <div style=\"background: linear-gradient(135deg, #ff6b00 0%, #ff0044 100%);\n",
        "                    border: 2px solid #ff6b00; border-radius: 8px; padding: 10px; margin-bottom: 10px;\n",
        "                    text-align: center;\">\n",
        "            <span style=\"color: white; font-weight: 600;\">‚ö° LEVERAGED ACCOUNT ‚ö°</span>\n",
        "            <span style=\"color: white; margin-left: 20px;\">Margin: ${leverage_info['margin_used']:,.2f}</span>\n",
        "            <span style=\"color: white; margin-left: 20px;\">Leverage: {leverage_info['leverage_ratio']:.2f}x</span>\n",
        "        </div>\n",
        "        \"\"\", unsafe_allow_html=True)\n",
        "\n",
        "    st.sidebar.markdown(\"## üéõÔ∏è NAVIGATION\")\n",
        "    page = st.sidebar.radio(\"Select Module\", [\n",
        "        \"üî• Phoenix Parser\",\n",
        "        \"üè† Portfolio Home\",\n",
        "        \"üåç Market Watch\",\n",
        "        \"üìà Risk Analysis\",\n",
        "        \"üíé Performance Suite\",\n",
        "        \"üî¨ Portfolio Deep Dive\",\n",
        "        \"üìä Multi-Factor Analysis\",\n",
        "        \"üí∞ Valuation House\",\n",
        "        \"‚ÑπÔ∏è About\"\n",
        "    ])\n",
        "\n",
        "    st.sidebar.markdown(\"---\")\n",
        "    st.sidebar.markdown(\"### üìÖ TIME RANGE\")\n",
        "    date_options = [\"1D\", \"1W\", \"1M\", \"3M\", \"6M\", \"YTD\", \"1Y\", \"3Y\", \"5Y\", \"MAX\"]\n",
        "    selected_range = st.sidebar.selectbox(\"Period\", date_options, index=6)\n",
        "\n",
        "    st.sidebar.markdown(\"---\")\n",
        "    st.sidebar.markdown(\"### üéØ BENCHMARK\")\n",
        "    benchmark_options = [\"SPY\", \"QQQ\", \"DIA\", \"IWM\", \"VTI\", \"ACWI\"]\n",
        "    selected_benchmark = st.sidebar.selectbox(\"Compare Against\", benchmark_options, index=0)\n",
        "\n",
        "    if selected_range == \"YTD\":\n",
        "        start_date = datetime(datetime.now().year, 1, 1)\n",
        "        end_date = datetime.now()\n",
        "    elif selected_range == \"MAX\":\n",
        "        start_date = datetime(2000, 1, 1)\n",
        "        end_date = datetime.now()\n",
        "    else:\n",
        "        days_map = {\"1D\": 1, \"1W\": 7, \"1M\": 30, \"3M\": 90, \"6M\": 180, \"1Y\": 365, \"3Y\": 1095, \"5Y\": 1825}\n",
        "        days = days_map.get(selected_range, 365)\n",
        "        end_date = datetime.now()\n",
        "        start_date = end_date - timedelta(days=days)\n",
        "\n",
        "    # ========================================================================\n",
        "    # PHOENIX PARSER\n",
        "    # ========================================================================\n",
        "    if page == \"üî• Phoenix Parser\":\n",
        "        st.markdown(\"## üî• PHOENIX MODE\")\n",
        "\n",
        "        col1, col2 = st.columns(2)\n",
        "\n",
        "        with col1:\n",
        "            st.markdown(\"### üìä Trade History\")\n",
        "            trade_file = st.file_uploader(\"Upload Trade History\", type=['xls', 'xlsx'], key=\"trade\")\n",
        "\n",
        "            if trade_file:\n",
        "                with st.spinner(\"Parsing...\"):\n",
        "                    trade_df = parse_trade_history_file(trade_file)\n",
        "\n",
        "                    if trade_df is not None:\n",
        "                        save_trade_history(trade_df)\n",
        "                        st.success(f\"‚úÖ Parsed {len(trade_df)} trades!\")\n",
        "                        st.dataframe(trade_df.head(10), use_container_width=True)\n",
        "\n",
        "                        portfolio_df = calculate_portfolio_from_trades(trade_df)\n",
        "                        if len(portfolio_df) > 0:\n",
        "                            save_portfolio_data(portfolio_df.to_dict('records'))\n",
        "                            st.success(f\"üéâ Portfolio rebuilt! {len(portfolio_df)} positions\")\n",
        "                            st.dataframe(portfolio_df, use_container_width=True)\n",
        "\n",
        "        with col2:\n",
        "            st.markdown(\"### üí∞ Account History\")\n",
        "            account_file = st.file_uploader(\"Upload Account History\", type=['xls', 'xlsx'], key=\"account\")\n",
        "\n",
        "            if account_file:\n",
        "                with st.spinner(\"Parsing...\"):\n",
        "                    account_df = parse_account_history_file(account_file)\n",
        "\n",
        "                    if account_df is not None:\n",
        "                        save_account_history(account_df)\n",
        "                        st.success(f\"‚úÖ Parsed {len(account_df)} records!\")\n",
        "                        st.dataframe(account_df.head(10), use_container_width=True)\n",
        "\n",
        "                        leverage_info_parsed = get_leverage_info()\n",
        "                        if leverage_info_parsed:\n",
        "                            st.info(f\"\"\"\n",
        "                            üí° Leverage Detected:\n",
        "                            - Margin: ${leverage_info_parsed['margin_used']:,.2f}\n",
        "                            - Leverage: {leverage_info_parsed['leverage_ratio']:.2f}x\n",
        "                            \"\"\")\n",
        "\n",
        "    # ========================================================================\n",
        "    # PORTFOLIO HOME - ENHANCED WITH CONTRIBUTORS/DETRACTORS\n",
        "    # ========================================================================\n",
        "    elif page == \"üè† Portfolio Home\":\n",
        "        st.markdown(\"## üè† PORTFOLIO HOME\")\n",
        "\n",
        "        portfolio_data = load_portfolio_data()\n",
        "\n",
        "        if not portfolio_data:\n",
        "            st.warning(\"‚ö†Ô∏è No portfolio data. Please upload via Phoenix Parser.\")\n",
        "            return\n",
        "\n",
        "        df = pd.DataFrame(portfolio_data)\n",
        "\n",
        "        with st.spinner(\"Loading...\"):\n",
        "            enhanced_df = create_enhanced_holdings_table(df)\n",
        "\n",
        "        total_value = enhanced_df['Total Value'].sum()\n",
        "        total_cost = enhanced_df['Total Cost'].sum()\n",
        "        total_gl = total_value - total_cost\n",
        "        total_gl_pct = (total_gl / total_cost) * 100 if total_cost > 0 else 0\n",
        "        daily_pl = enhanced_df['Daily P&L $'].sum()\n",
        "\n",
        "        col1, col2, col3, col4, col5 = st.columns(5)\n",
        "        col1.metric(\"Total Value\", format_currency(total_value))\n",
        "        col2.metric(\"Total Cost\", format_currency(total_cost))\n",
        "        col3.metric(\"Total G/L\", format_currency(total_gl), format_percentage(total_gl_pct))\n",
        "        col4.metric(\"Daily P&L\", format_currency(daily_pl))\n",
        "        col5.metric(\"Positions\", len(enhanced_df))\n",
        "\n",
        "        st.markdown(\"---\")\n",
        "        st.markdown(\"### üìã Holdings\")\n",
        "        display_df = style_holdings_dataframe(enhanced_df)\n",
        "        st.dataframe(display_df, use_container_width=True, hide_index=True, height=500)\n",
        "\n",
        "        st.info(\"üí° **Tip:** Head to the Valuation House to analyze intrinsic values of any ticker!\")\n",
        "\n",
        "        st.markdown(\"---\")\n",
        "        st.markdown(\"### üìä DASHBOARD OVERVIEW\")\n",
        "\n",
        "        # ENHANCED: Better layout with 2 rows\n",
        "        row1_col1, row1_col2 = st.columns([2, 1])\n",
        "\n",
        "        with row1_col1:\n",
        "            risk_reward = create_risk_reward_plot(enhanced_df)\n",
        "            if risk_reward:\n",
        "                st.plotly_chart(risk_reward, use_container_width=True)\n",
        "\n",
        "        with row1_col2:\n",
        "            sector_donut = create_sector_allocation_donut(enhanced_df)\n",
        "            if sector_donut:\n",
        "                st.plotly_chart(sector_donut, use_container_width=True)\n",
        "\n",
        "        # NEW: Second row with Contributors and Detractors\n",
        "        row2_col1, row2_col2 = st.columns(2)\n",
        "\n",
        "        with row2_col1:\n",
        "            contributors = create_top_contributors_chart(enhanced_df)\n",
        "            if contributors:\n",
        "                st.plotly_chart(contributors, use_container_width=True)\n",
        "\n",
        "        with row2_col2:\n",
        "            detractors = create_top_detractors_chart(enhanced_df)\n",
        "            if detractors:\n",
        "                st.plotly_chart(detractors, use_container_width=True)\n",
        "\n",
        "        # Performance Heatmap (full width)\n",
        "        st.markdown(\"---\")\n",
        "        perf_heatmap = create_performance_heatmap(enhanced_df)\n",
        "        if perf_heatmap:\n",
        "            st.plotly_chart(perf_heatmap, use_container_width=True)\n",
        "\n",
        "    # ========================================================================\n",
        "    # MARKET WATCH - COMPLETE REVAMP\n",
        "    # ========================================================================\n",
        "    elif page == \"üåç Market Watch\":\n",
        "        st.markdown(\"## üåç MARKET WATCH - EXCELLENCE EDITION\")\n",
        "        st.markdown(\"*Your comprehensive window into global markets, crypto, bonds, and credit conditions*\")\n",
        "\n",
        "        st.markdown(\"---\")\n",
        "        st.markdown(\"### üîç Filters & Settings\")\n",
        "        col1, col2, col3, col4 = st.columns(4)\n",
        "\n",
        "        with col1:\n",
        "            filter_change = st.slider(\"Min Change %\", -10.0, 10.0, -10.0)\n",
        "        with col2:\n",
        "            sort_by = st.selectbox(\"Sort By\", [\"Change %\", \"5D %\", \"Volume\"])\n",
        "        with col3:\n",
        "            refresh = st.button(\"üîÑ Refresh Data\")\n",
        "        with col4:\n",
        "            auto_refresh = st.checkbox(\"Auto-Refresh (5min)\")\n",
        "\n",
        "        st.markdown(\"---\")\n",
        "\n",
        "        # EXPANDED TABS\n",
        "        tab1, tab2, tab3, tab4, tab5, tab6, tab7 = st.tabs([\n",
        "            \"üìà Indices\",\n",
        "            \"üí∞ Crypto\",\n",
        "            \"üè¶ ETFs\",\n",
        "            \"‚ö° Commodities\",\n",
        "            \"üìä Stocks\",\n",
        "            \"üíµ Bonds & Rates\",\n",
        "            \"üéØ Credit Spreads\"\n",
        "        ])\n",
        "\n",
        "        with tab1:\n",
        "            st.markdown(\"#### üåç Global Indices\")\n",
        "            with st.spinner(\"Loading indices...\"):\n",
        "                indices_df = fetch_market_watch_data(GLOBAL_INDICES)\n",
        "                if not indices_df.empty:\n",
        "                    indices_df = indices_df[indices_df['Change %'] >= filter_change]\n",
        "                    display_df = create_dynamic_market_table(indices_df, {'sort_by': sort_by, 'ascending': False})\n",
        "                    st.dataframe(display_df, use_container_width=True, hide_index=True, height=600)\n",
        "                else:\n",
        "                    st.warning(\"No data available\")\n",
        "\n",
        "        with tab2:\n",
        "            st.markdown(\"#### ü™ô Cryptocurrency Markets\")\n",
        "            with st.spinner(\"Loading crypto...\"):\n",
        "                crypto_df = fetch_market_watch_data(CRYPTOCURRENCIES)\n",
        "                if not crypto_df.empty:\n",
        "                    crypto_df = crypto_df[crypto_df['Change %'] >= filter_change]\n",
        "                    display_df = create_dynamic_market_table(crypto_df, {'sort_by': sort_by, 'ascending': False})\n",
        "                    st.dataframe(display_df, use_container_width=True, hide_index=True, height=600)\n",
        "                else:\n",
        "                    st.warning(\"No data available\")\n",
        "\n",
        "        with tab3:\n",
        "            st.markdown(\"#### üì¶ Exchange-Traded Funds\")\n",
        "            sectors = st.multiselect(\"Filter by Category\",\n",
        "                                     [\"Broad Market\", \"Sector\", \"Thematic\", \"International\"],\n",
        "                                     default=[\"Broad Market\", \"Sector\", \"Thematic\"])\n",
        "\n",
        "            with st.spinner(\"Loading ETFs...\"):\n",
        "                etf_df = fetch_market_watch_data(POPULAR_ETFS)\n",
        "                if not etf_df.empty:\n",
        "                    if sectors:\n",
        "                        etf_df = etf_df[etf_df['Category'].isin(sectors)]\n",
        "                    display_df = create_dynamic_market_table(etf_df, {'sort_by': sort_by, 'ascending': False})\n",
        "                    st.dataframe(display_df, use_container_width=True, hide_index=True, height=600)\n",
        "                else:\n",
        "                    st.warning(\"No data available\")\n",
        "\n",
        "        with tab4:\n",
        "            st.markdown(\"#### ‚õΩ Commodity Markets\")\n",
        "            commodity_cats = st.multiselect(\"Filter by Type\",\n",
        "                                           [\"Precious Metals\", \"Energy\", \"Industrial Metals\", \"Agriculture\", \"Livestock\"],\n",
        "                                           default=[\"Precious Metals\", \"Energy\"])\n",
        "\n",
        "            with st.spinner(\"Loading commodities...\"):\n",
        "                comm_df = fetch_market_watch_data(COMMODITIES)\n",
        "                if not comm_df.empty:\n",
        "                    if commodity_cats:\n",
        "                        comm_df = comm_df[comm_df['Category'].isin(commodity_cats)]\n",
        "                    display_df = create_dynamic_market_table(comm_df, {'sort_by': sort_by, 'ascending': False})\n",
        "                    st.dataframe(display_df, use_container_width=True, hide_index=True, height=600)\n",
        "                else:\n",
        "                    st.warning(\"No data available\")\n",
        "\n",
        "        with tab5:\n",
        "            st.markdown(\"#### üìà Popular Stocks\")\n",
        "            stock_sectors = st.multiselect(\"Filter by Category\",\n",
        "                                          [\"Mega Cap Tech\", \"Financials\", \"Healthcare\", \"Consumer\", \"Energy\"],\n",
        "                                          default=[\"Mega Cap Tech\", \"Financials\"])\n",
        "\n",
        "            with st.spinner(\"Loading stocks...\"):\n",
        "                stocks_df = fetch_market_watch_data(POPULAR_STOCKS)\n",
        "                if not stocks_df.empty:\n",
        "                    if stock_sectors:\n",
        "                        stocks_df = stocks_df[stocks_df['Category'].isin(stock_sectors)]\n",
        "                    display_df = create_dynamic_market_table(stocks_df, {'sort_by': sort_by, 'ascending': False})\n",
        "                    st.dataframe(display_df, use_container_width=True, hide_index=True, height=600)\n",
        "                else:\n",
        "                    st.warning(\"No data available\")\n",
        "\n",
        "        with tab6:\n",
        "            st.markdown(\"#### üíµ Bond Yields & Treasury Rates\")\n",
        "            st.info(\"üìä **Key Insight:** Monitor the yield curve for recession signals and inflation expectations\")\n",
        "\n",
        "            with st.spinner(\"Loading bonds...\"):\n",
        "                bonds_df = fetch_market_watch_data(BOND_YIELDS)\n",
        "                if not bonds_df.empty:\n",
        "                    display_df = create_dynamic_market_table(bonds_df, {'sort_by': sort_by, 'ascending': False})\n",
        "                    st.dataframe(display_df, use_container_width=True, hide_index=True, height=400)\n",
        "                else:\n",
        "                    st.warning(\"No data available\")\n",
        "\n",
        "        with tab7:\n",
        "            st.markdown(\"#### üéØ Credit Spreads & Conditions\")\n",
        "            st.info(\"üí° **Key Insight:** Widening spreads signal deteriorating credit conditions and rising risk premiums\")\n",
        "\n",
        "            with st.spinner(\"Loading credit spreads...\"):\n",
        "                credit_df = fetch_market_watch_data(CREDIT_SPREADS)\n",
        "                if not credit_df.empty:\n",
        "                    display_df = create_dynamic_market_table(credit_df, {'sort_by': sort_by, 'ascending': False})\n",
        "                    st.dataframe(display_df, use_container_width=True, hide_index=True, height=400)\n",
        "\n",
        "                    st.markdown(\"---\")\n",
        "                    st.markdown(\"#### üìä Credit Market Interpretation\")\n",
        "                    st.markdown(\"\"\"\n",
        "                    **Investment Grade (LQD):** Corporate bonds rated BBB- or higher\n",
        "                    **High Yield (HYG):** \"Junk\" bonds with higher risk and return potential\n",
        "                    **Emerging Markets (EMB):** Sovereign and corporate debt from developing economies\n",
        "                    **TIPS (TIP):** Treasury Inflation-Protected Securities\n",
        "                    **MBS (MBB):** Mortgage-Backed Securities\n",
        "                    \"\"\")\n",
        "                else:\n",
        "                    st.warning(\"No data available\")\n",
        "\n",
        "    # Continue with remaining pages in next message...\n",
        "    # (Risk Analysis, Performance Suite, Portfolio Deep Dive, Multi-Factor, Valuation House, About)\n",
        "\n",
        "    # ========================================================================\n",
        "    # RISK ANALYSIS - WORLD CLASS\n",
        "    # ========================================================================\n",
        "    elif page == \"üìà Risk Analysis\":\n",
        "        st.markdown(\"## üìà RISK ANALYSIS - WORLD CLASS\")\n",
        "\n",
        "        portfolio_data = load_portfolio_data()\n",
        "\n",
        "        if not portfolio_data:\n",
        "            st.warning(\"‚ö†Ô∏è No portfolio data.\")\n",
        "            return\n",
        "\n",
        "        df = pd.DataFrame(portfolio_data)\n",
        "        enhanced_df = create_enhanced_holdings_table(df)\n",
        "\n",
        "        with st.spinner(\"Calculating...\"):\n",
        "            portfolio_returns = calculate_portfolio_returns(df, start_date, end_date)\n",
        "            benchmark_returns = calculate_benchmark_returns(selected_benchmark, start_date, end_date)\n",
        "\n",
        "            if not is_valid_series(portfolio_returns):\n",
        "                st.warning(\"Insufficient data\")\n",
        "                return\n",
        "\n",
        "            sharpe = calculate_sharpe_ratio(portfolio_returns)\n",
        "            sortino = calculate_sortino_ratio(portfolio_returns)\n",
        "            calmar = calculate_calmar_ratio(portfolio_returns)\n",
        "            var_95 = calculate_var(portfolio_returns, 0.95)\n",
        "            max_dd = calculate_max_drawdown(portfolio_returns)\n",
        "\n",
        "        col1, col2, col3, col4, col5 = st.columns(5)\n",
        "        col1.metric(\"Sharpe\", f\"{sharpe:.2f}\" if sharpe else \"N/A\")\n",
        "        col2.metric(\"Sortino\", f\"{sortino:.2f}\" if sortino else \"N/A\")\n",
        "        col3.metric(\"Calmar\", f\"{calmar:.2f}\" if calmar else \"N/A\")\n",
        "        col4.metric(\"VaR 95%\", format_percentage(var_95) if var_95 else \"N/A\")\n",
        "        col5.metric(\"Max DD\", format_percentage(max_dd) if max_dd else \"N/A\")\n",
        "\n",
        "        st.markdown(\"---\")\n",
        "\n",
        "        tab1, tab2, tab3, tab4 = st.tabs([\n",
        "            \"üìä Core Risk\", \"üé≤ Monte Carlo\", \"üî¨ Advanced Analytics\", \"‚ö° Stress Tests\"\n",
        "        ])\n",
        "\n",
        "        with tab1:\n",
        "            col1, col2 = st.columns(2)\n",
        "\n",
        "            with col1:\n",
        "                var_chart = create_var_waterfall(portfolio_returns)\n",
        "                if var_chart:\n",
        "                    st.plotly_chart(var_chart, use_container_width=True)\n",
        "\n",
        "                risk_parity = create_risk_parity_analysis(enhanced_df)\n",
        "                if risk_parity:\n",
        "                    st.plotly_chart(risk_parity, use_container_width=True)\n",
        "\n",
        "            with col2:\n",
        "                efficient = create_efficient_frontier(enhanced_df)\n",
        "                if efficient:\n",
        "                    st.plotly_chart(efficient, use_container_width=True)\n",
        "\n",
        "        with tab2:\n",
        "            simulations = run_monte_carlo_simulation(portfolio_returns)\n",
        "            if simulations is not None:\n",
        "                monte_carlo_chart, mc_stats = create_monte_carlo_chart(simulations, 100000)\n",
        "\n",
        "                if monte_carlo_chart:\n",
        "                    st.plotly_chart(monte_carlo_chart, use_container_width=True)\n",
        "\n",
        "                if mc_stats:\n",
        "                    st.markdown(\"#### üìä Simulation Results\")\n",
        "                    st.markdown(f\"\"\"\n",
        "                    **Key Statistics:**\n",
        "                    - Expected Value: ${mc_stats['mean']:,.2f}\n",
        "                    - Median: ${mc_stats['median']:,.2f}\n",
        "                    - Best Case (95th): ${mc_stats['percentile_95']:,.2f}\n",
        "                    - Worst Case (5th): ${mc_stats['percentile_5']:,.2f}\n",
        "                    - Prob of Profit: {mc_stats['prob_profit']:.1f}%\n",
        "                    \"\"\")\n",
        "\n",
        "        with tab3:\n",
        "            col1, col2 = st.columns(2)\n",
        "\n",
        "            with col1:\n",
        "                rolling = create_rolling_metrics_chart(portfolio_returns)\n",
        "                if rolling:\n",
        "                    st.plotly_chart(rolling, use_container_width=True)\n",
        "\n",
        "            with col2:\n",
        "                underwater = create_underwater_plot(portfolio_returns)\n",
        "                if underwater:\n",
        "                    st.plotly_chart(underwater, use_container_width=True)\n",
        "\n",
        "            sunburst = create_risk_contribution_sunburst(enhanced_df)\n",
        "            if sunburst:\n",
        "                st.plotly_chart(sunburst, use_container_width=True)\n",
        "\n",
        "            corr_network = create_correlation_network(enhanced_df, start_date, end_date)\n",
        "            if corr_network:\n",
        "                st.plotly_chart(corr_network, use_container_width=True)\n",
        "\n",
        "        with tab4:\n",
        "            st.info(\"Comprehensive stress testing scenarios...\")\n",
        "\n",
        "    # Continue with remaining pages...\n",
        "    # ========================================================================\n",
        "    # PERFORMANCE SUITE\n",
        "    # ========================================================================\n",
        "    elif page == \"üíé Performance Suite\":\n",
        "        st.markdown(\"## üíé PERFORMANCE SUITE\")\n",
        "\n",
        "        portfolio_data = load_portfolio_data()\n",
        "\n",
        "        if not portfolio_data:\n",
        "            st.warning(\"‚ö†Ô∏è No portfolio data.\")\n",
        "            return\n",
        "\n",
        "        df = pd.DataFrame(portfolio_data)\n",
        "        enhanced_df = create_enhanced_holdings_table(df)\n",
        "\n",
        "        with st.spinner(\"Calculating...\"):\n",
        "            portfolio_returns = calculate_portfolio_returns(df, start_date, end_date)\n",
        "            benchmark_returns = calculate_benchmark_returns(selected_benchmark, start_date, end_date)\n",
        "\n",
        "            metrics = None\n",
        "            if is_valid_series(portfolio_returns):\n",
        "                metrics = calculate_performance_metrics(enhanced_df, portfolio_returns, benchmark_returns)\n",
        "\n",
        "        tab1, tab2, tab3 = st.tabs([\"üìà Interactive Chart\", \"üìä Analytics\", \"üìã Metrics\"])\n",
        "\n",
        "        with tab1:\n",
        "            available_tickers = enhanced_df['Ticker'].tolist()\n",
        "\n",
        "            col1, col2 = st.columns([3, 1])\n",
        "            with col1:\n",
        "                selected_tickers = st.multiselect(\n",
        "                    \"Select Tickers\",\n",
        "                    options=available_tickers + [\"SPY\", \"QQQ\", \"VTI\"],\n",
        "                    default=available_tickers[:min(5, len(available_tickers))]\n",
        "                )\n",
        "\n",
        "            with col2:\n",
        "                custom_ticker = st.text_input(\"Add Custom\", placeholder=\"TSLA\")\n",
        "                if custom_ticker:\n",
        "                    selected_tickers.append(custom_ticker.upper())\n",
        "\n",
        "            if selected_tickers:\n",
        "                perf_chart = create_interactive_performance_chart(selected_tickers, start_date, end_date)\n",
        "                if perf_chart:\n",
        "                    st.plotly_chart(perf_chart, use_container_width=True)\n",
        "\n",
        "        with tab2:\n",
        "            if metrics:\n",
        "                dashboard = create_performance_dashboard(metrics)\n",
        "                st.plotly_chart(dashboard, use_container_width=True)\n",
        "\n",
        "        with tab3:\n",
        "            if metrics:\n",
        "                metrics_df = pd.DataFrame([\n",
        "                    ['Total Return', format_percentage(metrics['Total Return'])],\n",
        "                    ['Annualized Return', format_percentage(metrics['Annualized Return'])],\n",
        "                    ['Volatility', format_percentage(metrics['Annualized Volatility'])],\n",
        "                    ['Sharpe Ratio', f\"{metrics['Sharpe Ratio']:.3f}\"],\n",
        "                    ['Sortino Ratio', f\"{metrics['Sortino Ratio']:.3f}\"],\n",
        "                    ['Calmar Ratio', f\"{metrics['Calmar Ratio']:.3f}\"],\n",
        "                    ['VaR (95%)', format_percentage(metrics['VaR (95%)'])],\n",
        "                    ['Max Drawdown', format_percentage(metrics['Max Drawdown'])],\n",
        "                    ['Win Rate', format_percentage(metrics['Win Rate'])],\n",
        "                    ['Best Day', format_percentage(metrics['Best Day'])],\n",
        "                    ['Worst Day', format_percentage(metrics['Worst Day'])]\n",
        "                ], columns=['Metric', 'Value'])\n",
        "\n",
        "                st.dataframe(metrics_df, use_container_width=True, hide_index=True, height=600)\n",
        "\n",
        "    # ========================================================================\n",
        "    # PORTFOLIO DEEP DIVE - ENHANCED\n",
        "    # ========================================================================\n",
        "    elif page == \"üî¨ Portfolio Deep Dive\":\n",
        "        st.markdown(\"## üî¨ PORTFOLIO DEEP DIVE - ENHANCED\")\n",
        "\n",
        "        portfolio_data = load_portfolio_data()\n",
        "\n",
        "        if not portfolio_data:\n",
        "            st.warning(\"‚ö†Ô∏è No portfolio data.\")\n",
        "            return\n",
        "\n",
        "        df = pd.DataFrame(portfolio_data)\n",
        "        enhanced_df = create_enhanced_holdings_table(df)\n",
        "\n",
        "        tab1, tab2, tab3 = st.tabs([\n",
        "            \"üéØ Attribution\", \"üîÑ Sector Rotation\", \"üìä Concentration\"\n",
        "        ])\n",
        "\n",
        "        with tab1:\n",
        "            col1, col2 = st.columns(2)\n",
        "\n",
        "            with col1:\n",
        "                heatmap = create_portfolio_heatmap(enhanced_df)\n",
        "                if heatmap:\n",
        "                    st.plotly_chart(heatmap, use_container_width=True)\n",
        "\n",
        "            with col2:\n",
        "                waterfall = create_holdings_attribution_waterfall(enhanced_df)\n",
        "                if waterfall:\n",
        "                    st.plotly_chart(waterfall, use_container_width=True)\n",
        "\n",
        "        with tab2:\n",
        "            rotation = create_sector_rotation_heatmap(enhanced_df, start_date, end_date)\n",
        "            if rotation:\n",
        "                st.plotly_chart(rotation, use_container_width=True)\n",
        "\n",
        "        with tab3:\n",
        "            col1, col2 = st.columns([1, 2])\n",
        "\n",
        "            with col1:\n",
        "                gauge = create_concentration_gauge(enhanced_df)\n",
        "                if gauge:\n",
        "                    st.plotly_chart(gauge, use_container_width=True)\n",
        "\n",
        "            with col2:\n",
        "                # ENHANCED: Better concentration visual\n",
        "                conc_analysis = create_concentration_analysis(enhanced_df)\n",
        "                if conc_analysis:\n",
        "                    st.plotly_chart(conc_analysis, use_container_width=True)\n",
        "\n",
        "    # ========================================================================\n",
        "    # MULTI-FACTOR ANALYSIS - ENHANCED\n",
        "    # ========================================================================\n",
        "    elif page == \"üìä Multi-Factor Analysis\":\n",
        "        st.markdown(\"## üìä MULTI-FACTOR ANALYSIS - ENHANCED\")\n",
        "\n",
        "        portfolio_data = load_portfolio_data()\n",
        "\n",
        "        if not portfolio_data:\n",
        "            st.warning(\"‚ö†Ô∏è No portfolio data.\")\n",
        "            return\n",
        "\n",
        "        df = pd.DataFrame(portfolio_data)\n",
        "        enhanced_df = create_enhanced_holdings_table(df)\n",
        "\n",
        "        with st.spinner(\"Running analysis...\"):\n",
        "            factor_data = calculate_factor_exposures(enhanced_df, start_date, end_date)\n",
        "\n",
        "        if factor_data:\n",
        "            st.markdown(f\"**Model R¬≤ = {factor_data['r_squared']:.3f}**\")\n",
        "            st.progress(factor_data['r_squared'])\n",
        "\n",
        "            result = create_factor_attribution_table(factor_data, enhanced_df)\n",
        "\n",
        "            tab1, tab2, tab3 = st.tabs([\n",
        "                \"üìà Factor Momentum\", \"üéØ Exposure Radar\", \"üìä Attribution\"\n",
        "            ])\n",
        "\n",
        "            with tab1:\n",
        "                momentum = create_factor_momentum_chart(factor_data)\n",
        "                if momentum:\n",
        "                    st.plotly_chart(momentum, use_container_width=True)\n",
        "\n",
        "            with tab2:\n",
        "                radar = create_factor_exposure_radar(factor_data)\n",
        "                if radar:\n",
        "                    st.plotly_chart(radar, use_container_width=True)\n",
        "\n",
        "            with tab3:\n",
        "                if result is not None:\n",
        "                    attr_df, factor_summary, sector_summary = result\n",
        "\n",
        "                    if factor_summary is not None:\n",
        "                        st.markdown(\"### Factor Summary\")\n",
        "                        factor_display = factor_summary.copy()\n",
        "                        factor_display['Total Contribution'] = factor_display['Total Contribution'].apply(\n",
        "                            lambda x: f\"{x:.4f}\")\n",
        "                        st.dataframe(factor_display, use_container_width=True, hide_index=True)\n",
        "\n",
        "                    if attr_df is not None:\n",
        "                        st.markdown(\"### Holdings Attribution\")\n",
        "                        holdings_attr = attr_df.pivot_table(\n",
        "                            index='Ticker',\n",
        "                            columns='Factor',\n",
        "                            values='Contribution',\n",
        "                            aggfunc='sum'\n",
        "                        ).round(4)\n",
        "\n",
        "                        st.dataframe(holdings_attr, use_container_width=True)\n",
        "\n",
        "                        st.info(\"\"\"\n",
        "                        **Positive values**: Holding increases exposure\n",
        "                        **Negative values**: Holding decreases exposure\n",
        "                        \"\"\")\n",
        "        else:\n",
        "            st.error(\"Unable to calculate factor exposures.\")\n",
        "\n",
        "    # ========================================================================\n",
        "    # VALUATION HOUSE - ENHANCED WITH SMART ASSUMPTIONS\n",
        "    # ========================================================================\n",
        "    elif page == \"üí∞ Valuation House\":\n",
        "        st.markdown(\"## üí∞ VALUATION HOUSE - EXCELLENCE EDITION\")\n",
        "        st.markdown(\"### Professional DCF Valuation Engine with Smart Assumptions\")\n",
        "\n",
        "        st.info(\"üéØ **New Feature:** Toggle between Manual and Smart Assumptions for realistic valuations!\")\n",
        "\n",
        "        # Company Search\n",
        "        st.markdown(\"---\")\n",
        "        st.markdown(\"#### üîç Company Search\")\n",
        "\n",
        "        col1, col2 = st.columns([3, 1])\n",
        "\n",
        "        with col1:\n",
        "            ticker_input = st.text_input(\n",
        "                \"Enter Ticker Symbol\",\n",
        "                placeholder=\"e.g., AAPL, MSFT, GOOGL\",\n",
        "                help=\"Enter any publicly traded company ticker\"\n",
        "            ).upper()\n",
        "\n",
        "        with col2:\n",
        "            search_button = st.button(\"üöÄ Load Company\", type=\"primary\", use_container_width=True)\n",
        "\n",
        "        if search_button and ticker_input:\n",
        "            with st.spinner(f\"üìä Fetching data for {ticker_input}...\"):\n",
        "                company_data = fetch_company_financials(ticker_input)\n",
        "\n",
        "                if company_data['success']:\n",
        "                    st.session_state['valuation_company'] = company_data\n",
        "                    st.success(f\"‚úÖ Loaded {company_data['company']['name']}\")\n",
        "                else:\n",
        "                    st.error(f\"‚ùå Could not fetch data: {company_data.get('error', 'Unknown error')}\")\n",
        "\n",
        "        # Display valuation if company is loaded\n",
        "        if 'valuation_company' in st.session_state:\n",
        "            company = st.session_state['valuation_company']['company']\n",
        "            financials = st.session_state['valuation_company']['financials']\n",
        "\n",
        "            st.markdown(\"---\")\n",
        "\n",
        "            # Company Overview\n",
        "            st.markdown(f\"### üìä {company['name']} ({company['ticker']})\")\n",
        "\n",
        "            col1, col2, col3, col4, col5 = st.columns(5)\n",
        "            col1.metric(\"Current Price\", format_currency(company['current_price']))\n",
        "            col2.metric(\"Market Cap\", format_large_number(company['market_cap']))\n",
        "            col3.metric(\"Sector\", company['sector'])\n",
        "            col4.metric(\"Beta\", f\"{company['beta']:.2f}\")\n",
        "            col5.metric(\"Forward P/E\", f\"{company.get('forward_pe', 'N/A'):.1f}\" if company.get('forward_pe') else \"N/A\")\n",
        "\n",
        "            st.markdown(\"---\")\n",
        "\n",
        "            # DCF Method Selection\n",
        "            st.markdown(\"#### üéØ Valuation Method\")\n",
        "            dcf_method = st.radio(\n",
        "                \"Select DCF Method\",\n",
        "                options=['FCFF', 'FCFE'],\n",
        "                horizontal=True,\n",
        "                help=\"FCFF: Free Cash Flow to Firm | FCFE: Free Cash Flow to Equity\"\n",
        "            )\n",
        "\n",
        "            st.markdown(\"---\")\n",
        "\n",
        "            # NEW: Smart Assumptions Toggle\n",
        "            st.markdown(\"#### üß† Assumptions Mode\")\n",
        "\n",
        "            use_smart_assumptions = st.checkbox(\n",
        "                \"ü§ñ Use Smart Assumptions (AI-Generated)\",\n",
        "                help=\"Generate realistic assumptions based on sector averages, company size, and economic fundamentals\"\n",
        "            )\n",
        "\n",
        "            if use_smart_assumptions:\n",
        "                st.info(\"ü§ñ **Smart Mode Active:** Assumptions are generated based on sector benchmarks and economic reality\")\n",
        "                smart_params = calculate_smart_assumptions(company, financials)\n",
        "\n",
        "            # Assumptions Panel\n",
        "            st.markdown(\"---\")\n",
        "            st.markdown(\"#### üéõÔ∏è Valuation Assumptions\")\n",
        "\n",
        "            tab1, tab2, tab3 = st.tabs([\"üìà Growth & Operations\", \"üí∞ Cost of Capital\", \"üéØ Terminal Value\"])\n",
        "\n",
        "            with tab1:\n",
        "                st.markdown(\"##### Growth & Operating Assumptions\")\n",
        "\n",
        "                col1, col2 = st.columns(2)\n",
        "\n",
        "                with col1:\n",
        "                    if use_smart_assumptions:\n",
        "                        revenue_growth = smart_params['revenue_growth']\n",
        "                        st.metric(\"Revenue Growth Rate\", f\"{revenue_growth*100:.1f}%\",\n",
        "                                 delta=\"AI Generated\", delta_color=\"normal\")\n",
        "                    else:\n",
        "                        revenue_growth = st.slider(\n",
        "                            \"Revenue Growth Rate (%)\",\n",
        "                            min_value=-10.0,\n",
        "                            max_value=30.0,\n",
        "                            value=5.0,\n",
        "                            step=0.5\n",
        "                        ) / 100\n",
        "\n",
        "                    if use_smart_assumptions:\n",
        "                        ebit_margin = smart_params['ebit_margin']\n",
        "                        st.metric(\"EBIT Margin\", f\"{ebit_margin*100:.1f}%\",\n",
        "                                 delta=\"AI Generated\", delta_color=\"normal\")\n",
        "                    else:\n",
        "                        ebit_margin = st.slider(\n",
        "                            \"EBIT Margin (%)\",\n",
        "                            min_value=0.0,\n",
        "                            max_value=50.0,\n",
        "                            value=20.0,\n",
        "                            step=1.0\n",
        "                        ) / 100\n",
        "\n",
        "                    forecast_years = st.slider(\n",
        "                        \"Forecast Horizon (Years)\",\n",
        "                        min_value=3,\n",
        "                        max_value=15,\n",
        "                        value=smart_params['forecast_years'] if use_smart_assumptions else 5,\n",
        "                        step=1\n",
        "                    )\n",
        "\n",
        "                with col2:\n",
        "                    if use_smart_assumptions:\n",
        "                        capex_pct = smart_params['capex_pct']\n",
        "                        st.metric(\"CapEx (% of Revenue)\", f\"{capex_pct*100:.1f}%\",\n",
        "                                 delta=\"AI Generated\", delta_color=\"normal\")\n",
        "                    else:\n",
        "                        capex_pct = st.slider(\n",
        "                            \"CapEx (% of Revenue)\",\n",
        "                            min_value=0.0,\n",
        "                            max_value=20.0,\n",
        "                            value=5.0,\n",
        "                            step=0.5\n",
        "                        ) / 100\n",
        "\n",
        "                    if use_smart_assumptions:\n",
        "                        depreciation_pct = smart_params['depreciation_pct']\n",
        "                        st.metric(\"Depreciation (% of Revenue)\", f\"{depreciation_pct*100:.1f}%\",\n",
        "                                 delta=\"AI Generated\", delta_color=\"normal\")\n",
        "                    else:\n",
        "                        depreciation_pct = st.slider(\n",
        "                            \"Depreciation (% of Revenue)\",\n",
        "                            min_value=0.0,\n",
        "                            max_value=15.0,\n",
        "                            value=3.0,\n",
        "                            step=0.5\n",
        "                        ) / 100\n",
        "\n",
        "                    wc_change = st.number_input(\n",
        "                        \"Working Capital Change ($M)\",\n",
        "                        min_value=-1000.0,\n",
        "                        max_value=1000.0,\n",
        "                        value=smart_params['wc_change'] if use_smart_assumptions else 0.0,\n",
        "                        step=10.0\n",
        "                    ) * 1e6\n",
        "\n",
        "            with tab2:\n",
        "                st.markdown(\"##### Cost of Capital Assumptions\")\n",
        "\n",
        "                col1, col2 = st.columns(2)\n",
        "\n",
        "                with col1:\n",
        "                    risk_free = st.slider(\n",
        "                        \"Risk-Free Rate (%)\",\n",
        "                        min_value=0.0,\n",
        "                        max_value=10.0,\n",
        "                        value=4.5,\n",
        "                        step=0.1\n",
        "                    ) / 100\n",
        "\n",
        "                    market_risk_premium = st.slider(\n",
        "                        \"Market Risk Premium (%)\",\n",
        "                        min_value=3.0,\n",
        "                        max_value=10.0,\n",
        "                        value=6.0,\n",
        "                        step=0.5\n",
        "                    ) / 100\n",
        "\n",
        "                    beta = st.number_input(\n",
        "                        \"Beta\",\n",
        "                        min_value=0.0,\n",
        "                        max_value=3.0,\n",
        "                        value=float(company['beta']) if company['beta'] else 1.0,\n",
        "                        step=0.1\n",
        "                    )\n",
        "\n",
        "                with col2:\n",
        "                    if dcf_method == 'FCFF':\n",
        "                        cost_debt = st.slider(\n",
        "                            \"Cost of Debt (%)\",\n",
        "                            min_value=0.0,\n",
        "                            max_value=15.0,\n",
        "                            value=5.0,\n",
        "                            step=0.5\n",
        "                        ) / 100\n",
        "\n",
        "                    if use_smart_assumptions:\n",
        "                        tax_rate = smart_params['tax_rate']\n",
        "                        st.metric(\"Tax Rate\", f\"{tax_rate*100:.1f}%\",\n",
        "                                 delta=\"AI Generated\", delta_color=\"normal\")\n",
        "                    else:\n",
        "                        tax_rate = st.slider(\n",
        "                            \"Tax Rate (%)\",\n",
        "                            min_value=0.0,\n",
        "                            max_value=40.0,\n",
        "                            value=float(financials.get('tax_rate', 0.21) * 100),\n",
        "                            step=1.0\n",
        "                        ) / 100\n",
        "\n",
        "                    if dcf_method == 'FCFE':\n",
        "                        net_borrowing = st.number_input(\n",
        "                            \"Net Borrowing ($M)\",\n",
        "                            min_value=-1000.0,\n",
        "                            max_value=1000.0,\n",
        "                            value=0.0,\n",
        "                            step=10.0\n",
        "                        ) * 1e6\n",
        "\n",
        "            with tab3:\n",
        "                st.markdown(\"##### Terminal Value Assumptions\")\n",
        "\n",
        "                col1, col2 = st.columns(2)\n",
        "\n",
        "                with col1:\n",
        "                    if use_smart_assumptions:\n",
        "                        terminal_growth = smart_params['terminal_growth']\n",
        "                        st.metric(\"Perpetual Growth Rate\", f\"{terminal_growth*100:.1f}%\",\n",
        "                                 delta=\"AI Generated\", delta_color=\"normal\")\n",
        "                    else:\n",
        "                        terminal_growth = st.slider(\n",
        "                            \"Perpetual Growth Rate (%)\",\n",
        "                            min_value=0.0,\n",
        "                            max_value=5.0,\n",
        "                            value=2.5,\n",
        "                            step=0.1\n",
        "                        ) / 100\n",
        "\n",
        "                with col2:\n",
        "                    st.info(f\"\"\"\n",
        "                    **Terminal Value Method:** Gordon Growth Model\n",
        "\n",
        "                    TV = FCF‚Çô‚Çä‚ÇÅ / (r - g)\n",
        "                    \"\"\")\n",
        "\n",
        "            st.markdown(\"---\")\n",
        "\n",
        "            # Calculate DCF\n",
        "            if st.button(\"üöÄ Calculate Intrinsic Value\", type=\"primary\", use_container_width=True):\n",
        "                with st.spinner(\"üî¨ Running DCF Analysis...\"):\n",
        "\n",
        "                    # Calculate cost of equity\n",
        "                    cost_equity = calculate_cost_of_equity(risk_free, beta, market_risk_premium)\n",
        "\n",
        "                    # Calculate discount rate\n",
        "                    if dcf_method == 'FCFF':\n",
        "                        total_debt = financials.get('total_debt', 0)\n",
        "                        total_equity = company['market_cap']\n",
        "                        discount_rate = calculate_wacc(cost_equity, cost_debt, tax_rate, total_debt, total_equity)\n",
        "                    else:\n",
        "                        discount_rate = cost_equity\n",
        "\n",
        "                    # Get base financials\n",
        "                    base_revenue = financials.get('revenue', 0)\n",
        "                    base_ebit = financials.get('ebit', 0)\n",
        "                    base_net_income = financials.get('net_income', 0)\n",
        "\n",
        "                    # ENHANCED: Project cash flows with scaling D&A and CapEx\n",
        "                    if dcf_method == 'FCFF':\n",
        "                        projections = project_fcff_enhanced(\n",
        "                            base_revenue, base_ebit, revenue_growth, ebit_margin, tax_rate,\n",
        "                            depreciation_pct, capex_pct, wc_change, forecast_years\n",
        "                        )\n",
        "                        final_fcf = projections[-1]['fcff']\n",
        "                    else:\n",
        "                        projections = project_fcfe_enhanced(\n",
        "                            base_revenue, base_net_income, revenue_growth, tax_rate,\n",
        "                            depreciation_pct, capex_pct, wc_change, net_borrowing, forecast_years\n",
        "                        )\n",
        "                        final_fcf = projections[-1]['fcfe']\n",
        "\n",
        "                    # Calculate terminal value\n",
        "                    terminal_value = calculate_terminal_value(final_fcf, discount_rate, terminal_growth)\n",
        "\n",
        "                    # Calculate DCF value\n",
        "                    net_debt = financials.get('total_debt', 0) - financials.get('cash', 0)\n",
        "                    shares = company['shares_outstanding']\n",
        "\n",
        "                    dcf_results = calculate_dcf_value(\n",
        "                        projections, discount_rate, terminal_value, shares,\n",
        "                        net_debt if dcf_method == 'FCFF' else 0, dcf_method\n",
        "                    )\n",
        "\n",
        "                    dcf_results['net_debt'] = net_debt\n",
        "\n",
        "                    # Store results\n",
        "                    st.session_state['dcf_results'] = dcf_results\n",
        "                    st.session_state['dcf_projections'] = projections\n",
        "                    st.session_state['dcf_method'] = dcf_method\n",
        "                    st.session_state['discount_rate'] = discount_rate\n",
        "                    st.session_state['terminal_growth'] = terminal_growth\n",
        "                    st.session_state['used_smart_assumptions'] = use_smart_assumptions\n",
        "\n",
        "                    st.success(\"‚úÖ Valuation Complete!\")\n",
        "\n",
        "            # Display Results\n",
        "            if 'dcf_results' in st.session_state:\n",
        "                results = st.session_state['dcf_results']\n",
        "                projections = st.session_state['dcf_projections']\n",
        "                method = st.session_state['dcf_method']\n",
        "\n",
        "                st.markdown(\"---\")\n",
        "                st.markdown(\"### üìä Valuation Results\")\n",
        "\n",
        "                if st.session_state.get('used_smart_assumptions', False):\n",
        "                    st.success(\"ü§ñ **These results used AI-Generated Smart Assumptions**\")\n",
        "\n",
        "                # Key metrics\n",
        "                intrinsic_value = results['intrinsic_value_per_share']\n",
        "                current_price = company['current_price']\n",
        "                upside_downside = ((intrinsic_value - current_price) / current_price) * 100\n",
        "\n",
        "                col1, col2, col3, col4 = st.columns(4)\n",
        "\n",
        "                col1.metric(\n",
        "                    \"Intrinsic Value\",\n",
        "                    format_currency(intrinsic_value),\n",
        "                    delta=format_percentage(upside_downside) if abs(upside_downside) < 1000 else \"¬±‚àû\"\n",
        "                )\n",
        "\n",
        "                col2.metric(\"Current Price\", format_currency(current_price))\n",
        "\n",
        "                col3.metric(\n",
        "                    \"Upside/Downside\",\n",
        "                    format_percentage(upside_downside) if abs(upside_downside) < 1000 else \"¬±‚àû\",\n",
        "                    delta=\"Undervalued\" if upside_downside > 0 else \"Overvalued\"\n",
        "                )\n",
        "\n",
        "                col4.metric(\"Discount Rate\", format_percentage(st.session_state['discount_rate'] * 100))\n",
        "\n",
        "                # Valuation interpretation\n",
        "                st.markdown(\"---\")\n",
        "\n",
        "                if upside_downside > 20:\n",
        "                    st.success(f\"\"\"\n",
        "                    ‚úÖ **Significantly Undervalued**\n",
        "\n",
        "                    The intrinsic value suggests the stock is trading at a {abs(upside_downside):.1f}% discount to fair value.\n",
        "                    \"\"\")\n",
        "                elif upside_downside > 0:\n",
        "                    st.info(f\"\"\"\n",
        "                    üìä **Slightly Undervalued**\n",
        "\n",
        "                    Modest upside potential of {upside_downside:.1f}%.\n",
        "                    \"\"\")\n",
        "                elif upside_downside > -20:\n",
        "                    st.warning(f\"\"\"\n",
        "                    ‚ö†Ô∏è **Slightly Overvalued**\n",
        "\n",
        "                    Trading {abs(upside_downside):.1f}% above fair value.\n",
        "                    \"\"\")\n",
        "                else:\n",
        "                    st.error(f\"\"\"\n",
        "                    ‚ùå **Significantly Overvalued**\n",
        "\n",
        "                    Trading at a {abs(upside_downside):.1f}% premium to fair value.\n",
        "                    \"\"\")\n",
        "\n",
        "                st.markdown(\"---\")\n",
        "\n",
        "                # Visualizations\n",
        "                col1, col2 = st.columns(2)\n",
        "\n",
        "                with col1:\n",
        "                    waterfall = create_dcf_waterfall(results, method)\n",
        "                    st.plotly_chart(waterfall, use_container_width=True)\n",
        "\n",
        "                with col2:\n",
        "                    cf_chart = create_cash_flow_chart(projections, method)\n",
        "                    st.plotly_chart(cf_chart, use_container_width=True)\n",
        "\n",
        "                # Sensitivity Analysis\n",
        "                st.markdown(\"---\")\n",
        "                st.markdown(\"#### üéØ Sensitivity Analysis\")\n",
        "\n",
        "                sensitivity = create_sensitivity_table(\n",
        "                    intrinsic_value,\n",
        "                    st.session_state['discount_rate'],\n",
        "                    st.session_state['terminal_growth']\n",
        "                )\n",
        "                st.plotly_chart(sensitivity, use_container_width=True)\n",
        "\n",
        "                # Detailed Projections Table\n",
        "                st.markdown(\"---\")\n",
        "                st.markdown(\"#### üìã Detailed Cash Flow Projections\")\n",
        "\n",
        "                proj_df = pd.DataFrame(projections)\n",
        "\n",
        "                # Format for display\n",
        "                if method == 'FCFF':\n",
        "                    display_cols = ['year', 'revenue', 'ebit', 'nopat', 'depreciation', 'capex', 'change_wc', 'fcff']\n",
        "                    col_names = ['Year', 'Revenue', 'EBIT', 'NOPAT', 'D&A', 'CapEx', 'ŒîWC', 'FCFF']\n",
        "                else:\n",
        "                    display_cols = ['year', 'revenue', 'net_income', 'depreciation', 'capex', 'change_wc', 'net_borrowing', 'fcfe']\n",
        "                    col_names = ['Year', 'Revenue', 'Net Income', 'D&A', 'CapEx', 'ŒîWC', 'Borrowing', 'FCFE']\n",
        "\n",
        "                proj_display = proj_df[display_cols].copy()\n",
        "                proj_display.columns = col_names\n",
        "\n",
        "                # Format numbers\n",
        "                for col in proj_display.columns:\n",
        "                    if col != 'Year':\n",
        "                        proj_display[col] = proj_display[col].apply(format_large_number)\n",
        "\n",
        "                st.dataframe(proj_display, use_container_width=True, hide_index=True)\n",
        "\n",
        "                st.success(\"‚úÖ **Notice:** D&A and CapEx scale with revenue growth (as they should!)\")\n",
        "\n",
        "                # Export Options\n",
        "                st.markdown(\"---\")\n",
        "                col1, col2, col3 = st.columns(3)\n",
        "\n",
        "                with col1:\n",
        "                    if st.button(\"üì• Export to Excel\", use_container_width=True):\n",
        "                        st.info(\"Excel export feature coming soon!\")\n",
        "\n",
        "                with col2:\n",
        "                    if st.button(\"üìÑ Generate PDF Report\", use_container_width=True):\n",
        "                        st.info(\"PDF export feature coming soon!\")\n",
        "\n",
        "                with col3:\n",
        "                    if st.button(\"üîÑ Reset Valuation\", use_container_width=True):\n",
        "                        for key in ['dcf_results', 'dcf_projections', 'used_smart_assumptions']:\n",
        "                            if key in st.session_state:\n",
        "                                del st.session_state[key]\n",
        "                        st.rerun()\n",
        "\n",
        "        else:\n",
        "            # No company loaded\n",
        "            st.markdown(\"---\")\n",
        "            st.markdown(\"\"\"\n",
        "            ### üìö How to Use Valuation House - Excellence Edition\n",
        "\n",
        "            **NEW in v9.3: ü§ñ Smart Assumptions Mode**\n",
        "            - AI-generated assumptions based on sector benchmarks\n",
        "            - Realistic, economically grounded projections\n",
        "            - Toggle between manual and smart modes\n",
        "\n",
        "            **Step 1:** Search for any publicly traded company\n",
        "            **Step 2:** Choose FCFF or FCFE valuation method\n",
        "            **Step 3:** Enable Smart Assumptions or customize manually\n",
        "            **Step 4:** Calculate intrinsic value and analyze results\n",
        "            **Step 5:** Review sensitivity analysis\n",
        "\n",
        "            ---\n",
        "\n",
        "            ### ‚ú® What's New in v9.3 Excellence\n",
        "\n",
        "            ‚úÖ **Smart Assumptions:** AI-powered realistic assumptions\n",
        "            ‚úÖ **Fixed Scaling:** D&A and CapEx properly scale with revenue\n",
        "            ‚úÖ **Enhanced Visuals:** Seamless dark mode theming\n",
        "            ‚úÖ **Better Analysis:** More comprehensive sensitivity testing\n",
        "\n",
        "            *Ready to start? Enter a ticker symbol above!* üöÄ\n",
        "            \"\"\")\n",
        "\n",
        "    # ========================================================================\n",
        "    # ABOUT\n",
        "    # ========================================================================\n",
        "    elif page == \"‚ÑπÔ∏è About\":\n",
        "        st.markdown(\"### ‚ÑπÔ∏è ATLAS Terminal v9.3 EXCELLENCE EDITION\")\n",
        "        st.success(\"\"\"\n",
        "        **ATLAS v9.3 EXCELLENCE EDITION** üî•üíé\n",
        "\n",
        "        **EXCELLENCE ENHANCEMENTS:**\n",
        "        ‚úÖ Enhanced Home Page (Top Contributors/Detractors + Better Layout)\n",
        "        ‚úÖ Market Watch COMPLETE REVAMP (Crypto, Bonds, Spreads, 100+ Assets)\n",
        "        ‚úÖ ALL Charts Seamlessly Themed (No More Black Boxes!)\n",
        "        ‚úÖ Portfolio Deep Dive Enhanced (Better Concentration Analysis)\n",
        "        ‚úÖ Valuation House: Smart Assumptions Mode (AI-Generated)\n",
        "        ‚úÖ Valuation House: Fixed D&A/CapEx Scaling with Revenue\n",
        "        ‚úÖ Fixed Nov 2024 Columns in All Heatmaps\n",
        "        ‚úÖ Multi-Factor Analysis (Perfect - No Changes Needed!)\n",
        "\n",
        "        **COMPLETE MODULE LIST:**\n",
        "        1. **Phoenix Parser** - Exceptional data parsing\n",
        "        2. **Portfolio Home** - Enhanced dashboard with contributors/detractors\n",
        "        3. **Market Watch** - Comprehensive: Indices, Crypto, Bonds, Spreads, ETFs, Stocks, Commodities\n",
        "        4. **Risk Analysis** - World-class metrics & visualizations\n",
        "        5. **Performance Suite** - Comprehensive analytics\n",
        "        6. **Portfolio Deep Dive** - Enhanced concentration analysis\n",
        "        7. **Multi-Factor Analysis** - Advanced attribution (kept perfect!)\n",
        "        8. **Valuation House** - Smart Assumptions + Enhanced DCF\n",
        "\n",
        "        **KEY FEATURES:**\n",
        "        - ü§ñ Smart Assumptions for DCF valuations\n",
        "        - üåç Expanded Market Watch (150+ assets)\n",
        "        - üìä Seamless chart theming throughout\n",
        "        - üéØ Enhanced Home Page dashboard\n",
        "        - üíé Fixed D&A/CapEx scaling\n",
        "        - ‚ú® All original features preserved\n",
        "\n",
        "        **WHAT'S FIXED IN v9.3:**\n",
        "        - ‚úÖ All charts blend with dark background\n",
        "        - ‚úÖ Nov 2024 incomplete month columns removed\n",
        "        - ‚úÖ D&A and CapEx scale properly with revenue\n",
        "        - ‚úÖ Home Page layout optimized\n",
        "        - ‚úÖ Market Watch massively expanded\n",
        "        - ‚úÖ Concentration analysis enhanced\n",
        "\n",
        "        Total: **The Ultimate Investment Analysis Platform - Now EXCELLENT!** üöÄ\n",
        "        \"\"\")\n",
        "\n",
        "if __name__ == \"__main__\":\n",
        "    main()\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 4,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "dySOp2vj9qUH",
        "outputId": "61712695-4a21-43c8-e0e5-28ae996f3cad"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "üì¶ Installing streamlit... ‚úÖ\n",
            "üì¶ Installing yfinance... ‚úÖ\n",
            "üì¶ Installing plotly... ‚úÖ\n",
            "üì¶ Installing pandas... ‚úÖ\n",
            "üì¶ Installing numpy... ‚úÖ\n",
            "üì¶ Installing scipy... ‚úÖ\n",
            "üì¶ Installing pyngrok... ‚úÖ\n",
            "üì¶ Installing openpyxl... ‚úÖ\n",
            "üì¶ Installing xlrd... ‚úÖ\n",
            "üì¶ Installing xlsxwriter... ‚úÖ\n",
            "üì¶ Installing lxml... ‚úÖ\n",
            "üì¶ Installing html5lib... ‚úÖ\n",
            "üì¶ Installing networkx... ‚úÖ\n",
            "üì¶ Installing scikit-learn... ‚úÖ\n",
            "üì¶ Installing seaborn... ‚úÖ\n",
            "üì¶ Installing pandas-datareader... ‚úÖ\n",
            "üì¶ Installing statsmodels... ‚úÖ\n",
            "\n",
            "‚úÖ All dependencies installed!\n"
          ]
        }
      ],
      "source": [
        "import subprocess\n",
        "import sys\n",
        "\n",
        "packages = [\"streamlit\", \"yfinance\", \"plotly\", \"pandas\", \"numpy\", \"scipy\",\n",
        "            \"pyngrok\", \"openpyxl\", \"xlrd\", \"xlsxwriter\", \"lxml\", \"html5lib\",\n",
        "            \"networkx\", \"scikit-learn\", \"seaborn\", \"pandas-datareader\", \"statsmodels\"]\n",
        "\n",
        "for pkg in packages:\n",
        "    print(f\"üì¶ Installing {pkg}...\", end=\" \")\n",
        "    subprocess.check_call([sys.executable, \"-m\", \"pip\", \"install\", pkg, \"-q\"],\n",
        "                         stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)\n",
        "    print(\"‚úÖ\")\n",
        "\n",
        "print(\"\\n‚úÖ All dependencies installed!\")"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 5,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "ppsum-_O-TOX",
        "outputId": "c4e12144-ea93-4294-86d5-5ef858436671"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "‚úÖ atlas_app.py saved!\n"
          ]
        }
      ],
      "source": [
        "with open('atlas_app.py', 'w', encoding='utf-8') as f:\n",
        "    f.write('''\n",
        "#!/usr/bin/env python3\n",
        "\"\"\"\n",
        "ATLAS TERMINAL v9.3 EXCELLENCE EDITION - PART 1 OF 2\n",
        "Complete Portfolio Analytics + Valuation House - Excellence Optimized\n",
        "\n",
        "ENHANCED IN v9.3:\n",
        "‚úÖ Home Page: Top Contributors/Detractors + Enhanced Dashboard\n",
        "‚úÖ Market Watch: COMPLETE REVAMP (Crypto, Bonds, Spreads, Expanded Universe)\n",
        "‚úÖ Chart Theming: ALL charts blend seamlessly with dark background\n",
        "‚úÖ Portfolio Deep Dive: Enhanced visuals + Fixed Nov 2024 columns\n",
        "‚úÖ Valuation House: Analyst-grade fixes (scaling D&A/CapEx, Smart Assumptions, Editable Projections)\n",
        "‚úÖ ALL original features preserved and enhanced\n",
        "\n",
        "THIS IS PART 1 - Contains all imports, functions, calculations, and setup\n",
        "COPY PART 2 BELOW THIS FILE TO COMPLETE THE APP\n",
        "\"\"\"\n",
        "\n",
        "import pickle\n",
        "import warnings\n",
        "import re\n",
        "import time\n",
        "import io\n",
        "import json\n",
        "import random\n",
        "from datetime import datetime, timedelta, date\n",
        "from pathlib import Path\n",
        "from collections import Counter, defaultdict\n",
        "import numpy as np\n",
        "import pandas as pd\n",
        "import plotly.express as px\n",
        "import plotly.graph_objects as go\n",
        "from plotly.subplots import make_subplots\n",
        "import streamlit as st\n",
        "import yfinance as yf\n",
        "from scipy import stats\n",
        "from scipy.optimize import minimize\n",
        "import networkx as nx\n",
        "from sklearn.preprocessing import StandardScaler\n",
        "from sklearn.decomposition import PCA\n",
        "from sklearn.linear_model import LinearRegression\n",
        "\n",
        "warnings.filterwarnings(\"ignore\")\n",
        "\n",
        "# ============================================================================\n",
        "# HELPER FUNCTIONS FOR VALIDATION\n",
        "# ============================================================================\n",
        "def is_valid_series(series):\n",
        "    \"\"\"Safely check if a pandas Series has valid data\"\"\"\n",
        "    return series is not None and isinstance(series, pd.Series) and not series.empty\n",
        "\n",
        "def is_valid_dataframe(df):\n",
        "    \"\"\"Safely check if a pandas DataFrame has valid data\"\"\"\n",
        "    return df is not None and isinstance(df, pd.DataFrame) and not df.empty\n",
        "\n",
        "# ============================================================================\n",
        "# PAGE CONFIG\n",
        "# ============================================================================\n",
        "st.set_page_config(\n",
        "    page_title=\"ATLAS Terminal v9.3 EXCELLENCE\",\n",
        "    page_icon=\"üî•\",\n",
        "    layout=\"wide\",\n",
        "    initial_sidebar_state=\"expanded\"\n",
        ")\n",
        "\n",
        "# ============================================================================\n",
        "# PROFESSIONAL THEME SYSTEM - ENHANCED FOR SEAMLESS CHARTS\n",
        "# ============================================================================\n",
        "\n",
        "COLORS = {\n",
        "    \"background\": \"#000000\",\n",
        "    \"card_background\": \"#0a1929\",\n",
        "    \"card_background_alt\": \"#050f17\",\n",
        "    \"neon_blue\": \"#00d4ff\",\n",
        "    \"electric_blue\": \"#0080ff\",\n",
        "    \"teal\": \"#00ffcc\",\n",
        "    \"cyan\": \"#00ffff\",\n",
        "    \"success\": \"#00ff88\",\n",
        "    \"warning\": \"#ffaa00\",\n",
        "    \"danger\": \"#ff0044\",\n",
        "    \"info\": \"#00d4ff\",\n",
        "    \"purple\": \"#b794f6\",\n",
        "    \"pink\": \"#ff00ff\",\n",
        "    \"orange\": \"#ff6b00\",\n",
        "    \"chart_primary\": \"#00d4ff\",\n",
        "    \"chart_secondary\": \"#0080ff\",\n",
        "    \"chart_accent\": \"#00ffcc\",\n",
        "    \"chart_grid\": \"#1a3a52\",\n",
        "    \"text_primary\": \"#ffffff\",\n",
        "    \"text_secondary\": \"#b0c4de\",\n",
        "    \"text_muted\": \"#6c8ca8\",\n",
        "    \"border\": \"#00d4ff\",\n",
        "    \"shadow\": \"rgba(0, 212, 255, 0.3)\",\n",
        "    \"shadow_strong\": \"rgba(0, 212, 255, 0.6)\",\n",
        "    \"gain_bg\": \"rgba(0, 255, 136, 0.15)\",\n",
        "    \"gain_text\": \"#00ff88\",\n",
        "    \"loss_bg\": \"rgba(255, 0, 68, 0.15)\",\n",
        "    \"loss_text\": \"#ff0044\",\n",
        "}\n",
        "\n",
        "# ============================================================================\n",
        "# CHART THEME CONFIGURATION - SEAMLESS DARK MODE\n",
        "# ============================================================================\n",
        "CHART_THEME = {\n",
        "    'paper_bgcolor': 'rgba(0, 0, 0, 0)',  # Transparent background\n",
        "    'plot_bgcolor': 'rgba(10, 25, 41, 0.3)',  # Semi-transparent plot area\n",
        "    'font': {'color': COLORS['text_primary'], 'family': 'Inter, sans-serif'},\n",
        "    'xaxis': {\n",
        "        'gridcolor': COLORS['chart_grid'],\n",
        "        'linecolor': COLORS['chart_grid'],\n",
        "        'zerolinecolor': COLORS['chart_grid']\n",
        "    },\n",
        "    'yaxis': {\n",
        "        'gridcolor': COLORS['chart_grid'],\n",
        "        'linecolor': COLORS['chart_grid'],\n",
        "        'zerolinecolor': COLORS['chart_grid']\n",
        "    }\n",
        "}\n",
        "\n",
        "def apply_chart_theme(fig):\n",
        "    \"\"\"Apply seamless dark theme to any Plotly figure\"\"\"\n",
        "    fig.update_layout(\n",
        "        paper_bgcolor='rgba(0, 0, 0, 0)',\n",
        "        plot_bgcolor='rgba(10, 25, 41, 0.3)',\n",
        "        font=dict(color=COLORS['text_primary'], family='Inter, sans-serif'),\n",
        "        xaxis=dict(\n",
        "            gridcolor=COLORS['chart_grid'],\n",
        "            linecolor=COLORS['chart_grid'],\n",
        "            zerolinecolor=COLORS['chart_grid']\n",
        "        ),\n",
        "        yaxis=dict(\n",
        "            gridcolor=COLORS['chart_grid'],\n",
        "            linecolor=COLORS['chart_grid'],\n",
        "            zerolinecolor=COLORS['chart_grid']\n",
        "        )\n",
        "    )\n",
        "    return fig\n",
        "\n",
        "COLORSCALES = {\n",
        "    \"viridis\": px.colors.sequential.Viridis,\n",
        "    \"plasma\": px.colors.sequential.Plasma,\n",
        "    \"turbo\": px.colors.sequential.Turbo,\n",
        "    \"rdylgn\": px.colors.diverging.RdYlGn,\n",
        "    \"spectral\": px.colors.diverging.Spectral,\n",
        "}\n",
        "\n",
        "# ============================================================================\n",
        "# ENHANCED CSS\n",
        "# ============================================================================\n",
        "st.markdown(f\"\"\"\n",
        "<style>\n",
        "    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;600&display=swap');\n",
        "\n",
        "    * {{\n",
        "        font-family: 'Inter', 'Segoe UI', sans-serif !important;\n",
        "    }}\n",
        "\n",
        "    @keyframes pulseGreen {{\n",
        "        0% {{ background-color: {COLORS['gain_bg']}; transform: scale(1); }}\n",
        "        50% {{ background-color: rgba(0, 255, 136, 0.25); transform: scale(1.02); }}\n",
        "        100% {{ background-color: {COLORS['gain_bg']}; transform: scale(1); }}\n",
        "    }}\n",
        "\n",
        "    @keyframes pulseRed {{\n",
        "        0% {{ background-color: {COLORS['loss_bg']}; transform: scale(1); }}\n",
        "        50% {{ background-color: rgba(255, 0, 68, 0.25); transform: scale(1.02); }}\n",
        "        100% {{ background-color: {COLORS['loss_bg']}; transform: scale(1); }}\n",
        "    }}\n",
        "\n",
        "    .main {{\n",
        "        background: linear-gradient(135deg, #000000 0%, #0a1929 100%);\n",
        "        color: {COLORS['text_primary']};\n",
        "    }}\n",
        "\n",
        "    h1 {{\n",
        "        background: linear-gradient(90deg, #00d4ff, #00ff88, #00d4ff);\n",
        "        background-clip: text;\n",
        "        -webkit-background-clip: text;\n",
        "        -webkit-text-fill-color: transparent;\n",
        "        text-shadow: 0 0 40px rgba(0,212,255,0.8);\n",
        "        font-family: 'Inter', sans-serif !important;\n",
        "        font-weight: 700 !important;\n",
        "        font-size: 3.5em !important;\n",
        "        text-align: center;\n",
        "        animation: glow 2s ease-in-out infinite alternate;\n",
        "    }}\n",
        "\n",
        "    @keyframes glow {{\n",
        "        from {{ text-shadow: 0 0 20px rgba(0,212,255,0.5); }}\n",
        "        to {{ text-shadow: 0 0 30px rgba(0,212,255,1), 0 0 40px rgba(0,255,136,0.5); }}\n",
        "    }}\n",
        "\n",
        "    div[data-testid=\"stDataFrame\"] tbody tr:hover {{\n",
        "        background: linear-gradient(90deg, rgba(0, 212, 255, 0.2) 0%, rgba(0, 212, 255, 0.1) 100%) !important;\n",
        "        transform: scale(1.02) translateX(5px);\n",
        "        box-shadow: 0 5px 20px rgba(0, 212, 255, 0.3);\n",
        "        border-left: 3px solid {COLORS['neon_blue']};\n",
        "    }}\n",
        "\n",
        "    div[data-testid=\"stDataFrame\"] thead th {{\n",
        "        background: linear-gradient(135deg, {COLORS['neon_blue']} 0%, {COLORS['electric_blue']} 100%) !important;\n",
        "        color: {COLORS['background']} !important;\n",
        "        font-weight: 700 !important;\n",
        "        font-size: 14px !important;\n",
        "        text-transform: uppercase !important;\n",
        "    }}\n",
        "\n",
        "    div[data-testid=\"stMetric\"] {{\n",
        "        background: linear-gradient(135deg, {COLORS['card_background']} 0%, {COLORS['card_background_alt']} 100%);\n",
        "        border: 2px solid {COLORS['neon_blue']};\n",
        "        border-radius: 12px;\n",
        "        padding: 20px;\n",
        "        box-shadow: 0 0 30px {COLORS['shadow']};\n",
        "        transition: all 0.3s ease;\n",
        "    }}\n",
        "\n",
        "    div[data-testid=\"stMetric\"]:hover {{\n",
        "        transform: translateY(-5px) scale(1.02);\n",
        "        box-shadow: 0 10px 40px {COLORS['shadow_strong']};\n",
        "    }}\n",
        "\n",
        "    .stSlider {{\n",
        "        padding: 10px 0px;\n",
        "    }}\n",
        "</style>\n",
        "\"\"\", unsafe_allow_html=True)\n",
        "\n",
        "# ============================================================================\n",
        "# CONSTANTS & CONFIG\n",
        "# ============================================================================\n",
        "CACHE_DIR = Path.home() / \".atlas_cache\"\n",
        "CACHE_DIR.mkdir(exist_ok=True)\n",
        "PORTFOLIO_CACHE = CACHE_DIR / \"portfolio.pkl\"\n",
        "TRADE_HISTORY_CACHE = CACHE_DIR / \"trade_history.pkl\"\n",
        "ACCOUNT_HISTORY_CACHE = CACHE_DIR / \"account_history.pkl\"\n",
        "\n",
        "RISK_FREE_RATE = 0.045\n",
        "MARKET_RETURN = 0.10\n",
        "\n",
        "# ============================================================================\n",
        "# EXPANDED MARKET WATCH UNIVERSE - EXCELLENCE EDITION\n",
        "# ============================================================================\n",
        "\n",
        "# Global Market Indices\n",
        "GLOBAL_INDICES = {\n",
        "    \"^GSPC\": {\"name\": \"S&P 500\", \"region\": \"US\"},\n",
        "    \"^NDX\": {\"name\": \"Nasdaq 100\", \"region\": \"US\"},\n",
        "    \"^DJI\": {\"name\": \"Dow Jones\", \"region\": \"US\"},\n",
        "    \"^RUT\": {\"name\": \"Russell 2000\", \"region\": \"US\"},\n",
        "    \"^FTSE\": {\"name\": \"FTSE 100\", \"region\": \"UK\"},\n",
        "    \"^GDAXI\": {\"name\": \"DAX\", \"region\": \"Germany\"},\n",
        "    \"^FCHI\": {\"name\": \"CAC 40\", \"region\": \"France\"},\n",
        "    \"^STOXX50E\": {\"name\": \"Euro Stoxx 50\", \"region\": \"Europe\"},\n",
        "    \"^N225\": {\"name\": \"Nikkei 225\", \"region\": \"Japan\"},\n",
        "    \"^HSI\": {\"name\": \"Hang Seng\", \"region\": \"Hong Kong\"},\n",
        "    \"000001.SS\": {\"name\": \"Shanghai Composite\", \"region\": \"China\"},\n",
        "    \"^BSESN\": {\"name\": \"BSE Sensex\", \"region\": \"India\"},\n",
        "    \"^BVSP\": {\"name\": \"Bovespa\", \"region\": \"Brazil\"},\n",
        "    \"^AXJO\": {\"name\": \"ASX 200\", \"region\": \"Australia\"},\n",
        "    \"^GSPTSE\": {\"name\": \"TSX Composite\", \"region\": \"Canada\"}\n",
        "}\n",
        "\n",
        "# EXPANDED: Major Cryptocurrencies\n",
        "CRYPTOCURRENCIES = {\n",
        "    \"BTC-USD\": {\"name\": \"Bitcoin\", \"category\": \"Crypto\"},\n",
        "    \"ETH-USD\": {\"name\": \"Ethereum\", \"category\": \"Crypto\"},\n",
        "    \"BNB-USD\": {\"name\": \"Binance Coin\", \"category\": \"Crypto\"},\n",
        "    \"XRP-USD\": {\"name\": \"Ripple\", \"category\": \"Crypto\"},\n",
        "    \"ADA-USD\": {\"name\": \"Cardano\", \"category\": \"Crypto\"},\n",
        "    \"SOL-USD\": {\"name\": \"Solana\", \"category\": \"Crypto\"},\n",
        "    \"DOGE-USD\": {\"name\": \"Dogecoin\", \"category\": \"Crypto\"},\n",
        "    \"MATIC-USD\": {\"name\": \"Polygon\", \"category\": \"Crypto\"},\n",
        "    \"DOT-USD\": {\"name\": \"Polkadot\", \"category\": \"Crypto\"},\n",
        "    \"AVAX-USD\": {\"name\": \"Avalanche\", \"category\": \"Crypto\"}\n",
        "}\n",
        "\n",
        "# EXPANDED: Bond Yields and Rates\n",
        "BOND_YIELDS = {\n",
        "    \"^TNX\": {\"name\": \"US 10Y Treasury\", \"category\": \"Government Bonds\"},\n",
        "    \"^TYX\": {\"name\": \"US 30Y Treasury\", \"category\": \"Government Bonds\"},\n",
        "    \"^FVX\": {\"name\": \"US 5Y Treasury\", \"category\": \"Government Bonds\"},\n",
        "    \"^IRX\": {\"name\": \"US 13W Treasury\", \"category\": \"Government Bonds\"},\n",
        "}\n",
        "\n",
        "# NEW: Credit Spreads (using ETF proxies)\n",
        "CREDIT_SPREADS = {\n",
        "    \"LQD\": {\"name\": \"Investment Grade Credit\", \"category\": \"Credit\"},\n",
        "    \"HYG\": {\"name\": \"High Yield Credit\", \"category\": \"Credit\"},\n",
        "    \"EMB\": {\"name\": \"Emerging Market Bonds\", \"category\": \"Credit\"},\n",
        "    \"TIP\": {\"name\": \"TIPS (Inflation-Protected)\", \"category\": \"Government Bonds\"},\n",
        "    \"MBB\": {\"name\": \"Mortgage-Backed Securities\", \"category\": \"Credit\"},\n",
        "}\n",
        "\n",
        "# EXPANDED: Commodities\n",
        "COMMODITIES = {\n",
        "    \"GC=F\": {\"name\": \"Gold\", \"category\": \"Precious Metals\"},\n",
        "    \"SI=F\": {\"name\": \"Silver\", \"category\": \"Precious Metals\"},\n",
        "    \"PL=F\": {\"name\": \"Platinum\", \"category\": \"Precious Metals\"},\n",
        "    \"PA=F\": {\"name\": \"Palladium\", \"category\": \"Precious Metals\"},\n",
        "    \"CL=F\": {\"name\": \"Crude Oil WTI\", \"category\": \"Energy\"},\n",
        "    \"BZ=F\": {\"name\": \"Brent Crude\", \"category\": \"Energy\"},\n",
        "    \"NG=F\": {\"name\": \"Natural Gas\", \"category\": \"Energy\"},\n",
        "    \"RB=F\": {\"name\": \"Gasoline\", \"category\": \"Energy\"},\n",
        "    \"HG=F\": {\"name\": \"Copper\", \"category\": \"Industrial Metals\"},\n",
        "    \"ALI=F\": {\"name\": \"Aluminum\", \"category\": \"Industrial Metals\"},\n",
        "    \"ZC=F\": {\"name\": \"Corn\", \"category\": \"Agriculture\"},\n",
        "    \"ZW=F\": {\"name\": \"Wheat\", \"category\": \"Agriculture\"},\n",
        "    \"ZS=F\": {\"name\": \"Soybeans\", \"category\": \"Agriculture\"},\n",
        "    \"KC=F\": {\"name\": \"Coffee\", \"category\": \"Agriculture\"},\n",
        "    \"SB=F\": {\"name\": \"Sugar\", \"category\": \"Agriculture\"},\n",
        "    \"CC=F\": {\"name\": \"Cocoa\", \"category\": \"Agriculture\"},\n",
        "    \"LE=F\": {\"name\": \"Live Cattle\", \"category\": \"Livestock\"},\n",
        "    \"GF=F\": {\"name\": \"Feeder Cattle\", \"category\": \"Livestock\"}\n",
        "}\n",
        "\n",
        "# EXPANDED: Popular Stocks (diverse selection)\n",
        "POPULAR_STOCKS = {\n",
        "    # Mega Cap Tech\n",
        "    \"AAPL\": {\"name\": \"Apple\", \"sector\": \"Technology\", \"category\": \"Mega Cap Tech\"},\n",
        "    \"MSFT\": {\"name\": \"Microsoft\", \"sector\": \"Technology\", \"category\": \"Mega Cap Tech\"},\n",
        "    \"GOOGL\": {\"name\": \"Alphabet\", \"sector\": \"Technology\", \"category\": \"Mega Cap Tech\"},\n",
        "    \"AMZN\": {\"name\": \"Amazon\", \"sector\": \"Consumer Cyclical\", \"category\": \"Mega Cap Tech\"},\n",
        "    \"NVDA\": {\"name\": \"NVIDIA\", \"sector\": \"Technology\", \"category\": \"Mega Cap Tech\"},\n",
        "    \"META\": {\"name\": \"Meta\", \"sector\": \"Technology\", \"category\": \"Mega Cap Tech\"},\n",
        "    \"TSLA\": {\"name\": \"Tesla\", \"sector\": \"Consumer Cyclical\", \"category\": \"Mega Cap Tech\"},\n",
        "\n",
        "    # Financials\n",
        "    \"JPM\": {\"name\": \"JPMorgan\", \"sector\": \"Financial Services\", \"category\": \"Financials\"},\n",
        "    \"BAC\": {\"name\": \"Bank of America\", \"sector\": \"Financial Services\", \"category\": \"Financials\"},\n",
        "    \"GS\": {\"name\": \"Goldman Sachs\", \"sector\": \"Financial Services\", \"category\": \"Financials\"},\n",
        "    \"MS\": {\"name\": \"Morgan Stanley\", \"sector\": \"Financial Services\", \"category\": \"Financials\"},\n",
        "\n",
        "    # Healthcare\n",
        "    \"JNJ\": {\"name\": \"Johnson & Johnson\", \"sector\": \"Healthcare\", \"category\": \"Healthcare\"},\n",
        "    \"UNH\": {\"name\": \"UnitedHealth\", \"sector\": \"Healthcare\", \"category\": \"Healthcare\"},\n",
        "    \"PFE\": {\"name\": \"Pfizer\", \"sector\": \"Healthcare\", \"category\": \"Healthcare\"},\n",
        "\n",
        "    # Consumer\n",
        "    \"WMT\": {\"name\": \"Walmart\", \"sector\": \"Consumer Defensive\", \"category\": \"Consumer\"},\n",
        "    \"PG\": {\"name\": \"Procter & Gamble\", \"sector\": \"Consumer Defensive\", \"category\": \"Consumer\"},\n",
        "    \"KO\": {\"name\": \"Coca-Cola\", \"sector\": \"Consumer Defensive\", \"category\": \"Consumer\"},\n",
        "\n",
        "    # Energy\n",
        "    \"XOM\": {\"name\": \"Exxon Mobil\", \"sector\": \"Energy\", \"category\": \"Energy\"},\n",
        "    \"CVX\": {\"name\": \"Chevron\", \"sector\": \"Energy\", \"category\": \"Energy\"},\n",
        "}\n",
        "\n",
        "# EXPANDED: Popular ETFs (now includes thematic and sector)\n",
        "POPULAR_ETFS = {\n",
        "    # Broad Market\n",
        "    \"SPY\": {\"name\": \"SPDR S&P 500\", \"category\": \"Broad Market\", \"avg_volume\": 70000000},\n",
        "    \"QQQ\": {\"name\": \"Invesco QQQ\", \"category\": \"Broad Market\", \"avg_volume\": 40000000},\n",
        "    \"IWM\": {\"name\": \"Russell 2000\", \"category\": \"Broad Market\", \"avg_volume\": 30000000},\n",
        "    \"VTI\": {\"name\": \"Total Stock Market\", \"category\": \"Broad Market\", \"avg_volume\": 5000000},\n",
        "\n",
        "    # Sector SPDRs\n",
        "    \"XLK\": {\"name\": \"Technology Select\", \"category\": \"Sector\", \"avg_volume\": 15000000},\n",
        "    \"XLF\": {\"name\": \"Financial Select\", \"category\": \"Sector\", \"avg_volume\": 50000000},\n",
        "    \"XLV\": {\"name\": \"Health Care Select\", \"category\": \"Sector\", \"avg_volume\": 10000000},\n",
        "    \"XLE\": {\"name\": \"Energy Select\", \"category\": \"Sector\", \"avg_volume\": 20000000},\n",
        "    \"XLI\": {\"name\": \"Industrial Select\", \"category\": \"Sector\", \"avg_volume\": 12000000},\n",
        "    \"XLY\": {\"name\": \"Consumer Discretionary\", \"category\": \"Sector\", \"avg_volume\": 8000000},\n",
        "    \"XLP\": {\"name\": \"Consumer Staples\", \"category\": \"Sector\", \"avg_volume\": 10000000},\n",
        "    \"XLU\": {\"name\": \"Utilities Select\", \"category\": \"Sector\", \"avg_volume\": 12000000},\n",
        "    \"XLRE\": {\"name\": \"Real Estate Select\", \"category\": \"Sector\", \"avg_volume\": 5000000},\n",
        "\n",
        "    # Thematic\n",
        "    \"ARKK\": {\"name\": \"ARK Innovation\", \"category\": \"Thematic\", \"avg_volume\": 8000000},\n",
        "    \"ARKQ\": {\"name\": \"ARK Autonomous Tech\", \"category\": \"Thematic\", \"avg_volume\": 2000000},\n",
        "    \"ARKW\": {\"name\": \"ARK Next Gen Internet\", \"category\": \"Thematic\", \"avg_volume\": 1500000},\n",
        "    \"ICLN\": {\"name\": \"Clean Energy\", \"category\": \"Thematic\", \"avg_volume\": 5000000},\n",
        "    \"TAN\": {\"name\": \"Solar Energy\", \"category\": \"Thematic\", \"avg_volume\": 1500000},\n",
        "    \"HACK\": {\"name\": \"Cybersecurity\", \"category\": \"Thematic\", \"avg_volume\": 800000},\n",
        "    \"ROBO\": {\"name\": \"Robotics & AI\", \"category\": \"Thematic\", \"avg_volume\": 500000},\n",
        "    \"FINX\": {\"name\": \"FinTech\", \"category\": \"Thematic\", \"avg_volume\": 300000},\n",
        "\n",
        "    # International\n",
        "    \"EEM\": {\"name\": \"Emerging Markets\", \"category\": \"International\", \"avg_volume\": 25000000},\n",
        "    \"EFA\": {\"name\": \"EAFE\", \"category\": \"International\", \"avg_volume\": 15000000},\n",
        "    \"VWO\": {\"name\": \"FTSE Emerging Markets\", \"category\": \"International\", \"avg_volume\": 10000000},\n",
        "    \"FXI\": {\"name\": \"China Large-Cap\", \"category\": \"International\", \"avg_volume\": 20000000},\n",
        "}\n",
        "\n",
        "# Factor definitions\n",
        "FACTOR_DEFINITIONS = {\n",
        "    \"Market\": {\"description\": \"Market risk premium\", \"benchmark\": \"SPY\"},\n",
        "    \"Size\": {\"description\": \"Small cap minus large cap\", \"benchmark\": \"IWM\"},\n",
        "    \"Value\": {\"description\": \"Value minus growth\", \"benchmark\": \"IWD\"},\n",
        "    \"Momentum\": {\"description\": \"Winners minus losers\", \"benchmark\": \"MTUM\"},\n",
        "    \"Quality\": {\"description\": \"High quality minus low quality\", \"benchmark\": \"QUAL\"},\n",
        "    \"Volatility\": {\"description\": \"Low vol minus high vol\", \"benchmark\": \"USMV\"}\n",
        "}\n",
        "\n",
        "# ETF sectors\n",
        "ETF_SECTORS = {\n",
        "    \"QQQ\": \"Technology\", \"XLK\": \"Technology\", \"VGT\": \"Technology\",\n",
        "    \"XLF\": \"Financial Services\", \"KRE\": \"Financial Services\",\n",
        "    \"XLV\": \"Healthcare\", \"IBB\": \"Healthcare\", \"XBI\": \"Healthcare\",\n",
        "    \"XLE\": \"Energy\", \"XOP\": \"Energy\", \"USO\": \"Energy\",\n",
        "    \"XLB\": \"Basic Materials\", \"GDX\": \"Basic Materials\",\n",
        "    \"XLY\": \"Consumer Cyclical\", \"XLP\": \"Consumer Defensive\",\n",
        "    \"XLI\": \"Industrials\", \"IYT\": \"Industrials\",\n",
        "    \"VNQ\": \"Real Estate\", \"XLRE\": \"Real Estate\",\n",
        "    \"XLU\": \"Utilities\",\n",
        "    \"SPY\": \"Broad Market\", \"VOO\": \"Broad Market\", \"VTI\": \"Broad Market\"\n",
        "}\n",
        "\n",
        "# ============================================================================\n",
        "# HELPER FUNCTIONS\n",
        "# ============================================================================\n",
        "\n",
        "def format_percentage(value, decimals=2):\n",
        "    if pd.isna(value) or value is None:\n",
        "        return \"N/A\"\n",
        "    return f\"{value:.{decimals}f}%\"\n",
        "\n",
        "def format_currency(value):\n",
        "    if pd.isna(value) or value is None:\n",
        "        return \"N/A\"\n",
        "    return f\"${value:,.2f}\"\n",
        "\n",
        "def format_large_number(value):\n",
        "    \"\"\"Format large numbers with B/M/K suffix\"\"\"\n",
        "    if pd.isna(value) or value is None:\n",
        "        return \"N/A\"\n",
        "    if abs(value) >= 1e9:\n",
        "        return f\"${value/1e9:.2f}B\"\n",
        "    elif abs(value) >= 1e6:\n",
        "        return f\"${value/1e6:.2f}M\"\n",
        "    elif abs(value) >= 1e3:\n",
        "        return f\"${value/1e3:.2f}K\"\n",
        "    return f\"${value:.2f}\"\n",
        "\n",
        "def add_arrow_indicator(value):\n",
        "    try:\n",
        "        val = float(str(value).replace('%', '').replace('$', '').replace(',', ''))\n",
        "        if val > 0:\n",
        "            return f\"‚ñ≤ {value}\"\n",
        "        elif val < 0:\n",
        "            return f\"‚ñº {value}\"\n",
        "        return f\"‚îÄ {value}\"\n",
        "    except:\n",
        "        return value\n",
        "\n",
        "# ============================================================================\n",
        "# DATA FUNCTIONS\n",
        "# ============================================================================\n",
        "\n",
        "def save_portfolio_data(data):\n",
        "    with open(PORTFOLIO_CACHE, \"wb\") as f:\n",
        "        pickle.dump(data, f)\n",
        "\n",
        "def load_portfolio_data():\n",
        "    if PORTFOLIO_CACHE.exists():\n",
        "        with open(PORTFOLIO_CACHE, \"rb\") as f:\n",
        "            return pickle.load(f)\n",
        "    return []\n",
        "\n",
        "def save_trade_history(df):\n",
        "    with open(TRADE_HISTORY_CACHE, \"wb\") as f:\n",
        "        pickle.dump(df, f)\n",
        "\n",
        "def load_trade_history():\n",
        "    if TRADE_HISTORY_CACHE.exists():\n",
        "        with open(TRADE_HISTORY_CACHE, \"rb\") as f:\n",
        "            return pickle.load(f)\n",
        "    return None\n",
        "\n",
        "def save_account_history(df):\n",
        "    with open(ACCOUNT_HISTORY_CACHE, \"wb\") as f:\n",
        "        pickle.dump(df, f)\n",
        "\n",
        "def load_account_history():\n",
        "    if ACCOUNT_HISTORY_CACHE.exists():\n",
        "        with open(ACCOUNT_HISTORY_CACHE, \"rb\") as f:\n",
        "            return pickle.load(f)\n",
        "    return None\n",
        "\n",
        "def get_leverage_info():\n",
        "    account_df = load_account_history()\n",
        "    if account_df is not None:\n",
        "        latest_cash = account_df.get('Cash Balance', account_df.get('Cash', pd.Series([0]))).iloc[-1]\n",
        "\n",
        "        if isinstance(latest_cash, str):\n",
        "            latest_cash = latest_cash.replace('$', '').replace(',', '')\n",
        "            if '(' in latest_cash and ')' in latest_cash:\n",
        "                latest_cash = '-' + latest_cash.replace('(', '').replace(')', '')\n",
        "            try:\n",
        "                latest_cash = float(latest_cash)\n",
        "            except:\n",
        "                latest_cash = 0\n",
        "\n",
        "        latest_margin = 0\n",
        "\n",
        "        if 'Margin Used' in account_df.columns:\n",
        "            latest_margin = account_df['Margin Used'].iloc[-1]\n",
        "            if isinstance(latest_margin, str):\n",
        "                latest_margin = latest_margin.replace('$', '').replace(',', '')\n",
        "                if '(' in latest_margin and ')' in latest_margin:\n",
        "                    latest_margin = '-' + latest_margin.replace('(', '').replace(')', '')\n",
        "                try:\n",
        "                    latest_margin = float(latest_margin)\n",
        "                except:\n",
        "                    latest_margin = 0\n",
        "\n",
        "        if latest_cash < 0:\n",
        "            latest_margin = abs(latest_cash)\n",
        "\n",
        "        total_value = 0\n",
        "        if 'Total Value' in account_df.columns:\n",
        "            total_value = account_df['Total Value'].iloc[-1]\n",
        "            if isinstance(total_value, str):\n",
        "                total_value = total_value.replace('$', '').replace(',', '')\n",
        "                if '(' in total_value and ')' in total_value:\n",
        "                    total_value = '-' + total_value.replace('(', '').replace(')', '')\n",
        "                try:\n",
        "                    total_value = float(total_value)\n",
        "                except:\n",
        "                    total_value = abs(latest_cash) + latest_margin\n",
        "        else:\n",
        "            total_value = abs(latest_cash) + latest_margin\n",
        "\n",
        "        leverage_ratio = (total_value / (total_value - latest_margin)) if (total_value - latest_margin) > 0 else 1\n",
        "\n",
        "        return {\n",
        "            'margin_used': latest_margin,\n",
        "            'cash_balance': latest_cash,\n",
        "            'leverage_ratio': leverage_ratio,\n",
        "            'total_value': total_value\n",
        "        }\n",
        "    return None\n",
        "\n",
        "@st.cache_data(ttl=300)\n",
        "def fetch_market_data(ticker):\n",
        "    try:\n",
        "        stock = yf.Ticker(ticker)\n",
        "        info = stock.info\n",
        "        hist = stock.history(period=\"5d\")\n",
        "        if hist.empty:\n",
        "            return None\n",
        "\n",
        "        current_price = hist['Close'].iloc[-1]\n",
        "        prev_close = hist['Close'].iloc[-2] if len(hist) > 1 else current_price\n",
        "        daily_change = current_price - prev_close\n",
        "        daily_change_pct = (daily_change / prev_close * 100) if prev_close else 0\n",
        "\n",
        "        five_day_return = ((current_price / hist['Close'].iloc[0]) - 1) * 100 if len(hist) >= 5 else 0\n",
        "\n",
        "        company_name = info.get('longName', info.get('shortName', ticker))\n",
        "\n",
        "        return {\n",
        "            \"price\": current_price,\n",
        "            \"daily_change\": daily_change,\n",
        "            \"daily_change_pct\": daily_change_pct,\n",
        "            \"five_day_return\": five_day_return,\n",
        "            \"volume\": info.get('volume', 0),\n",
        "            \"avg_volume\": info.get('averageVolume', 0),\n",
        "            \"sector\": info.get('sector', 'Unknown'),\n",
        "            \"beta\": info.get('beta', None),\n",
        "            \"market_cap\": info.get('marketCap', 0),\n",
        "            \"company_name\": company_name,\n",
        "            \"52_week_high\": info.get('fiftyTwoWeekHigh', None),\n",
        "            \"52_week_low\": info.get('fiftyTwoWeekLow', None)\n",
        "        }\n",
        "    except:\n",
        "        return None\n",
        "\n",
        "def is_option_ticker(ticker):\n",
        "    if len(ticker) <= 6:\n",
        "        return False\n",
        "    has_year = any(str(y) in ticker for y in range(2020, 2030))\n",
        "    has_strike = any(c.isdigit() for c in ticker[6:])\n",
        "    has_type = ticker[-1] in ['C', 'P'] or 'C' in ticker[6:] or 'P' in ticker[6:]\n",
        "    return has_year and has_strike and has_type\n",
        "\n",
        "def classify_ticker_sector(ticker, default_sector):\n",
        "    if pd.notna(default_sector) and default_sector != \"Unknown\":\n",
        "        return default_sector\n",
        "\n",
        "    if ticker in ETF_SECTORS:\n",
        "        return ETF_SECTORS[ticker]\n",
        "\n",
        "    return \"Other\"\n",
        "\n",
        "@st.cache_data(ttl=600)\n",
        "def fetch_historical_data(ticker, start_date, end_date):\n",
        "    try:\n",
        "        stock = yf.Ticker(ticker)\n",
        "        hist = stock.history(start=start_date, end=end_date)\n",
        "        if not hist.empty:\n",
        "            return hist\n",
        "    except:\n",
        "        pass\n",
        "    return None\n",
        "\n",
        "@st.cache_data(ttl=3600)\n",
        "def fetch_analyst_data(ticker):\n",
        "    try:\n",
        "        stock = yf.Ticker(ticker)\n",
        "        info = stock.info\n",
        "\n",
        "        rating = info.get('recommendationKey', 'none')\n",
        "        if rating == 'none' or rating is None:\n",
        "            rating = \"No Coverage\"\n",
        "\n",
        "        return {\n",
        "            'rating': rating.upper() if rating != \"No Coverage\" else rating,\n",
        "            'target_price': info.get('targetMeanPrice'),\n",
        "            'num_analysts': info.get('numberOfAnalystOpinions', 0),\n",
        "            'success': True\n",
        "        }\n",
        "    except:\n",
        "        return {'success': False, 'rating': 'No Coverage', 'target_price': None}\n",
        "\n",
        "# ============================================================================\n",
        "# VALUATION HOUSE - ENHANCED WITH SMART ASSUMPTIONS\n",
        "# ============================================================================\n",
        "\n",
        "@st.cache_data(ttl=3600)\n",
        "def fetch_company_financials(ticker):\n",
        "    \"\"\"Fetch comprehensive financial data for valuation\"\"\"\n",
        "    try:\n",
        "        stock = yf.Ticker(ticker)\n",
        "        info = stock.info\n",
        "\n",
        "        # Basic company info\n",
        "        company_data = {\n",
        "            'ticker': ticker,\n",
        "            'name': info.get('longName', ticker),\n",
        "            'sector': info.get('sector', 'Unknown'),\n",
        "            'industry': info.get('industry', 'Unknown'),\n",
        "            'current_price': info.get('currentPrice', 0),\n",
        "            'market_cap': info.get('marketCap', 0),\n",
        "            'shares_outstanding': info.get('sharesOutstanding', 0),\n",
        "            'beta': info.get('beta', 1.0),\n",
        "            'forward_pe': info.get('forwardPE'),\n",
        "            'trailing_pe': info.get('trailingPE'),\n",
        "        }\n",
        "\n",
        "        # Financial statements\n",
        "        income_stmt = stock.income_stmt\n",
        "        balance_sheet = stock.balance_sheet\n",
        "        cash_flow = stock.cash_flow\n",
        "\n",
        "        # Parse financials (most recent 3 years)\n",
        "        financials = {}\n",
        "\n",
        "        if not income_stmt.empty:\n",
        "            # Get most recent year\n",
        "            latest_col = income_stmt.columns[0]\n",
        "\n",
        "            financials['revenue'] = income_stmt.loc['Total Revenue', latest_col] if 'Total Revenue' in income_stmt.index else 0\n",
        "            financials['ebit'] = income_stmt.loc['EBIT', latest_col] if 'EBIT' in income_stmt.index else 0\n",
        "            financials['net_income'] = income_stmt.loc['Net Income', latest_col] if 'Net Income' in income_stmt.index else 0\n",
        "            financials['tax_expense'] = income_stmt.loc['Tax Provision', latest_col] if 'Tax Provision' in income_stmt.index else 0\n",
        "\n",
        "            # Calculate tax rate\n",
        "            if financials['ebit'] != 0:\n",
        "                financials['tax_rate'] = abs(financials['tax_expense'] / financials['ebit'])\n",
        "            else:\n",
        "                financials['tax_rate'] = 0.21  # Default US corporate tax rate\n",
        "\n",
        "        if not balance_sheet.empty:\n",
        "            latest_col = balance_sheet.columns[0]\n",
        "\n",
        "            financials['total_debt'] = balance_sheet.loc['Total Debt', latest_col] if 'Total Debt' in balance_sheet.index else 0\n",
        "            financials['cash'] = balance_sheet.loc['Cash And Cash Equivalents', latest_col] if 'Cash And Cash Equivalents' in balance_sheet.index else 0\n",
        "            financials['total_equity'] = balance_sheet.loc['Total Equity Gross Minority Interest', latest_col] if 'Total Equity Gross Minority Interest' in balance_sheet.index else 0\n",
        "\n",
        "        if not cash_flow.empty:\n",
        "            latest_col = cash_flow.columns[0]\n",
        "\n",
        "            financials['capex'] = abs(cash_flow.loc['Capital Expenditure', latest_col]) if 'Capital Expenditure' in cash_flow.index else 0\n",
        "            financials['depreciation'] = cash_flow.loc['Depreciation And Amortization', latest_col] if 'Depreciation And Amortization' in cash_flow.index else 0\n",
        "            financials['operating_cf'] = cash_flow.loc['Operating Cash Flow', latest_col] if 'Operating Cash Flow' in cash_flow.index else 0\n",
        "\n",
        "        # Calculate working capital change (simplified)\n",
        "        financials['change_wc'] = 0  # User can adjust\n",
        "\n",
        "        return {\n",
        "            'company': company_data,\n",
        "            'financials': financials,\n",
        "            'success': True\n",
        "        }\n",
        "\n",
        "    except Exception as e:\n",
        "        return {\n",
        "            'success': False,\n",
        "            'error': str(e)\n",
        "        }\n",
        "\n",
        "def calculate_smart_assumptions(company_data, financials):\n",
        "    \"\"\"\n",
        "    NEW: Calculate realistic, economically grounded assumptions\n",
        "    based on company fundamentals, sector averages, and economic reality\n",
        "    \"\"\"\n",
        "    sector = company_data.get('sector', 'Unknown')\n",
        "    revenue = financials.get('revenue', 0)\n",
        "    ebit = financials.get('ebit', 0)\n",
        "\n",
        "    # Smart revenue growth (based on sector and size)\n",
        "    sector_growth_rates = {\n",
        "        'Technology': 0.08,\n",
        "        'Healthcare': 0.06,\n",
        "        'Financial Services': 0.05,\n",
        "        'Consumer Cyclical': 0.04,\n",
        "        'Consumer Defensive': 0.03,\n",
        "        'Energy': 0.03,\n",
        "        'Industrials': 0.04,\n",
        "        'Basic Materials': 0.03,\n",
        "        'Real Estate': 0.03,\n",
        "        'Utilities': 0.02,\n",
        "        'Communication Services': 0.05,\n",
        "        'Unknown': 0.04\n",
        "    }\n",
        "\n",
        "    base_growth = sector_growth_rates.get(sector, 0.04)\n",
        "\n",
        "    # Adjust for company size (larger = slower growth)\n",
        "    market_cap = company_data.get('market_cap', 0)\n",
        "    if market_cap > 500e9:  # Mega cap\n",
        "        size_adjustment = -0.02\n",
        "    elif market_cap > 100e9:  # Large cap\n",
        "        size_adjustment = -0.01\n",
        "    elif market_cap > 10e9:  # Mid cap\n",
        "        size_adjustment = 0\n",
        "    else:  # Small cap\n",
        "        size_adjustment = 0.01\n",
        "\n",
        "    smart_revenue_growth = base_growth + size_adjustment\n",
        "\n",
        "    # Smart EBIT margin (sector averages)\n",
        "    sector_ebit_margins = {\n",
        "        'Technology': 0.25,\n",
        "        'Healthcare': 0.20,\n",
        "        'Financial Services': 0.30,\n",
        "        'Consumer Cyclical': 0.10,\n",
        "        'Consumer Defensive': 0.08,\n",
        "        'Energy': 0.15,\n",
        "        'Industrials': 0.12,\n",
        "        'Basic Materials': 0.15,\n",
        "        'Real Estate': 0.40,\n",
        "        'Utilities': 0.20,\n",
        "        'Communication Services': 0.18,\n",
        "        'Unknown': 0.15\n",
        "    }\n",
        "\n",
        "    smart_ebit_margin = sector_ebit_margins.get(sector, 0.15)\n",
        "\n",
        "    # Smart CapEx (as % of revenue, sector-based)\n",
        "    sector_capex_rates = {\n",
        "        'Technology': 0.03,\n",
        "        'Healthcare': 0.04,\n",
        "        'Financial Services': 0.02,\n",
        "        'Consumer Cyclical': 0.05,\n",
        "        'Consumer Defensive': 0.04,\n",
        "        'Energy': 0.12,\n",
        "        'Industrials': 0.06,\n",
        "        'Basic Materials': 0.10,\n",
        "        'Real Estate': 0.08,\n",
        "        'Utilities': 0.15,\n",
        "        'Communication Services': 0.07,\n",
        "        'Unknown': 0.05\n",
        "    }\n",
        "\n",
        "    smart_capex_pct = sector_capex_rates.get(sector, 0.05)\n",
        "\n",
        "    # Smart Depreciation (typically 60-80% of CapEx for mature companies)\n",
        "    smart_depreciation_pct = smart_capex_pct * 0.7\n",
        "\n",
        "    # Smart Terminal Growth (conservative)\n",
        "    smart_terminal_growth = 0.025  # Long-term GDP growth\n",
        "\n",
        "    # Smart Tax Rate (based on geography and sector)\n",
        "    smart_tax_rate = 0.21  # US corporate rate\n",
        "\n",
        "    return {\n",
        "        'revenue_growth': smart_revenue_growth,\n",
        "        'ebit_margin': smart_ebit_margin,\n",
        "        'capex_pct': smart_capex_pct,\n",
        "        'depreciation_pct': smart_depreciation_pct,\n",
        "        'terminal_growth': smart_terminal_growth,\n",
        "        'tax_rate': smart_tax_rate,\n",
        "        'wc_change': 0,  # Assume neutral\n",
        "        'forecast_years': 5\n",
        "    }\n",
        "\n",
        "def calculate_wacc(cost_equity, cost_debt, tax_rate, debt, equity):\n",
        "    \"\"\"Calculate Weighted Average Cost of Capital\"\"\"\n",
        "    total_value = debt + equity\n",
        "    if total_value == 0:\n",
        "        return cost_equity\n",
        "\n",
        "    weight_equity = equity / total_value\n",
        "    weight_debt = debt / total_value\n",
        "\n",
        "    wacc = (cost_equity * weight_equity) + (cost_debt * (1 - tax_rate) * weight_debt)\n",
        "    return wacc\n",
        "\n",
        "def calculate_cost_of_equity(risk_free_rate, beta, market_risk_premium):\n",
        "    \"\"\"Calculate Cost of Equity using CAPM\"\"\"\n",
        "    return risk_free_rate + (beta * market_risk_premium)\n",
        "\n",
        "def calculate_terminal_value(final_fcf, discount_rate, terminal_growth):\n",
        "    \"\"\"Calculate Terminal Value using Gordon Growth Model\"\"\"\n",
        "    if discount_rate <= terminal_growth:\n",
        "        return 0\n",
        "    return final_fcf * (1 + terminal_growth) / (discount_rate - terminal_growth)\n",
        "\n",
        "def project_fcff_enhanced(base_revenue, base_ebit, revenue_growth, ebit_margin, tax_rate,\n",
        "                         depreciation_pct, capex_pct, change_wc, forecast_years):\n",
        "    \"\"\"\n",
        "    ENHANCED: Project FCFF with D&A and CapEx scaling with revenue\n",
        "    \"\"\"\n",
        "    projections = []\n",
        "\n",
        "    current_revenue = base_revenue\n",
        "\n",
        "    for year in range(1, forecast_years + 1):\n",
        "        # Grow revenue\n",
        "        current_revenue = current_revenue * (1 + revenue_growth)\n",
        "\n",
        "        # Calculate EBIT based on margin\n",
        "        current_ebit = current_revenue * ebit_margin\n",
        "\n",
        "        # Calculate NOPAT\n",
        "        nopat = current_ebit * (1 - tax_rate)\n",
        "\n",
        "        # FIXED: Scale D&A and CapEx with revenue\n",
        "        depreciation = current_revenue * depreciation_pct\n",
        "        capex = current_revenue * capex_pct\n",
        "\n",
        "        # Calculate FCFF\n",
        "        fcff = nopat + depreciation - capex - change_wc\n",
        "\n",
        "        projections.append({\n",
        "            'year': year,\n",
        "            'revenue': current_revenue,\n",
        "            'ebit': current_ebit,\n",
        "            'nopat': nopat,\n",
        "            'depreciation': depreciation,\n",
        "            'capex': capex,\n",
        "            'change_wc': change_wc,\n",
        "            'fcff': fcff\n",
        "        })\n",
        "\n",
        "    return projections\n",
        "\n",
        "def project_fcfe_enhanced(base_revenue, base_net_income, revenue_growth, tax_rate,\n",
        "                         depreciation_pct, capex_pct, change_wc, net_borrowing, forecast_years):\n",
        "    \"\"\"\n",
        "    ENHANCED: Project FCFE with D&A and CapEx scaling with revenue\n",
        "    \"\"\"\n",
        "    projections = []\n",
        "\n",
        "    current_revenue = base_revenue\n",
        "    current_ni = base_net_income\n",
        "\n",
        "    # Calculate initial NI margin\n",
        "    ni_margin = current_ni / current_revenue if current_revenue > 0 else 0\n",
        "\n",
        "    for year in range(1, forecast_years + 1):\n",
        "        # Grow revenue\n",
        "        current_revenue = current_revenue * (1 + revenue_growth)\n",
        "\n",
        "        # Grow net income\n",
        "        current_ni = current_revenue * ni_margin\n",
        "\n",
        "        # FIXED: Scale D&A and CapEx with revenue\n",
        "        depreciation = current_revenue * depreciation_pct\n",
        "        capex = current_revenue * capex_pct\n",
        "\n",
        "        # Calculate FCFE\n",
        "        fcfe = current_ni + depreciation - capex - change_wc + net_borrowing\n",
        "\n",
        "        projections.append({\n",
        "            'year': year,\n",
        "            'revenue': current_revenue,\n",
        "            'net_income': current_ni,\n",
        "            'depreciation': depreciation,\n",
        "            'capex': capex,\n",
        "            'change_wc': change_wc,\n",
        "            'net_borrowing': net_borrowing,\n",
        "            'fcfe': fcfe\n",
        "        })\n",
        "\n",
        "    return projections\n",
        "\n",
        "def calculate_dcf_value(projections, discount_rate, terminal_value, shares_outstanding,\n",
        "                       net_debt=0, method='FCFF'):\n",
        "    \"\"\"Calculate DCF valuation\"\"\"\n",
        "    # Discount projected cash flows\n",
        "    pv_cash_flows = []\n",
        "    total_pv = 0\n",
        "\n",
        "    for proj in projections:\n",
        "        year = proj['year']\n",
        "        cf = proj['fcff'] if method == 'FCFF' else proj['fcfe']\n",
        "        pv = cf / ((1 + discount_rate) ** year)\n",
        "        pv_cash_flows.append(pv)\n",
        "        total_pv += pv\n",
        "\n",
        "    # Discount terminal value\n",
        "    pv_terminal = terminal_value / ((1 + discount_rate) ** len(projections))\n",
        "\n",
        "    # Calculate enterprise/equity value\n",
        "    enterprise_value = total_pv + pv_terminal\n",
        "\n",
        "    if method == 'FCFF':\n",
        "        # For FCFF, subtract net debt to get equity value\n",
        "        equity_value = enterprise_value - net_debt\n",
        "    else:\n",
        "        # For FCFE, enterprise value IS equity value\n",
        "        equity_value = enterprise_value\n",
        "\n",
        "    # Calculate per share value\n",
        "    intrinsic_value_per_share = equity_value / shares_outstanding if shares_outstanding > 0 else 0\n",
        "\n",
        "    return {\n",
        "        'pv_cash_flows': pv_cash_flows,\n",
        "        'total_pv_cash_flows': total_pv,\n",
        "        'terminal_value': terminal_value,\n",
        "        'pv_terminal': pv_terminal,\n",
        "        'enterprise_value': enterprise_value,\n",
        "        'equity_value': equity_value,\n",
        "        'intrinsic_value_per_share': intrinsic_value_per_share\n",
        "    }\n",
        "\n",
        "# ============================================================================\n",
        "# PHOENIX PARSER\n",
        "# ============================================================================\n",
        "\n",
        "def parse_trade_history_file(uploaded_file):\n",
        "    try:\n",
        "        df = pd.read_html(uploaded_file)[0]\n",
        "        required_cols = ['Date', 'Symbol', 'Trade Type', 'Quantity', 'Price']\n",
        "        if not all(col in df.columns for col in required_cols):\n",
        "            return None\n",
        "        df['Price'] = df['Price'].astype(str).str.replace('$', '').str.replace(',', '').astype(float)\n",
        "        df['Date'] = pd.to_datetime(df['Date'])\n",
        "        df = df.sort_values('Date')\n",
        "        return df\n",
        "    except:\n",
        "        return None\n",
        "\n",
        "def parse_account_history_file(uploaded_file):\n",
        "    try:\n",
        "        df = pd.read_html(uploaded_file)[0]\n",
        "        df['Date'] = pd.to_datetime(df['Date'])\n",
        "        df = df.sort_values('Date')\n",
        "        return df\n",
        "    except:\n",
        "        return None\n",
        "\n",
        "def calculate_portfolio_from_trades(trade_df):\n",
        "    holdings = {}\n",
        "    for _, row in trade_df.iterrows():\n",
        "        symbol = row['Symbol']\n",
        "        trade_type = row['Trade Type']\n",
        "        quantity = row['Quantity']\n",
        "        price = row['Price']\n",
        "\n",
        "        if is_option_ticker(symbol):\n",
        "            continue\n",
        "\n",
        "        if symbol not in holdings:\n",
        "            holdings[symbol] = {'total_shares': 0, 'total_cost': 0, 'trades': []}\n",
        "\n",
        "        is_buy = 'Buy' in trade_type\n",
        "\n",
        "        if is_buy:\n",
        "            holdings[symbol]['total_shares'] += quantity\n",
        "            holdings[symbol]['total_cost'] += (quantity * price)\n",
        "            holdings[symbol]['trades'].append({'type': 'BUY', 'quantity': quantity, 'price': price})\n",
        "        else:\n",
        "            remaining_to_sell = quantity\n",
        "            for trade in holdings[symbol]['trades']:\n",
        "                if trade['type'] == 'BUY' and remaining_to_sell > 0:\n",
        "                    if trade['quantity'] <= remaining_to_sell:\n",
        "                        holdings[symbol]['total_cost'] -= (trade['quantity'] * trade['price'])\n",
        "                        holdings[symbol]['total_shares'] -= trade['quantity']\n",
        "                        remaining_to_sell -= trade['quantity']\n",
        "                        trade['quantity'] = 0\n",
        "                    else:\n",
        "                        holdings[symbol]['total_cost'] -= (remaining_to_sell * trade['price'])\n",
        "                        holdings[symbol]['total_shares'] -= remaining_to_sell\n",
        "                        trade['quantity'] -= remaining_to_sell\n",
        "                        remaining_to_sell = 0\n",
        "\n",
        "    portfolio_data = []\n",
        "    for symbol, data in holdings.items():\n",
        "        if data['total_shares'] > 0:\n",
        "            avg_cost = data['total_cost'] / data['total_shares']\n",
        "            portfolio_data.append({\n",
        "                'Ticker': symbol,\n",
        "                'Shares': data['total_shares'],\n",
        "                'Avg Cost': avg_cost\n",
        "            })\n",
        "\n",
        "    if not portfolio_data:\n",
        "        return pd.DataFrame(columns=['Ticker', 'Shares', 'Avg Cost'])\n",
        "    return pd.DataFrame(portfolio_data).sort_values('Ticker')\n",
        "\n",
        "# ============================================================================\n",
        "# PORTFOLIO CALCULATIONS\n",
        "# ============================================================================\n",
        "\n",
        "@st.cache_data(ttl=600)\n",
        "def calculate_portfolio_returns(df, start_date, end_date):\n",
        "    try:\n",
        "        valid_positions = []\n",
        "        for _, row in df.iterrows():\n",
        "            if not is_option_ticker(row['Ticker']):\n",
        "                valid_positions.append(row)\n",
        "\n",
        "        if not valid_positions:\n",
        "            return None\n",
        "\n",
        "        valid_df = pd.DataFrame(valid_positions)\n",
        "        all_data = {}\n",
        "\n",
        "        for _, row in valid_df.iterrows():\n",
        "            ticker = row['Ticker']\n",
        "            data = fetch_historical_data(ticker, start_date, end_date)\n",
        "            if data is not None and len(data) > 0:\n",
        "                all_data[ticker] = data\n",
        "\n",
        "        if not all_data:\n",
        "            return None\n",
        "\n",
        "        common_dates = None\n",
        "        for ticker, data in all_data.items():\n",
        "            dates = set(data.index)\n",
        "            common_dates = dates if common_dates is None else common_dates.intersection(dates)\n",
        "\n",
        "        common_dates = sorted(list(common_dates))\n",
        "        if len(common_dates) < 2:\n",
        "            return None\n",
        "\n",
        "        portfolio_values = []\n",
        "        for date in common_dates:\n",
        "            daily_value = 0\n",
        "            for _, row in valid_df.iterrows():\n",
        "                ticker = row['Ticker']\n",
        "                if ticker in all_data:\n",
        "                    try:\n",
        "                        price = all_data[ticker].loc[date, 'Close']\n",
        "                        daily_value += price * row['Shares']\n",
        "                    except KeyError:\n",
        "                        continue\n",
        "            portfolio_values.append(daily_value)\n",
        "\n",
        "        portfolio_series = pd.Series(portfolio_values, index=common_dates)\n",
        "        returns = portfolio_series.pct_change().dropna()\n",
        "        return returns\n",
        "    except:\n",
        "        return None\n",
        "\n",
        "@st.cache_data(ttl=600)\n",
        "def calculate_benchmark_returns(benchmark_ticker, start_date, end_date):\n",
        "    try:\n",
        "        data = fetch_historical_data(benchmark_ticker, start_date, end_date)\n",
        "        if data is None or data.empty:\n",
        "            return None\n",
        "        returns = data['Close'].pct_change().dropna()\n",
        "        return returns\n",
        "    except:\n",
        "        return None\n",
        "\n",
        "# ============================================================================\n",
        "# ENHANCED HOLDINGS TABLE\n",
        "# ============================================================================\n",
        "\n",
        "def create_enhanced_holdings_table(df):\n",
        "    enhanced_df = df.copy()\n",
        "\n",
        "    for idx, row in enhanced_df.iterrows():\n",
        "        ticker = row['Ticker']\n",
        "        market_data = fetch_market_data(ticker)\n",
        "\n",
        "        if market_data:\n",
        "            enhanced_df.at[idx, 'Asset Name'] = market_data['company_name']\n",
        "            enhanced_df.at[idx, 'Current Price'] = market_data['price']\n",
        "            enhanced_df.at[idx, 'Daily Change'] = market_data['daily_change']\n",
        "            enhanced_df.at[idx, 'Daily Change %'] = market_data['daily_change_pct']\n",
        "            enhanced_df.at[idx, '5D Return %'] = market_data['five_day_return']\n",
        "            enhanced_df.at[idx, 'Beta'] = market_data.get('beta', 'N/A')\n",
        "            enhanced_df.at[idx, 'Volume'] = market_data.get('volume', 0)\n",
        "            base_sector = market_data.get('sector', 'Unknown')\n",
        "            enhanced_df.at[idx, 'Sector'] = classify_ticker_sector(ticker, base_sector)\n",
        "        else:\n",
        "            enhanced_df.at[idx, 'Asset Name'] = ticker\n",
        "            enhanced_df.at[idx, 'Sector'] = 'Other'\n",
        "\n",
        "        analyst_data = fetch_analyst_data(ticker)\n",
        "        if analyst_data['success']:\n",
        "            enhanced_df.at[idx, 'Analyst Rating'] = analyst_data['rating']\n",
        "            enhanced_df.at[idx, 'Price Target'] = analyst_data['target_price']\n",
        "        else:\n",
        "            enhanced_df.at[idx, 'Analyst Rating'] = 'No Coverage'\n",
        "\n",
        "    enhanced_df['Sector'] = enhanced_df['Sector'].fillna('Other')\n",
        "    enhanced_df['Shares'] = enhanced_df['Shares'].round(0).astype(int)\n",
        "\n",
        "    enhanced_df['Total Cost'] = enhanced_df['Shares'] * enhanced_df['Avg Cost']\n",
        "    enhanced_df['Total Value'] = enhanced_df['Shares'] * enhanced_df['Current Price']\n",
        "    enhanced_df['Total Gain/Loss $'] = enhanced_df['Total Value'] - enhanced_df['Total Cost']\n",
        "    enhanced_df['Total Gain/Loss %'] = ((enhanced_df['Current Price'] - enhanced_df['Avg Cost']) / enhanced_df['Avg Cost']) * 100\n",
        "    enhanced_df['Daily P&L $'] = enhanced_df['Shares'] * enhanced_df['Daily Change']\n",
        "\n",
        "    total_value = enhanced_df['Total Value'].sum()\n",
        "    enhanced_df['Weight %'] = (enhanced_df['Total Value'] / total_value * 100) if total_value > 0 else 0\n",
        "\n",
        "    return enhanced_df\n",
        "\n",
        "def style_holdings_dataframe(df):\n",
        "    display_df = df[[\n",
        "        'Ticker', 'Asset Name', 'Shares', 'Avg Cost', 'Current Price',\n",
        "        'Daily Change %', '5D Return %', 'Weight %', 'Daily P&L $',\n",
        "        'Total Gain/Loss $', 'Total Gain/Loss %', 'Beta', 'Analyst Rating'\n",
        "    ]].copy()\n",
        "\n",
        "    pct_cols = ['Daily Change %', '5D Return %', 'Weight %', 'Total Gain/Loss %']\n",
        "    for col in pct_cols:\n",
        "        display_df[col] = display_df[col].apply(lambda x: format_percentage(x))\n",
        "\n",
        "    currency_cols = ['Avg Cost', 'Current Price', 'Daily P&L $', 'Total Gain/Loss $']\n",
        "    for col in currency_cols:\n",
        "        display_df[col] = display_df[col].apply(format_currency)\n",
        "\n",
        "    display_df['Daily Change %'] = display_df['Daily Change %'].apply(add_arrow_indicator)\n",
        "    display_df['Total Gain/Loss %'] = display_df['Total Gain/Loss %'].apply(add_arrow_indicator)\n",
        "\n",
        "    return display_df\n",
        "\n",
        "# ============================================================================\n",
        "# RISK METRICS\n",
        "# ============================================================================\n",
        "\n",
        "def calculate_sharpe_ratio(returns, risk_free_rate=RISK_FREE_RATE):\n",
        "    if not is_valid_series(returns) or len(returns) < 2:\n",
        "        return None\n",
        "    total_return = (1 + returns).prod() - 1\n",
        "    n_years = len(returns) / 252\n",
        "    annualized_return = (1 + total_return) ** (1/n_years) - 1 if n_years > 0 else 0\n",
        "    annualized_vol = returns.std() * np.sqrt(252)\n",
        "    sharpe = (annualized_return - risk_free_rate) / annualized_vol if annualized_vol > 0 else 0\n",
        "    return sharpe\n",
        "\n",
        "def calculate_sortino_ratio(returns, risk_free_rate=RISK_FREE_RATE):\n",
        "    if not is_valid_series(returns) or len(returns) < 2:\n",
        "        return None\n",
        "    total_return = (1 + returns).prod() - 1\n",
        "    n_years = len(returns) / 252\n",
        "    annualized_return = (1 + total_return) ** (1/n_years) - 1 if n_years > 0 else 0\n",
        "    downside_returns = returns[returns < 0]\n",
        "    if len(downside_returns) < 2:\n",
        "        return None\n",
        "    downside_std = downside_returns.std() * np.sqrt(252)\n",
        "    sortino = (annualized_return - risk_free_rate) / downside_std if downside_std > 0 else 0\n",
        "    return sortino\n",
        "\n",
        "def calculate_information_ratio(portfolio_returns, benchmark_returns):\n",
        "    if not is_valid_series(portfolio_returns) or not is_valid_series(benchmark_returns):\n",
        "        return None\n",
        "    if len(portfolio_returns) < 2 or len(benchmark_returns) < 2:\n",
        "        return None\n",
        "    common_dates = portfolio_returns.index.intersection(benchmark_returns.index)\n",
        "    portfolio_returns = portfolio_returns.loc[common_dates]\n",
        "    benchmark_returns = benchmark_returns.loc[common_dates]\n",
        "    excess_returns = portfolio_returns - benchmark_returns\n",
        "    if len(excess_returns) < 2:\n",
        "        return None\n",
        "    total_excess = (1 + excess_returns).prod() - 1\n",
        "    n_years = len(excess_returns) / 252\n",
        "    annualized_excess = (1 + total_excess) ** (1/n_years) - 1 if n_years > 0 else 0\n",
        "    tracking_error = excess_returns.std() * np.sqrt(252)\n",
        "    info_ratio = annualized_excess / tracking_error if tracking_error > 0 else 0\n",
        "    return info_ratio\n",
        "\n",
        "def calculate_var(returns, confidence=0.95):\n",
        "    if not is_valid_series(returns) or len(returns) < 2:\n",
        "        return None\n",
        "    var = np.percentile(returns, (1 - confidence) * 100)\n",
        "    return var * 100\n",
        "\n",
        "def calculate_cvar(returns, confidence=0.95):\n",
        "    if not is_valid_series(returns) or len(returns) < 2:\n",
        "        return None\n",
        "    var = np.percentile(returns, (1 - confidence) * 100)\n",
        "    cvar = returns[returns <= var].mean()\n",
        "    return cvar * 100\n",
        "\n",
        "def calculate_max_drawdown(returns):\n",
        "    if not is_valid_series(returns) or len(returns) < 2:\n",
        "        return None\n",
        "    cumulative = (1 + returns).cumprod()\n",
        "    running_max = cumulative.expanding().max()\n",
        "    drawdown = (cumulative - running_max) / running_max\n",
        "    return drawdown.min() * 100\n",
        "\n",
        "def calculate_calmar_ratio(returns, risk_free_rate=RISK_FREE_RATE):\n",
        "    if not is_valid_series(returns) or len(returns) < 2:\n",
        "        return None\n",
        "    total_return = (1 + returns).prod() - 1\n",
        "    n_years = len(returns) / 252\n",
        "    annualized_return = (1 + total_return) ** (1/n_years) - 1 if n_years > 0 else 0\n",
        "    max_dd = abs(calculate_max_drawdown(returns))\n",
        "    if max_dd == 0:\n",
        "        return 0\n",
        "    return (annualized_return - risk_free_rate) / (max_dd / 100)\n",
        "\n",
        "# ============================================================================\n",
        "# CONTINUING IN PART 2...\n",
        "# ============================================================================\n",
        "# Part 2 will contain all visualizations and page implementations\n",
        "# Save this file and paste Part 2 below it!\n",
        "\n",
        "\n",
        "\n",
        "# ============================================================================\n",
        "# WORLD-CLASS VISUALIZATIONS - ENHANCED WITH SEAMLESS THEMING\n",
        "# ============================================================================\n",
        "\n",
        "def create_top_contributors_chart(df, top_n=5):\n",
        "    \"\"\"NEW: Top contributors visualization for Home Page\"\"\"\n",
        "    top_contributors = df.nlargest(top_n, 'Total Gain/Loss $')[['Ticker', 'Asset Name', 'Total Gain/Loss $', 'Total Gain/Loss %']]\n",
        "\n",
        "    fig = go.Figure()\n",
        "\n",
        "    fig.add_trace(go.Bar(\n",
        "        x=top_contributors['Total Gain/Loss $'],\n",
        "        y=top_contributors['Ticker'],\n",
        "        orientation='h',\n",
        "        marker=dict(\n",
        "            color=top_contributors['Total Gain/Loss $'],\n",
        "            colorscale=[[0, COLORS['success']], [1, COLORS['success']]],\n",
        "            line=dict(color=COLORS['border'], width=2)\n",
        "        ),\n",
        "        text=[f\"${x:,.0f}\" for x in top_contributors['Total Gain/Loss $']],\n",
        "        textposition='auto',\n",
        "        hovertemplate='<b>%{y}</b><br>P&L: %{text}<extra></extra>'\n",
        "    ))\n",
        "\n",
        "    fig.update_layout(\n",
        "        title=\"üéØ Top 5 Contributors\",\n",
        "        xaxis_title=\"Total Gain ($)\",\n",
        "        yaxis_title=\"\",\n",
        "        height=400,\n",
        "        showlegend=False\n",
        "    )\n",
        "\n",
        "    apply_chart_theme(fig)\n",
        "    return fig\n",
        "\n",
        "def create_top_detractors_chart(df, top_n=5):\n",
        "    \"\"\"NEW: Top detractors visualization for Home Page\"\"\"\n",
        "    top_detractors = df.nsmallest(top_n, 'Total Gain/Loss $')[['Ticker', 'Asset Name', 'Total Gain/Loss $', 'Total Gain/Loss %']]\n",
        "\n",
        "    fig = go.Figure()\n",
        "\n",
        "    fig.add_trace(go.Bar(\n",
        "        x=top_detractors['Total Gain/Loss $'],\n",
        "        y=top_detractors['Ticker'],\n",
        "        orientation='h',\n",
        "        marker=dict(\n",
        "            color=top_detractors['Total Gain/Loss $'],\n",
        "            colorscale=[[0, COLORS['danger']], [1, COLORS['danger']]],\n",
        "            line=dict(color=COLORS['border'], width=2)\n",
        "        ),\n",
        "        text=[f\"${x:,.0f}\" for x in top_detractors['Total Gain/Loss $']],\n",
        "        textposition='auto',\n",
        "        hovertemplate='<b>%{y}</b><br>P&L: %{text}<extra></extra>'\n",
        "    ))\n",
        "\n",
        "    fig.update_layout(\n",
        "        title=\"‚ö†Ô∏è Top 5 Detractors\",\n",
        "        xaxis_title=\"Total Loss ($)\",\n",
        "        yaxis_title=\"\",\n",
        "        height=400,\n",
        "        showlegend=False\n",
        "    )\n",
        "\n",
        "    apply_chart_theme(fig)\n",
        "    return fig\n",
        "\n",
        "def create_sector_allocation_donut(df):\n",
        "    \"\"\"NEW: Sector allocation donut chart for Home Page\"\"\"\n",
        "    sector_allocation = df.groupby('Sector')['Total Value'].sum().reset_index()\n",
        "    sector_allocation = sector_allocation.sort_values('Total Value', ascending=False)\n",
        "\n",
        "    fig = go.Figure(data=[go.Pie(\n",
        "        labels=sector_allocation['Sector'],\n",
        "        values=sector_allocation['Total Value'],\n",
        "        hole=0.5,\n",
        "        marker=dict(\n",
        "            colors=px.colors.qualitative.Set3,\n",
        "            line=dict(color=COLORS['border'], width=2)\n",
        "        ),\n",
        "        textinfo='label+percent',\n",
        "        textfont=dict(size=12)\n",
        "    )])\n",
        "\n",
        "    fig.update_layout(\n",
        "        title=\"üìä Sector Allocation\",\n",
        "        height=400,\n",
        "        showlegend=True,\n",
        "        legend=dict(x=0.85, y=0.5)\n",
        "    )\n",
        "\n",
        "    apply_chart_theme(fig)\n",
        "    return fig\n",
        "\n",
        "def create_rolling_metrics_chart(returns, window=60):\n",
        "    \"\"\"Rolling metrics visualization - ENHANCED THEMING\"\"\"\n",
        "    if not is_valid_series(returns) or len(returns) < window:\n",
        "        return None\n",
        "\n",
        "    rolling_vol = returns.rolling(window).std() * np.sqrt(252) * 100\n",
        "    rolling_sharpe = (returns.rolling(window).mean() * 252 - RISK_FREE_RATE) / (returns.rolling(window).std() * np.sqrt(252))\n",
        "\n",
        "    fig = make_subplots(\n",
        "        rows=2, cols=1,\n",
        "        subplot_titles=('Rolling Volatility (60-Day)', 'Rolling Sharpe Ratio (60-Day)'),\n",
        "        vertical_spacing=0.15\n",
        "    )\n",
        "\n",
        "    fig.add_trace(\n",
        "        go.Scatter(\n",
        "            x=rolling_vol.index,\n",
        "            y=rolling_vol.values,\n",
        "            fill='tozeroy',\n",
        "            fillcolor='rgba(255, 0, 68, 0.2)',\n",
        "            line=dict(color=COLORS['danger'], width=2),\n",
        "            name='Volatility'\n",
        "        ),\n",
        "        row=1, col=1\n",
        "    )\n",
        "\n",
        "    fig.add_trace(\n",
        "        go.Scatter(\n",
        "            x=rolling_sharpe.index,\n",
        "            y=rolling_sharpe.values,\n",
        "            fill='tozeroy',\n",
        "            fillcolor='rgba(0, 212, 255, 0.2)',\n",
        "            line=dict(color=COLORS['neon_blue'], width=2),\n",
        "            name='Sharpe Ratio'\n",
        "        ),\n",
        "        row=2, col=1\n",
        "    )\n",
        "\n",
        "    fig.add_hline(y=0, line_dash=\"dash\", line_color=COLORS['text_muted'], row=2, col=1)\n",
        "\n",
        "    fig.update_layout(\n",
        "        height=600,\n",
        "        showlegend=False,\n",
        "        title_text=\"üìä Rolling Risk Metrics\"\n",
        "    )\n",
        "\n",
        "    apply_chart_theme(fig)\n",
        "    return fig\n",
        "\n",
        "def create_underwater_plot(returns):\n",
        "    \"\"\"Underwater drawdown plot - ENHANCED THEMING\"\"\"\n",
        "    if not is_valid_series(returns) or len(returns) < 2:\n",
        "        return None\n",
        "\n",
        "    cumulative = (1 + returns).cumprod()\n",
        "    running_max = cumulative.expanding().max()\n",
        "    drawdown = ((cumulative - running_max) / running_max) * 100\n",
        "\n",
        "    fig = go.Figure()\n",
        "\n",
        "    fig.add_trace(go.Scatter(\n",
        "        x=drawdown.index,\n",
        "        y=drawdown.values,\n",
        "        fill='tozeroy',\n",
        "        fillcolor='rgba(255, 0, 68, 0.3)',\n",
        "        line=dict(color=COLORS['danger'], width=2),\n",
        "        name='Drawdown'\n",
        "    ))\n",
        "\n",
        "    fig.add_hline(y=0, line_dash=\"solid\", line_color=COLORS['text_primary'], line_width=1)\n",
        "\n",
        "    max_dd_idx = drawdown.idxmin()\n",
        "    max_dd_val = drawdown.min()\n",
        "\n",
        "    fig.add_annotation(\n",
        "        x=max_dd_idx,\n",
        "        y=max_dd_val,\n",
        "        text=f\"Max DD: {max_dd_val:.2f}%\",\n",
        "        showarrow=True,\n",
        "        arrowhead=2,\n",
        "        arrowcolor=COLORS['danger'],\n",
        "        ax=0,\n",
        "        ay=-40,\n",
        "        bgcolor=COLORS['card_background'],\n",
        "        bordercolor=COLORS['danger'],\n",
        "        borderwidth=2\n",
        "    )\n",
        "\n",
        "    fig.update_layout(\n",
        "        title=\"üåä Underwater Plot\",\n",
        "        xaxis_title=\"Date\",\n",
        "        yaxis_title=\"Drawdown (%)\",\n",
        "        height=500\n",
        "    )\n",
        "\n",
        "    apply_chart_theme(fig)\n",
        "    return fig\n",
        "\n",
        "def create_var_waterfall(returns):\n",
        "    \"\"\"VaR/CVaR waterfall chart - ENHANCED THEMING\"\"\"\n",
        "    if not is_valid_series(returns) or len(returns) < 2:\n",
        "        return None\n",
        "\n",
        "    var_90 = calculate_var(returns, 0.90)\n",
        "    var_95 = calculate_var(returns, 0.95)\n",
        "    var_99 = calculate_var(returns, 0.99)\n",
        "    cvar_95 = calculate_cvar(returns, 0.95)\n",
        "\n",
        "    categories = ['VaR 90%', 'VaR 95%', 'VaR 99%', 'CVaR 95%']\n",
        "    values = [var_90, var_95, var_99, cvar_95]\n",
        "\n",
        "    colors_list = [COLORS['warning'], COLORS['orange'], COLORS['danger'], COLORS['danger']]\n",
        "\n",
        "    fig = go.Figure()\n",
        "\n",
        "    fig.add_trace(go.Bar(\n",
        "        x=categories,\n",
        "        y=values,\n",
        "        marker=dict(\n",
        "            color=colors_list,\n",
        "            line=dict(color=COLORS['border'], width=2)\n",
        "        ),\n",
        "        text=[f\"{v:.2f}%\" for v in values],\n",
        "        textposition='outside'\n",
        "    ))\n",
        "\n",
        "    fig.update_layout(\n",
        "        title=\"‚ö†Ô∏è Value at Risk Waterfall\",\n",
        "        xaxis_title=\"Risk Measure\",\n",
        "        yaxis_title=\"Expected Loss (%)\",\n",
        "        height=500\n",
        "    )\n",
        "\n",
        "    apply_chart_theme(fig)\n",
        "    return fig\n",
        "\n",
        "def create_risk_contribution_sunburst(df):\n",
        "    \"\"\"Risk contribution sunburst - ENHANCED THEMING\"\"\"\n",
        "    risk_data = []\n",
        "\n",
        "    for _, row in df.iterrows():\n",
        "        ticker = row['Ticker']\n",
        "        weight = row['Weight %']\n",
        "        sector = row['Sector']\n",
        "\n",
        "        hist_data = fetch_historical_data(ticker, datetime.now() - timedelta(days=365), datetime.now())\n",
        "        if hist_data is not None and len(hist_data) > 30:\n",
        "            returns = hist_data['Close'].pct_change().dropna()\n",
        "            vol = returns.std() * np.sqrt(252) * 100\n",
        "            risk_contribution = weight * vol\n",
        "\n",
        "            risk_data.append({\n",
        "                'Ticker': ticker,\n",
        "                'Sector': sector,\n",
        "                'Weight': weight,\n",
        "                'Volatility': vol,\n",
        "                'Risk Contribution': risk_contribution\n",
        "            })\n",
        "\n",
        "    if not risk_data:\n",
        "        return None\n",
        "\n",
        "    risk_df = pd.DataFrame(risk_data)\n",
        "\n",
        "    fig = px.sunburst(\n",
        "        risk_df,\n",
        "        path=['Sector', 'Ticker'],\n",
        "        values='Risk Contribution',\n",
        "        color='Volatility',\n",
        "        color_continuous_scale='RdYlGn_r',\n",
        "        title=\"‚òÄÔ∏è Risk Contribution Sunburst\"\n",
        "    )\n",
        "\n",
        "    fig.update_layout(height=600)\n",
        "    apply_chart_theme(fig)\n",
        "    return fig\n",
        "\n",
        "def create_risk_reward_plot(df):\n",
        "    \"\"\"Risk-reward scatter plot - ENHANCED THEMING\"\"\"\n",
        "    risk_reward_data = []\n",
        "\n",
        "    for _, row in df.iterrows():\n",
        "        ticker = row['Ticker']\n",
        "        hist_data = fetch_historical_data(ticker, datetime.now() - timedelta(days=365), datetime.now())\n",
        "\n",
        "        if hist_data is not None and len(hist_data) > 30:\n",
        "            returns = hist_data['Close'].pct_change().dropna()\n",
        "            annual_return = ((1 + returns.mean()) ** 252 - 1) * 100\n",
        "            annual_vol = returns.std() * np.sqrt(252) * 100\n",
        "\n",
        "            risk_reward_data.append({\n",
        "                'Ticker': ticker,\n",
        "                'Asset Name': row['Asset Name'],\n",
        "                'Return': annual_return,\n",
        "                'Risk': annual_vol,\n",
        "                'Weight': row['Weight %'],\n",
        "                'Sector': row['Sector']\n",
        "            })\n",
        "\n",
        "    if not risk_reward_data:\n",
        "        return None\n",
        "\n",
        "    rr_df = pd.DataFrame(risk_reward_data)\n",
        "\n",
        "    fig = px.scatter(\n",
        "        rr_df,\n",
        "        x='Risk',\n",
        "        y='Return',\n",
        "        size='Weight',\n",
        "        color='Sector',\n",
        "        text='Ticker',\n",
        "        hover_data=['Asset Name'],\n",
        "        color_discrete_sequence=px.colors.qualitative.Set3\n",
        "    )\n",
        "\n",
        "    fig.update_traces(\n",
        "        textposition='top center',\n",
        "        marker=dict(line=dict(width=2, color=COLORS['border']))\n",
        "    )\n",
        "\n",
        "    fig.update_layout(\n",
        "        title=\"üìà Risk-Reward Analysis\",\n",
        "        xaxis_title=\"Risk (Annual Volatility %)\",\n",
        "        yaxis_title=\"Expected Return (Annual %)\",\n",
        "        height=500\n",
        "    )\n",
        "\n",
        "    apply_chart_theme(fig)\n",
        "    return fig\n",
        "\n",
        "def create_performance_heatmap(df, period='monthly'):\n",
        "    \"\"\"Performance heatmap - ENHANCED THEMING & FIXED NOV 2024\"\"\"\n",
        "    try:\n",
        "        portfolio_values = {}\n",
        "\n",
        "        end_date = datetime.now()\n",
        "        start_date = end_date - timedelta(days=365)\n",
        "\n",
        "        for _, row in df.iterrows():\n",
        "            ticker = row['Ticker']\n",
        "            hist_data = fetch_historical_data(ticker, start_date, end_date)\n",
        "\n",
        "            if hist_data is not None and len(hist_data) > 0:\n",
        "                monthly_data = hist_data['Close'].resample('M').last()\n",
        "                monthly_returns = monthly_data.pct_change() * 100\n",
        "\n",
        "                for month, ret in monthly_returns.items():\n",
        "                    # FIXED: Skip current incomplete month\n",
        "                    if month.month == end_date.month and month.year == end_date.year:\n",
        "                        continue\n",
        "                    month_str = month.strftime('%b %Y')\n",
        "                    if month_str not in portfolio_values:\n",
        "                        portfolio_values[month_str] = {}\n",
        "                    if pd.notna(ret) and abs(ret) < 50:\n",
        "                        portfolio_values[month_str][ticker] = ret\n",
        "\n",
        "        if not portfolio_values:\n",
        "            return None\n",
        "\n",
        "        tickers = sorted(set(t for months in portfolio_values.values() for t in months))\n",
        "        months = sorted(portfolio_values.keys(), key=lambda x: datetime.strptime(x, '%b %Y'))\n",
        "\n",
        "        # FIXED: Remove current incomplete month\n",
        "        months = [m for m in months if datetime.strptime(m, '%b %Y') < end_date.replace(day=1)]\n",
        "\n",
        "        matrix = []\n",
        "        for ticker in tickers:\n",
        "            row = []\n",
        "            for month in months:\n",
        "                if ticker in portfolio_values[month]:\n",
        "                    val = portfolio_values[month][ticker]\n",
        "                    val = max(-50, min(50, val))\n",
        "                    row.append(val)\n",
        "                else:\n",
        "                    row.append(0)\n",
        "            matrix.append(row)\n",
        "\n",
        "        fig = go.Figure(data=go.Heatmap(\n",
        "            z=matrix,\n",
        "            x=months,\n",
        "            y=tickers,\n",
        "            colorscale='RdYlGn',\n",
        "            zmid=0,\n",
        "            zmin=-20,\n",
        "            zmax=20,\n",
        "            text=np.round(matrix, 1),\n",
        "            texttemplate='%{text}%',\n",
        "            textfont={\"size\": 14},\n",
        "            colorbar=dict(title=\"Return %\")\n",
        "        ))\n",
        "\n",
        "        fig.update_layout(\n",
        "            title=\"üî• Monthly Performance Heatmap\",\n",
        "            xaxis_title=\"Month\",\n",
        "            yaxis_title=\"Asset\",\n",
        "            height=800,\n",
        "            width=1200\n",
        "        )\n",
        "\n",
        "        apply_chart_theme(fig)\n",
        "        return fig\n",
        "    except Exception as e:\n",
        "        st.error(f\"Error: {str(e)}\")\n",
        "        return None\n",
        "\n",
        "def create_portfolio_heatmap(df):\n",
        "    \"\"\"Portfolio treemap - ENHANCED THEMING\"\"\"\n",
        "    df_viz = df[['Ticker', 'Asset Name', 'Weight %', 'Total Gain/Loss %', 'Sector']].copy()\n",
        "    df_viz['Sector'] = df_viz['Sector'].fillna('Other')\n",
        "    df_viz = df_viz.dropna()\n",
        "\n",
        "    if df_viz.empty:\n",
        "        return None\n",
        "\n",
        "    fig = px.treemap(\n",
        "        df_viz,\n",
        "        path=[px.Constant(\"Portfolio\"), 'Sector', 'Ticker'],\n",
        "        values='Weight %',\n",
        "        color='Total Gain/Loss %',\n",
        "        color_continuous_scale='RdYlGn',\n",
        "        color_continuous_midpoint=0,\n",
        "        hover_data={'Asset Name': True, 'Total Gain/Loss %': ':.2f'}\n",
        "    )\n",
        "\n",
        "    fig.update_layout(\n",
        "        title=\"üó∫Ô∏è Portfolio Heatmap\",\n",
        "        height=700\n",
        "    )\n",
        "\n",
        "    apply_chart_theme(fig)\n",
        "    return fig\n",
        "\n",
        "@st.cache_data(ttl=600)\n",
        "def fetch_ticker_performance(ticker, start_date, end_date):\n",
        "    try:\n",
        "        data = fetch_historical_data(ticker, start_date, end_date)\n",
        "        if data is not None and not data.empty:\n",
        "            returns = data['Close'].pct_change().fillna(0)\n",
        "            cumulative = (1 + returns).cumprod() - 1\n",
        "            return cumulative * 100, data\n",
        "        return None, None\n",
        "    except:\n",
        "        return None, None\n",
        "\n",
        "def create_interactive_performance_chart(tickers, start_date, end_date):\n",
        "    \"\"\"Interactive performance chart - ENHANCED THEMING\"\"\"\n",
        "    fig = go.Figure()\n",
        "\n",
        "    colors = [COLORS['neon_blue'], COLORS['electric_blue'], COLORS['teal'],\n",
        "              COLORS['success'], COLORS['warning'], COLORS['danger'],\n",
        "              COLORS['purple'], COLORS['pink'], COLORS['orange']]\n",
        "\n",
        "    for idx, ticker in enumerate(tickers):\n",
        "        cumulative, data = fetch_ticker_performance(ticker, start_date, end_date)\n",
        "        if cumulative is not None:\n",
        "            fig.add_trace(go.Scatter(\n",
        "                x=cumulative.index,\n",
        "                y=cumulative.values,\n",
        "                mode='lines',\n",
        "                name=ticker,\n",
        "                line=dict(width=2.5, color=colors[idx % len(colors)])\n",
        "            ))\n",
        "\n",
        "    if not fig.data:\n",
        "        return None\n",
        "\n",
        "    fig.update_layout(\n",
        "        title=\"üìà Interactive Performance Comparison\",\n",
        "        xaxis_title=\"Date\",\n",
        "        yaxis_title=\"Cumulative Return (%)\",\n",
        "        height=600,\n",
        "        hovermode='x unified',\n",
        "        legend=dict(x=0.01, y=0.99)\n",
        "    )\n",
        "\n",
        "    fig.add_hline(y=0, line_dash=\"dash\", line_color=COLORS['text_muted'], line_width=1)\n",
        "\n",
        "    apply_chart_theme(fig)\n",
        "    return fig\n",
        "\n",
        "def run_monte_carlo_simulation(returns, initial_value=100000, days=252, simulations=1000):\n",
        "    if not is_valid_series(returns) or len(returns) < 30:\n",
        "        return None\n",
        "\n",
        "    daily_return = returns.mean()\n",
        "    daily_vol = returns.std()\n",
        "\n",
        "    simulation_results = []\n",
        "\n",
        "    for _ in range(simulations):\n",
        "        prices = [initial_value]\n",
        "        for _ in range(days):\n",
        "            price = prices[-1] * (1 + np.random.normal(daily_return, daily_vol))\n",
        "            prices.append(price)\n",
        "        simulation_results.append(prices)\n",
        "\n",
        "    return np.array(simulation_results)\n",
        "\n",
        "def create_monte_carlo_chart(simulation_results, initial_value=100000):\n",
        "    if simulation_results is None:\n",
        "        return None, None\n",
        "\n",
        "    fig = go.Figure()\n",
        "\n",
        "    for i in range(min(100, len(simulation_results))):\n",
        "        fig.add_trace(go.Scatter(\n",
        "            y=simulation_results[i],\n",
        "            mode='lines',\n",
        "            line=dict(width=0.5, color=COLORS['electric_blue']),\n",
        "            opacity=0.1,\n",
        "            showlegend=False\n",
        "        ))\n",
        "\n",
        "    percentiles = [5, 25, 50, 75, 95]\n",
        "    colors_pct = [COLORS['danger'], COLORS['warning'], COLORS['info'],\n",
        "                  COLORS['teal'], COLORS['success']]\n",
        "\n",
        "    for p, color in zip(percentiles, colors_pct):\n",
        "        values = np.percentile(simulation_results, p, axis=0)\n",
        "        fig.add_trace(go.Scatter(\n",
        "            y=values,\n",
        "            mode='lines',\n",
        "            line=dict(width=3, color=color),\n",
        "            name=f'{p}th Percentile'\n",
        "        ))\n",
        "\n",
        "    fig.update_layout(\n",
        "        title=\"üé≤ Monte Carlo Simulation\",\n",
        "        xaxis_title=\"Trading Days\",\n",
        "        yaxis_title=\"Portfolio Value ($)\",\n",
        "        height=500\n",
        "    )\n",
        "\n",
        "    apply_chart_theme(fig)\n",
        "\n",
        "    final_values = simulation_results[:, -1]\n",
        "    stats = {\n",
        "        'mean': np.mean(final_values),\n",
        "        'median': np.median(final_values),\n",
        "        'percentile_5': np.percentile(final_values, 5),\n",
        "        'percentile_95': np.percentile(final_values, 95),\n",
        "        'prob_profit': (final_values > initial_value).mean() * 100,\n",
        "        'prob_loss_10': (final_values < initial_value * 0.9).mean() * 100,\n",
        "        'prob_gain_20': (final_values > initial_value * 1.2).mean() * 100\n",
        "    }\n",
        "\n",
        "    return fig, stats\n",
        "\n",
        "def create_risk_parity_analysis(df):\n",
        "    risk_contributions = []\n",
        "\n",
        "    for _, row in df.iterrows():\n",
        "        ticker = row['Ticker']\n",
        "        weight = row['Weight %'] / 100\n",
        "\n",
        "        hist_data = fetch_historical_data(ticker, datetime.now() - timedelta(days=365), datetime.now())\n",
        "        if hist_data is not None and len(hist_data) > 30:\n",
        "            returns = hist_data['Close'].pct_change().dropna()\n",
        "            vol = returns.std() * np.sqrt(252)\n",
        "            risk_contribution = weight * vol\n",
        "\n",
        "            risk_contributions.append({\n",
        "                'Ticker': ticker,\n",
        "                'Weight %': row['Weight %'],\n",
        "                'Volatility': vol * 100,\n",
        "                'Risk Contribution': risk_contribution * 100\n",
        "            })\n",
        "\n",
        "    if not risk_contributions:\n",
        "        return None\n",
        "\n",
        "    rc_df = pd.DataFrame(risk_contributions)\n",
        "    total_risk = rc_df['Risk Contribution'].sum()\n",
        "    rc_df['Risk %'] = (rc_df['Risk Contribution'] / total_risk) * 100\n",
        "\n",
        "    fig = go.Figure()\n",
        "\n",
        "    fig.add_trace(go.Bar(\n",
        "        name='Weight %',\n",
        "        x=rc_df['Ticker'],\n",
        "        y=rc_df['Weight %'],\n",
        "        marker_color=COLORS['electric_blue']\n",
        "    ))\n",
        "\n",
        "    fig.add_trace(go.Bar(\n",
        "        name='Risk Contribution %',\n",
        "        x=rc_df['Ticker'],\n",
        "        y=rc_df['Risk %'],\n",
        "        marker_color=COLORS['danger']\n",
        "    ))\n",
        "\n",
        "    fig.update_layout(\n",
        "        title=\"‚öñÔ∏è Risk Parity Analysis\",\n",
        "        xaxis_title=\"Asset\",\n",
        "        yaxis_title=\"Percentage\",\n",
        "        barmode='group',\n",
        "        height=500\n",
        "    )\n",
        "\n",
        "    apply_chart_theme(fig)\n",
        "    return fig\n",
        "\n",
        "def create_correlation_network(df, start_date, end_date):\n",
        "    returns_data = {}\n",
        "\n",
        "    for _, row in df.iterrows():\n",
        "        ticker = row['Ticker']\n",
        "        hist_data = fetch_historical_data(ticker, start_date, end_date)\n",
        "        if hist_data is not None and len(hist_data) > 30:\n",
        "            returns_data[ticker] = hist_data['Close'].pct_change().dropna()\n",
        "\n",
        "    if len(returns_data) < 2:\n",
        "        return None\n",
        "\n",
        "    returns_df = pd.DataFrame(returns_data)\n",
        "    corr_matrix = returns_df.corr()\n",
        "\n",
        "    fig = go.Figure()\n",
        "\n",
        "    G = nx.Graph()\n",
        "    for ticker in corr_matrix.columns:\n",
        "        G.add_node(ticker)\n",
        "\n",
        "    threshold = 0.5\n",
        "    for i, ticker1 in enumerate(corr_matrix.columns):\n",
        "        for j, ticker2 in enumerate(corr_matrix.columns):\n",
        "            if i < j:\n",
        "                corr = corr_matrix.iloc[i, j]\n",
        "                if abs(corr) > threshold:\n",
        "                    G.add_edge(ticker1, ticker2, weight=abs(corr))\n",
        "\n",
        "    pos = nx.spring_layout(G)\n",
        "\n",
        "    for edge in G.edges():\n",
        "        x0, y0 = pos[edge[0]]\n",
        "        x1, y1 = pos[edge[1]]\n",
        "        weight = G[edge[0]][edge[1]]['weight']\n",
        "\n",
        "        fig.add_trace(go.Scatter(\n",
        "            x=[x0, x1],\n",
        "            y=[y0, y1],\n",
        "            mode='lines',\n",
        "            line=dict(width=weight*5, color=COLORS['electric_blue']),\n",
        "            opacity=0.5,\n",
        "            showlegend=False\n",
        "        ))\n",
        "\n",
        "    node_x = []\n",
        "    node_y = []\n",
        "    node_text = []\n",
        "\n",
        "    for node in G.nodes():\n",
        "        x, y = pos[node]\n",
        "        node_x.append(x)\n",
        "        node_y.append(y)\n",
        "        node_text.append(node)\n",
        "\n",
        "    fig.add_trace(go.Scatter(\n",
        "        x=node_x,\n",
        "        y=node_y,\n",
        "        mode='markers+text',\n",
        "        text=node_text,\n",
        "        textposition='top center',\n",
        "        marker=dict(\n",
        "            size=20,\n",
        "            color=COLORS['neon_blue'],\n",
        "            line=dict(width=2, color=COLORS['border'])\n",
        "        ),\n",
        "        showlegend=False\n",
        "    ))\n",
        "\n",
        "    fig.update_layout(\n",
        "        title=\"üîó Correlation Network\",\n",
        "        showlegend=False,\n",
        "        height=600,\n",
        "        xaxis=dict(showgrid=False, zeroline=False, showticklabels=False),\n",
        "        yaxis=dict(showgrid=False, zeroline=False, showticklabels=False)\n",
        "    )\n",
        "\n",
        "    apply_chart_theme(fig)\n",
        "    return fig\n",
        "\n",
        "def create_efficient_frontier(df):\n",
        "    \"\"\"FIXED BROADCASTING ERROR - ENHANCED THEMING\"\"\"\n",
        "    returns_data = {}\n",
        "    expected_returns = []\n",
        "    volatilities = []\n",
        "    tickers = []\n",
        "\n",
        "    for _, row in df.iterrows():\n",
        "        ticker = row['Ticker']\n",
        "        hist_data = fetch_historical_data(ticker, datetime.now() - timedelta(days=365), datetime.now())\n",
        "\n",
        "        if hist_data is not None and len(hist_data) > 30:\n",
        "            returns = hist_data['Close'].pct_change().dropna()\n",
        "            annual_return = ((1 + returns.mean()) ** 252 - 1)\n",
        "            annual_vol = returns.std() * np.sqrt(252)\n",
        "\n",
        "            expected_returns.append(annual_return)\n",
        "            volatilities.append(annual_vol)\n",
        "            tickers.append(ticker)\n",
        "            returns_data[ticker] = returns\n",
        "\n",
        "    if len(expected_returns) < 2:\n",
        "        return None\n",
        "\n",
        "    returns_df = pd.DataFrame(returns_data)\n",
        "    cov_matrix = returns_df.cov() * 252\n",
        "\n",
        "    num_portfolios = 5000\n",
        "    results = np.zeros((3, num_portfolios))\n",
        "\n",
        "    np.random.seed(42)\n",
        "\n",
        "    for i in range(num_portfolios):\n",
        "        weights = np.random.random(len(tickers))\n",
        "        weights /= np.sum(weights)\n",
        "\n",
        "        portfolio_return = np.sum(weights * np.array(expected_returns))\n",
        "        portfolio_vol = np.sqrt(np.dot(weights.T, np.dot(cov_matrix, weights)))\n",
        "        sharpe = (portfolio_return - RISK_FREE_RATE) / portfolio_vol if portfolio_vol > 0 else 0\n",
        "\n",
        "        results[0, i] = portfolio_return * 100\n",
        "        results[1, i] = portfolio_vol * 100\n",
        "        results[2, i] = sharpe\n",
        "\n",
        "    fig = go.Figure()\n",
        "\n",
        "    fig.add_trace(go.Scatter(\n",
        "        x=results[1],\n",
        "        y=results[0],\n",
        "        mode='markers',\n",
        "        marker=dict(\n",
        "            size=5,\n",
        "            color=results[2],\n",
        "            colorscale='Viridis',\n",
        "            showscale=True,\n",
        "            colorbar=dict(title=\"Sharpe Ratio\")\n",
        "        ),\n",
        "        name='Efficient Frontier'\n",
        "    ))\n",
        "\n",
        "    # FIXED: Properly align weights and returns\n",
        "    current_weights = df[df['Ticker'].isin(tickers)]['Weight %'].values / 100\n",
        "    aligned_returns = np.array(expected_returns[:len(current_weights)])\n",
        "    aligned_cov = cov_matrix.iloc[:len(current_weights), :len(current_weights)]\n",
        "\n",
        "    current_return = np.sum(current_weights * aligned_returns) * 100\n",
        "    current_vol = np.sqrt(np.dot(current_weights.T, np.dot(aligned_cov, current_weights))) * 100\n",
        "\n",
        "    fig.add_trace(go.Scatter(\n",
        "        x=[current_vol],\n",
        "        y=[current_return],\n",
        "        mode='markers',\n",
        "        marker=dict(size=20, color=COLORS['danger'], symbol='star'),\n",
        "        name='Current Portfolio'\n",
        "    ))\n",
        "\n",
        "    fig.update_layout(\n",
        "        title=\"üìä Efficient Frontier\",\n",
        "        xaxis_title=\"Risk (Volatility %)\",\n",
        "        yaxis_title=\"Return %\",\n",
        "        height=600\n",
        "    )\n",
        "\n",
        "    apply_chart_theme(fig)\n",
        "    return fig\n",
        "\n",
        "# ============================================================================\n",
        "# MARKET WATCH - ENHANCED\n",
        "# ============================================================================\n",
        "\n",
        "@st.cache_data(ttl=300)\n",
        "def fetch_market_watch_data(tickers_dict):\n",
        "    market_data = []\n",
        "\n",
        "    for ticker, info in tickers_dict.items():\n",
        "        try:\n",
        "            stock = yf.Ticker(ticker)\n",
        "            hist = stock.history(period=\"5d\")\n",
        "\n",
        "            if not hist.empty:\n",
        "                current = hist['Close'].iloc[-1]\n",
        "                prev = hist['Close'].iloc[-2] if len(hist) > 1 else current\n",
        "                change = ((current - prev) / prev) * 100\n",
        "\n",
        "                five_day = ((current / hist['Close'].iloc[0]) - 1) * 100 if len(hist) >= 5 else 0\n",
        "\n",
        "                volume = hist['Volume'].iloc[-1]\n",
        "                avg_volume = hist['Volume'].mean()\n",
        "\n",
        "                market_data.append({\n",
        "                    'Symbol': ticker,\n",
        "                    'Name': info.get('name', ticker),\n",
        "                    'Category': info.get('category', info.get('region', '')),\n",
        "                    'Last': current,\n",
        "                    'Change %': change,\n",
        "                    '5D %': five_day,\n",
        "                    'Volume': volume,\n",
        "                    'Avg Volume': avg_volume,\n",
        "                    'Vol/Avg': volume / avg_volume if avg_volume > 0 else 0\n",
        "                })\n",
        "        except:\n",
        "            continue\n",
        "\n",
        "    return pd.DataFrame(market_data)\n",
        "\n",
        "def create_dynamic_market_table(df, filters=None):\n",
        "    if filters:\n",
        "        if 'category' in filters and filters['category']:\n",
        "            df = df[df['Category'] == filters['category']]\n",
        "\n",
        "        if 'min_change' in filters and filters['min_change']:\n",
        "            df = df[df['Change %'] >= filters['min_change']]\n",
        "\n",
        "        if 'sort_by' in filters and filters['sort_by']:\n",
        "            ascending = filters.get('ascending', False)\n",
        "            df = df.sort_values(filters['sort_by'], ascending=ascending)\n",
        "\n",
        "    display_df = df.copy()\n",
        "    display_df['Last'] = display_df['Last'].apply(format_currency)\n",
        "    display_df['Change %'] = display_df['Change %'].apply(lambda x: add_arrow_indicator(format_percentage(x)))\n",
        "    display_df['5D %'] = display_df['5D %'].apply(lambda x: add_arrow_indicator(format_percentage(x)))\n",
        "    display_df['Volume'] = display_df['Volume'].apply(lambda x: f\"{x:,.0f}\")\n",
        "    display_df['Vol/Avg'] = display_df['Vol/Avg'].apply(lambda x: f\"{x:.2f}x\")\n",
        "\n",
        "    return display_df\n",
        "\n",
        "# ============================================================================\n",
        "# PORTFOLIO DEEP DIVE - ENHANCED\n",
        "# ============================================================================\n",
        "\n",
        "def create_sector_rotation_heatmap(df, start_date, end_date):\n",
        "    \"\"\"Sector rotation heatmap - FIXED NOV 2024\"\"\"\n",
        "    sector_returns = {}\n",
        "\n",
        "    end_date_cutoff = datetime.now().replace(day=1)  # First day of current month\n",
        "\n",
        "    for _, row in df.iterrows():\n",
        "        ticker = row['Ticker']\n",
        "        sector = row['Sector']\n",
        "\n",
        "        hist_data = fetch_historical_data(ticker, start_date, end_date)\n",
        "        if hist_data is not None and len(hist_data) > 30:\n",
        "            monthly_data = hist_data['Close'].resample('M').last()\n",
        "            monthly_returns = monthly_data.pct_change() * 100\n",
        "\n",
        "            # FIXED: Filter out current incomplete month\n",
        "            monthly_returns = monthly_returns[monthly_returns.index < end_date_cutoff]\n",
        "\n",
        "            if sector not in sector_returns:\n",
        "                sector_returns[sector] = []\n",
        "\n",
        "            sector_returns[sector].append(monthly_returns)\n",
        "\n",
        "    if not sector_returns:\n",
        "        return None\n",
        "\n",
        "    sector_avg = {}\n",
        "    for sector, returns_list in sector_returns.items():\n",
        "        combined = pd.concat(returns_list, axis=1).mean(axis=1)\n",
        "        sector_avg[sector] = combined\n",
        "\n",
        "    sectors = list(sector_avg.keys())\n",
        "    months = sector_avg[sectors[0]].index\n",
        "\n",
        "    matrix = []\n",
        "    for sector in sectors:\n",
        "        matrix.append(sector_avg[sector].values)\n",
        "\n",
        "    fig = go.Figure(data=go.Heatmap(\n",
        "        z=matrix,\n",
        "        x=[m.strftime('%b %Y') for m in months],\n",
        "        y=sectors,\n",
        "        colorscale='RdYlGn',\n",
        "        zmid=0,\n",
        "        text=np.round(matrix, 1),\n",
        "        texttemplate='%{text}%',\n",
        "        textfont={\"size\": 11},\n",
        "        colorbar=dict(title=\"Return %\")\n",
        "    ))\n",
        "\n",
        "    fig.update_layout(\n",
        "        title=\"üîÑ Sector Rotation Heatmap\",\n",
        "        xaxis_title=\"Month\",\n",
        "        yaxis_title=\"Sector\",\n",
        "        height=500\n",
        "    )\n",
        "\n",
        "    apply_chart_theme(fig)\n",
        "    return fig\n",
        "\n",
        "def create_holdings_attribution_waterfall(df):\n",
        "    \"\"\"Holdings attribution waterfall - ENHANCED THEMING\"\"\"\n",
        "    top_contributors = df.nlargest(10, 'Total Gain/Loss $')\n",
        "\n",
        "    tickers = top_contributors['Ticker'].tolist()\n",
        "    contributions = top_contributors['Total Gain/Loss $'].tolist()\n",
        "\n",
        "    fig = go.Figure()\n",
        "\n",
        "    fig.add_trace(go.Waterfall(\n",
        "        name=\"Attribution\",\n",
        "        orientation=\"v\",\n",
        "        x=tickers,\n",
        "        y=contributions,\n",
        "        connector={\"line\": {\"color\": COLORS['neon_blue']}},\n",
        "        decreasing={\"marker\": {\"color\": COLORS['danger']}},\n",
        "        increasing={\"marker\": {\"color\": COLORS['success']}},\n",
        "        totals={\"marker\": {\"color\": COLORS['electric_blue']}}\n",
        "    ))\n",
        "\n",
        "    fig.update_layout(\n",
        "        title=\"üíß Holdings Attribution Waterfall\",\n",
        "        xaxis_title=\"Ticker\",\n",
        "        yaxis_title=\"Contribution ($)\",\n",
        "        height=500\n",
        "    )\n",
        "\n",
        "    apply_chart_theme(fig)\n",
        "    return fig\n",
        "\n",
        "def create_concentration_gauge(df):\n",
        "    \"\"\"Concentration gauge - ENHANCED THEMING\"\"\"\n",
        "    top_5_weight = df.nlargest(5, 'Weight %')['Weight %'].sum()\n",
        "\n",
        "    fig = go.Figure(go.Indicator(\n",
        "        mode=\"gauge+number+delta\",\n",
        "        value=top_5_weight,\n",
        "        title={'text': \"Top 5 Concentration\"},\n",
        "        delta={'reference': 50, 'increasing': {'color': COLORS['warning']}},\n",
        "        gauge={\n",
        "            'axis': {'range': [None, 100]},\n",
        "            'bar': {'color': COLORS['neon_blue']},\n",
        "            'steps': [\n",
        "                {'range': [0, 30], 'color': COLORS['success']},\n",
        "                {'range': [30, 50], 'color': COLORS['warning']},\n",
        "                {'range': [50, 100], 'color': COLORS['danger']}\n",
        "            ],\n",
        "            'threshold': {\n",
        "                'line': {'color': \"red\", 'width': 4},\n",
        "                'thickness': 0.75,\n",
        "                'value': 70\n",
        "            }\n",
        "        }\n",
        "    ))\n",
        "\n",
        "    fig.update_layout(height=400)\n",
        "    apply_chart_theme(fig)\n",
        "    return fig\n",
        "\n",
        "def create_concentration_analysis(df):\n",
        "    \"\"\"NEW: Enhanced concentration analysis with multiple visuals\"\"\"\n",
        "\n",
        "    # Top 10 Holdings Bar Chart\n",
        "    top_10 = df.nlargest(10, 'Weight %')\n",
        "\n",
        "    fig = go.Figure()\n",
        "\n",
        "    fig.add_trace(go.Bar(\n",
        "        x=top_10['Weight %'],\n",
        "        y=top_10['Ticker'],\n",
        "        orientation='h',\n",
        "        marker=dict(\n",
        "            color=top_10['Weight %'],\n",
        "            colorscale='Blues',\n",
        "            line=dict(color=COLORS['border'], width=2)\n",
        "        ),\n",
        "        text=[f\"{x:.1f}%\" for x in top_10['Weight %']],\n",
        "        textposition='auto'\n",
        "    ))\n",
        "\n",
        "    fig.update_layout(\n",
        "        title=\"üìä Top 10 Holdings Concentration\",\n",
        "        xaxis_title=\"Weight (%)\",\n",
        "        yaxis_title=\"\",\n",
        "        height=500,\n",
        "        showlegend=False\n",
        "    )\n",
        "\n",
        "    apply_chart_theme(fig)\n",
        "    return fig\n",
        "\n",
        "# ============================================================================\n",
        "# MULTI-FACTOR ANALYSIS - ENHANCED\n",
        "# ============================================================================\n",
        "\n",
        "def create_factor_momentum_chart(factor_data):\n",
        "    \"\"\"Factor momentum chart - ENHANCED THEMING\"\"\"\n",
        "    if factor_data is None or 'factor_returns' not in factor_data:\n",
        "        return None\n",
        "\n",
        "    factor_returns = factor_data['factor_returns']\n",
        "\n",
        "    fig = go.Figure()\n",
        "\n",
        "    colors = [COLORS['neon_blue'], COLORS['electric_blue'], COLORS['teal'],\n",
        "              COLORS['success'], COLORS['purple'], COLORS['pink']]\n",
        "\n",
        "    for idx, factor in enumerate(FACTOR_DEFINITIONS.keys()):\n",
        "        if factor in factor_returns.columns:\n",
        "            cumulative = (1 + factor_returns[factor]).cumprod() - 1\n",
        "            fig.add_trace(go.Scatter(\n",
        "                x=cumulative.index,\n",
        "                y=cumulative.values * 100,\n",
        "                mode='lines',\n",
        "                name=factor,\n",
        "                line=dict(width=2, color=colors[idx % len(colors)])\n",
        "            ))\n",
        "\n",
        "    fig.update_layout(\n",
        "        title=\"üìà Factor Momentum\",\n",
        "        xaxis_title=\"Date\",\n",
        "        yaxis_title=\"Cumulative Return (%)\",\n",
        "        height=600,\n",
        "        hovermode='x unified',\n",
        "        legend=dict(x=0.02, y=0.98)\n",
        "    )\n",
        "\n",
        "    apply_chart_theme(fig)\n",
        "    return fig\n",
        "\n",
        "def create_factor_exposure_radar(exposures):\n",
        "    \"\"\"Factor exposure radar - ENHANCED THEMING\"\"\"\n",
        "    if exposures is None or 'exposures' not in exposures:\n",
        "        return None\n",
        "\n",
        "    exp = exposures['exposures']\n",
        "    factors = [f for f in FACTOR_DEFINITIONS.keys() if f in exp.index]\n",
        "    values = [exp[f] for f in factors]\n",
        "\n",
        "    max_abs = max([abs(v) for v in values]) if values else 1\n",
        "    normalized = [(v / max_abs) * 100 if max_abs > 0 else 0 for v in values]\n",
        "\n",
        "    fig = go.Figure()\n",
        "\n",
        "    fig.add_trace(go.Scatterpolar(\n",
        "        r=normalized,\n",
        "        theta=factors,\n",
        "        fill='toself',\n",
        "        fillcolor='rgba(0, 212, 255, 0.2)',\n",
        "        line=dict(color=COLORS['neon_blue'], width=2),\n",
        "        name='Factor Exposure'\n",
        "    ))\n",
        "\n",
        "    fig.update_layout(\n",
        "        polar=dict(\n",
        "            radialaxis=dict(\n",
        "                visible=True,\n",
        "                range=[0, 100],\n",
        "                color=COLORS['text_secondary']\n",
        "            ),\n",
        "            bgcolor='rgba(10, 25, 41, 0.3)'\n",
        "        ),\n",
        "        title=\"üéØ Factor Exposure Radar\",\n",
        "        height=550\n",
        "    )\n",
        "\n",
        "    apply_chart_theme(fig)\n",
        "    return fig\n",
        "\n",
        "@st.cache_data(ttl=3600)\n",
        "def calculate_factor_exposures(df, start_date, end_date):\n",
        "    try:\n",
        "        portfolio_returns = calculate_portfolio_returns(df, start_date, end_date)\n",
        "        if not is_valid_series(portfolio_returns):\n",
        "            return None\n",
        "\n",
        "        factor_returns = {}\n",
        "        for factor_name, factor_info in FACTOR_DEFINITIONS.items():\n",
        "            benchmark = factor_info['benchmark']\n",
        "            returns = calculate_benchmark_returns(benchmark, start_date, end_date)\n",
        "            if is_valid_series(returns):\n",
        "                factor_returns[factor_name] = returns\n",
        "\n",
        "        if not factor_returns:\n",
        "            return None\n",
        "\n",
        "        common_dates = portfolio_returns.index\n",
        "        for factor_name in factor_returns:\n",
        "            common_dates = common_dates.intersection(factor_returns[factor_name].index)\n",
        "\n",
        "        X = pd.DataFrame({name: returns.loc[common_dates] for name, returns in factor_returns.items()})\n",
        "        y = portfolio_returns.loc[common_dates]\n",
        "\n",
        "        X['Alpha'] = 1\n",
        "\n",
        "        model = LinearRegression()\n",
        "        model.fit(X, y)\n",
        "\n",
        "        exposures = pd.Series(model.coef_, index=X.columns)\n",
        "        r_squared = model.score(X, y)\n",
        "        predicted_returns = model.predict(X)\n",
        "\n",
        "        asset_exposures = {}\n",
        "        for _, row in df.iterrows():\n",
        "            ticker = row['Ticker']\n",
        "            ticker_returns = calculate_benchmark_returns(ticker, start_date, end_date)\n",
        "            if is_valid_series(ticker_returns):\n",
        "                ticker_aligned = ticker_returns.loc[common_dates]\n",
        "\n",
        "                asset_model = LinearRegression()\n",
        "                asset_model.fit(X, ticker_aligned)\n",
        "\n",
        "                asset_exposures[ticker] = pd.Series(asset_model.coef_, index=X.columns)\n",
        "\n",
        "        return {\n",
        "            'exposures': exposures,\n",
        "            'r_squared': r_squared,\n",
        "            'factor_returns': X,\n",
        "            'portfolio_returns': y,\n",
        "            'predicted_returns': predicted_returns,\n",
        "            'asset_exposures': asset_exposures\n",
        "        }\n",
        "    except:\n",
        "        return None\n",
        "\n",
        "def create_factor_attribution_table(exposures, df):\n",
        "    if exposures is None or 'asset_exposures' not in exposures:\n",
        "        return None, None, None\n",
        "\n",
        "    attribution_data = []\n",
        "\n",
        "    for ticker, asset_exp in exposures['asset_exposures'].items():\n",
        "        asset_row = df[df['Ticker'] == ticker]\n",
        "        if asset_row.empty:\n",
        "            continue\n",
        "\n",
        "        weight = asset_row['Weight %'].values[0] / 100\n",
        "        sector = asset_row['Sector'].values[0]\n",
        "\n",
        "        for factor in FACTOR_DEFINITIONS.keys():\n",
        "            if factor in asset_exp:\n",
        "                contribution = weight * asset_exp[factor]\n",
        "                attribution_data.append({\n",
        "                    'Ticker': ticker,\n",
        "                    'Sector': sector,\n",
        "                    'Factor': factor,\n",
        "                    'Weight': weight * 100,\n",
        "                    'Factor Beta': asset_exp[factor],\n",
        "                    'Contribution': contribution\n",
        "                })\n",
        "\n",
        "    if not attribution_data:\n",
        "        return None, None, None\n",
        "\n",
        "    attr_df = pd.DataFrame(attribution_data)\n",
        "\n",
        "    factor_summary = attr_df.groupby('Factor').agg({\n",
        "        'Contribution': 'sum'\n",
        "    }).reset_index()\n",
        "    factor_summary.columns = ['Factor', 'Total Contribution']\n",
        "\n",
        "    sector_summary = attr_df.groupby(['Sector', 'Factor']).agg({\n",
        "        'Contribution': 'sum'\n",
        "    }).reset_index()\n",
        "\n",
        "    return attr_df, factor_summary, sector_summary\n",
        "\n",
        "# ============================================================================\n",
        "# PERFORMANCE METRICS\n",
        "# ============================================================================\n",
        "\n",
        "def calculate_performance_metrics(df, portfolio_returns, benchmark_returns):\n",
        "    if not is_valid_series(portfolio_returns):\n",
        "        return None\n",
        "\n",
        "    total_return = (1 + portfolio_returns).prod() - 1\n",
        "    n_years = len(portfolio_returns) / 252\n",
        "    annualized_return = (1 + total_return) ** (1/n_years) - 1 if n_years > 0 else 0\n",
        "    annualized_vol = portfolio_returns.std() * np.sqrt(252)\n",
        "\n",
        "    sharpe = calculate_sharpe_ratio(portfolio_returns)\n",
        "    sortino = calculate_sortino_ratio(portfolio_returns)\n",
        "    calmar = calculate_calmar_ratio(portfolio_returns)\n",
        "\n",
        "    info_ratio = calculate_information_ratio(portfolio_returns, benchmark_returns)\n",
        "\n",
        "    var_95 = calculate_var(portfolio_returns, 0.95)\n",
        "    cvar_95 = calculate_cvar(portfolio_returns, 0.95)\n",
        "    max_dd = calculate_max_drawdown(portfolio_returns)\n",
        "\n",
        "    winning_days = (portfolio_returns > 0).sum()\n",
        "    losing_days = (portfolio_returns < 0).sum()\n",
        "    win_rate = winning_days / (winning_days + losing_days) * 100 if (winning_days + losing_days) > 0 else 0\n",
        "\n",
        "    avg_win = portfolio_returns[portfolio_returns > 0].mean() * 100 if winning_days > 0 else 0\n",
        "    avg_loss = portfolio_returns[portfolio_returns < 0].mean() * 100 if losing_days > 0 else 0\n",
        "\n",
        "    best_day = portfolio_returns.max() * 100\n",
        "    worst_day = portfolio_returns.min() * 100\n",
        "\n",
        "    return {\n",
        "        'Total Return': total_return * 100,\n",
        "        'Annualized Return': annualized_return * 100,\n",
        "        'Annualized Volatility': annualized_vol * 100,\n",
        "        'Sharpe Ratio': sharpe,\n",
        "        'Sortino Ratio': sortino,\n",
        "        'Calmar Ratio': calmar,\n",
        "        'Information Ratio': info_ratio,\n",
        "        'VaR (95%)': var_95,\n",
        "        'CVaR (95%)': cvar_95,\n",
        "        'Max Drawdown': max_dd,\n",
        "        'Win Rate': win_rate,\n",
        "        'Avg Win': avg_win,\n",
        "        'Avg Loss': avg_loss,\n",
        "        'Best Day': best_day,\n",
        "        'Worst Day': worst_day,\n",
        "        'Winning Days': winning_days,\n",
        "        'Losing Days': losing_days\n",
        "    }\n",
        "\n",
        "def create_performance_dashboard(metrics):\n",
        "    fig = make_subplots(\n",
        "        rows=2, cols=2,\n",
        "        subplot_titles=('Returns Distribution', 'Risk Metrics',\n",
        "                       'Win/Loss Analysis', 'Risk-Adjusted Returns'),\n",
        "        specs=[[{'type': 'bar'}, {'type': 'scatter'}],\n",
        "               [{'type': 'pie'}, {'type': 'bar'}]]\n",
        "    )\n",
        "\n",
        "    fig.add_trace(\n",
        "        go.Bar(x=['Total', 'Annualized'],\n",
        "               y=[metrics['Total Return'], metrics['Annualized Return']],\n",
        "               marker_color=[COLORS['success'], COLORS['electric_blue']]),\n",
        "        row=1, col=1\n",
        "    )\n",
        "\n",
        "    fig.add_trace(\n",
        "        go.Scatter(x=['Volatility', 'VaR', 'CVaR', 'Max DD'],\n",
        "                  y=[metrics['Annualized Volatility'], abs(metrics['VaR (95%)']),\n",
        "                     abs(metrics['CVaR (95%)']), abs(metrics['Max Drawdown'])],\n",
        "                  mode='markers+lines',\n",
        "                  marker=dict(size=15, color=COLORS['danger'])),\n",
        "        row=1, col=2\n",
        "    )\n",
        "\n",
        "    fig.add_trace(\n",
        "        go.Pie(labels=['Winning Days', 'Losing Days'],\n",
        "               values=[metrics['Winning Days'], metrics['Losing Days']],\n",
        "               marker=dict(colors=[COLORS['success'], COLORS['danger']])),\n",
        "        row=2, col=1\n",
        "    )\n",
        "\n",
        "    fig.add_trace(\n",
        "        go.Bar(x=['Sharpe', 'Sortino', 'Calmar', 'Info'],\n",
        "               y=[metrics['Sharpe Ratio'], metrics['Sortino Ratio'],\n",
        "                  metrics['Calmar Ratio'], metrics['Information Ratio']],\n",
        "               marker_color=COLORS['purple']),\n",
        "        row=2, col=2\n",
        "    )\n",
        "\n",
        "    fig.update_layout(\n",
        "        height=700,\n",
        "        showlegend=False,\n",
        "        title_text=\"üìä Performance Dashboard\"\n",
        "    )\n",
        "\n",
        "    apply_chart_theme(fig)\n",
        "    return fig\n",
        "\n",
        "# ============================================================================\n",
        "# VALUATION HOUSE VISUALIZATIONS - ENHANCED\n",
        "# ============================================================================\n",
        "\n",
        "def create_dcf_waterfall(dcf_results, method='FCFF'):\n",
        "    \"\"\"Create waterfall chart showing DCF buildup - ENHANCED THEMING\"\"\"\n",
        "\n",
        "    categories = ['PV of Cash Flows', 'PV of Terminal Value']\n",
        "    values = [dcf_results['total_pv_cash_flows'], dcf_results['pv_terminal']]\n",
        "\n",
        "    if method == 'FCFF':\n",
        "        categories.append('Enterprise Value')\n",
        "        categories.append('Less: Net Debt')\n",
        "        categories.append('Equity Value')\n",
        "        values.append(dcf_results['enterprise_value'])\n",
        "        values.append(-dcf_results.get('net_debt', 0))\n",
        "        values.append(dcf_results['equity_value'])\n",
        "\n",
        "    fig = go.Figure(go.Waterfall(\n",
        "        name=\"DCF Buildup\",\n",
        "        orientation=\"v\",\n",
        "        x=categories,\n",
        "        y=values,\n",
        "        connector={\"line\": {\"color\": COLORS['neon_blue']}},\n",
        "        decreasing={\"marker\": {\"color\": COLORS['danger']}},\n",
        "        increasing={\"marker\": {\"color\": COLORS['success']}},\n",
        "    ))\n",
        "\n",
        "    fig.update_layout(\n",
        "        title=f\"üíé {method} Valuation Buildup\",\n",
        "        yaxis_title=\"Value ($)\",\n",
        "        height=500\n",
        "    )\n",
        "\n",
        "    apply_chart_theme(fig)\n",
        "    return fig\n",
        "\n",
        "def create_cash_flow_chart(projections, method='FCFF'):\n",
        "    \"\"\"Create bar chart of projected cash flows - ENHANCED THEMING\"\"\"\n",
        "\n",
        "    cf_key = 'fcff' if method == 'FCFF' else 'fcfe'\n",
        "\n",
        "    years = [proj['year'] for proj in projections]\n",
        "    cash_flows = [proj[cf_key] for proj in projections]\n",
        "\n",
        "    fig = go.Figure()\n",
        "\n",
        "    fig.add_trace(go.Bar(\n",
        "        x=years,\n",
        "        y=cash_flows,\n",
        "        marker_color=COLORS['electric_blue'],\n",
        "        name=method,\n",
        "        marker=dict(line=dict(color=COLORS['border'], width=2))\n",
        "    ))\n",
        "\n",
        "    fig.update_layout(\n",
        "        title=f\"üìä Projected {method} by Year\",\n",
        "        xaxis_title=\"Year\",\n",
        "        yaxis_title=f\"{method} ($)\",\n",
        "        height=400\n",
        "    )\n",
        "\n",
        "    apply_chart_theme(fig)\n",
        "    return fig\n",
        "\n",
        "def create_sensitivity_table(base_price, base_discount, base_terminal):\n",
        "    \"\"\"Create sensitivity analysis table - ENHANCED THEMING\"\"\"\n",
        "\n",
        "    discount_rates = np.linspace(base_discount - 0.02, base_discount + 0.02, 5)\n",
        "    terminal_growth_rates = np.linspace(base_terminal - 0.01, base_terminal + 0.01, 5)\n",
        "\n",
        "    # This is simplified - in real implementation would recalculate DCF\n",
        "    sensitivity_matrix = []\n",
        "    for tr in terminal_growth_rates:\n",
        "        row = []\n",
        "        for dr in discount_rates:\n",
        "            # Simplified sensitivity calculation\n",
        "            adjustment = (1 - (dr - base_discount)) * (1 + (tr - base_terminal))\n",
        "            value = base_price * adjustment\n",
        "            row.append(value)\n",
        "        sensitivity_matrix.append(row)\n",
        "\n",
        "    fig = go.Figure(data=go.Heatmap(\n",
        "        z=sensitivity_matrix,\n",
        "        x=[f\"{dr:.1%}\" for dr in discount_rates],\n",
        "        y=[f\"{tg:.1%}\" for tg in terminal_growth_rates],\n",
        "        colorscale='RdYlGn',\n",
        "        text=[[f\"${v:.2f}\" for v in row] for row in sensitivity_matrix],\n",
        "        texttemplate='%{text}',\n",
        "        textfont={\"size\": 10},\n",
        "        colorbar=dict(title=\"Price\")\n",
        "    ))\n",
        "\n",
        "    fig.update_layout(\n",
        "        title=\"üéØ Sensitivity Analysis\",\n",
        "        xaxis_title=\"Discount Rate\",\n",
        "        yaxis_title=\"Terminal Growth Rate\",\n",
        "        height=400\n",
        "    )\n",
        "\n",
        "    apply_chart_theme(fig)\n",
        "    return fig\n",
        "\n",
        "# ============================================================================\n",
        "# MAIN APP - EXCELLENCE EDITION\n",
        "# ============================================================================\n",
        "\n",
        "def main():\n",
        "    st.markdown(\"<h1>üî• ATLAS TERMINAL v9.3 EXCELLENCE</h1>\", unsafe_allow_html=True)\n",
        "    st.markdown(\"<p style='text-align: center; color: #00d4ff; font-size: 18px;'>Complete Portfolio Analytics + Valuation House üíé</p>\", unsafe_allow_html=True)\n",
        "\n",
        "    leverage_info = get_leverage_info()\n",
        "    if leverage_info:\n",
        "        st.markdown(f\"\"\"\n",
        "        <div style=\"background: linear-gradient(135deg, #ff6b00 0%, #ff0044 100%);\n",
        "                    border: 2px solid #ff6b00; border-radius: 8px; padding: 10px; margin-bottom: 10px;\n",
        "                    text-align: center;\">\n",
        "            <span style=\"color: white; font-weight: 600;\">‚ö° LEVERAGED ACCOUNT ‚ö°</span>\n",
        "            <span style=\"color: white; margin-left: 20px;\">Margin: ${leverage_info['margin_used']:,.2f}</span>\n",
        "            <span style=\"color: white; margin-left: 20px;\">Leverage: {leverage_info['leverage_ratio']:.2f}x</span>\n",
        "        </div>\n",
        "        \"\"\", unsafe_allow_html=True)\n",
        "\n",
        "    st.sidebar.markdown(\"## üéõÔ∏è NAVIGATION\")\n",
        "    page = st.sidebar.radio(\"Select Module\", [\n",
        "        \"üî• Phoenix Parser\",\n",
        "        \"üè† Portfolio Home\",\n",
        "        \"üåç Market Watch\",\n",
        "        \"üìà Risk Analysis\",\n",
        "        \"üíé Performance Suite\",\n",
        "        \"üî¨ Portfolio Deep Dive\",\n",
        "        \"üìä Multi-Factor Analysis\",\n",
        "        \"üí∞ Valuation House\",\n",
        "        \"‚ÑπÔ∏è About\"\n",
        "    ])\n",
        "\n",
        "    st.sidebar.markdown(\"---\")\n",
        "    st.sidebar.markdown(\"### üìÖ TIME RANGE\")\n",
        "    date_options = [\"1D\", \"1W\", \"1M\", \"3M\", \"6M\", \"YTD\", \"1Y\", \"3Y\", \"5Y\", \"MAX\"]\n",
        "    selected_range = st.sidebar.selectbox(\"Period\", date_options, index=6)\n",
        "\n",
        "    st.sidebar.markdown(\"---\")\n",
        "    st.sidebar.markdown(\"### üéØ BENCHMARK\")\n",
        "    benchmark_options = [\"SPY\", \"QQQ\", \"DIA\", \"IWM\", \"VTI\", \"ACWI\"]\n",
        "    selected_benchmark = st.sidebar.selectbox(\"Compare Against\", benchmark_options, index=0)\n",
        "\n",
        "    if selected_range == \"YTD\":\n",
        "        start_date = datetime(datetime.now().year, 1, 1)\n",
        "        end_date = datetime.now()\n",
        "    elif selected_range == \"MAX\":\n",
        "        start_date = datetime(2000, 1, 1)\n",
        "        end_date = datetime.now()\n",
        "    else:\n",
        "        days_map = {\"1D\": 1, \"1W\": 7, \"1M\": 30, \"3M\": 90, \"6M\": 180, \"1Y\": 365, \"3Y\": 1095, \"5Y\": 1825}\n",
        "        days = days_map.get(selected_range, 365)\n",
        "        end_date = datetime.now()\n",
        "        start_date = end_date - timedelta(days=days)\n",
        "\n",
        "    # ========================================================================\n",
        "    # PHOENIX PARSER\n",
        "    # ========================================================================\n",
        "    if page == \"üî• Phoenix Parser\":\n",
        "        st.markdown(\"## üî• PHOENIX MODE\")\n",
        "\n",
        "        col1, col2 = st.columns(2)\n",
        "\n",
        "        with col1:\n",
        "            st.markdown(\"### üìä Trade History\")\n",
        "            trade_file = st.file_uploader(\"Upload Trade History\", type=['xls', 'xlsx'], key=\"trade\")\n",
        "\n",
        "            if trade_file:\n",
        "                with st.spinner(\"Parsing...\"):\n",
        "                    trade_df = parse_trade_history_file(trade_file)\n",
        "\n",
        "                    if trade_df is not None:\n",
        "                        save_trade_history(trade_df)\n",
        "                        st.success(f\"‚úÖ Parsed {len(trade_df)} trades!\")\n",
        "                        st.dataframe(trade_df.head(10), use_container_width=True)\n",
        "\n",
        "                        portfolio_df = calculate_portfolio_from_trades(trade_df)\n",
        "                        if len(portfolio_df) > 0:\n",
        "                            save_portfolio_data(portfolio_df.to_dict('records'))\n",
        "                            st.success(f\"üéâ Portfolio rebuilt! {len(portfolio_df)} positions\")\n",
        "                            st.dataframe(portfolio_df, use_container_width=True)\n",
        "\n",
        "        with col2:\n",
        "            st.markdown(\"### üí∞ Account History\")\n",
        "            account_file = st.file_uploader(\"Upload Account History\", type=['xls', 'xlsx'], key=\"account\")\n",
        "\n",
        "            if account_file:\n",
        "                with st.spinner(\"Parsing...\"):\n",
        "                    account_df = parse_account_history_file(account_file)\n",
        "\n",
        "                    if account_df is not None:\n",
        "                        save_account_history(account_df)\n",
        "                        st.success(f\"‚úÖ Parsed {len(account_df)} records!\")\n",
        "                        st.dataframe(account_df.head(10), use_container_width=True)\n",
        "\n",
        "                        leverage_info_parsed = get_leverage_info()\n",
        "                        if leverage_info_parsed:\n",
        "                            st.info(f\"\"\"\n",
        "                            üí° Leverage Detected:\n",
        "                            - Margin: ${leverage_info_parsed['margin_used']:,.2f}\n",
        "                            - Leverage: {leverage_info_parsed['leverage_ratio']:.2f}x\n",
        "                            \"\"\")\n",
        "\n",
        "    # ========================================================================\n",
        "    # PORTFOLIO HOME - ENHANCED WITH CONTRIBUTORS/DETRACTORS\n",
        "    # ========================================================================\n",
        "    elif page == \"üè† Portfolio Home\":\n",
        "        st.markdown(\"## üè† PORTFOLIO HOME\")\n",
        "\n",
        "        portfolio_data = load_portfolio_data()\n",
        "\n",
        "        if not portfolio_data:\n",
        "            st.warning(\"‚ö†Ô∏è No portfolio data. Please upload via Phoenix Parser.\")\n",
        "            return\n",
        "\n",
        "        df = pd.DataFrame(portfolio_data)\n",
        "\n",
        "        with st.spinner(\"Loading...\"):\n",
        "            enhanced_df = create_enhanced_holdings_table(df)\n",
        "\n",
        "        total_value = enhanced_df['Total Value'].sum()\n",
        "        total_cost = enhanced_df['Total Cost'].sum()\n",
        "        total_gl = total_value - total_cost\n",
        "        total_gl_pct = (total_gl / total_cost) * 100 if total_cost > 0 else 0\n",
        "        daily_pl = enhanced_df['Daily P&L $'].sum()\n",
        "\n",
        "        col1, col2, col3, col4, col5 = st.columns(5)\n",
        "        col1.metric(\"Total Value\", format_currency(total_value))\n",
        "        col2.metric(\"Total Cost\", format_currency(total_cost))\n",
        "        col3.metric(\"Total G/L\", format_currency(total_gl), format_percentage(total_gl_pct))\n",
        "        col4.metric(\"Daily P&L\", format_currency(daily_pl))\n",
        "        col5.metric(\"Positions\", len(enhanced_df))\n",
        "\n",
        "        st.markdown(\"---\")\n",
        "        st.markdown(\"### üìã Holdings\")\n",
        "        display_df = style_holdings_dataframe(enhanced_df)\n",
        "        st.dataframe(display_df, use_container_width=True, hide_index=True, height=500)\n",
        "\n",
        "        st.info(\"üí° **Tip:** Head to the Valuation House to analyze intrinsic values of any ticker!\")\n",
        "\n",
        "        st.markdown(\"---\")\n",
        "        st.markdown(\"### üìä DASHBOARD OVERVIEW\")\n",
        "\n",
        "        # ENHANCED: Better layout with 2 rows\n",
        "        row1_col1, row1_col2 = st.columns([2, 1])\n",
        "\n",
        "        with row1_col1:\n",
        "            risk_reward = create_risk_reward_plot(enhanced_df)\n",
        "            if risk_reward:\n",
        "                st.plotly_chart(risk_reward, use_container_width=True)\n",
        "\n",
        "        with row1_col2:\n",
        "            sector_donut = create_sector_allocation_donut(enhanced_df)\n",
        "            if sector_donut:\n",
        "                st.plotly_chart(sector_donut, use_container_width=True)\n",
        "\n",
        "        # NEW: Second row with Contributors and Detractors\n",
        "        row2_col1, row2_col2 = st.columns(2)\n",
        "\n",
        "        with row2_col1:\n",
        "            contributors = create_top_contributors_chart(enhanced_df)\n",
        "            if contributors:\n",
        "                st.plotly_chart(contributors, use_container_width=True)\n",
        "\n",
        "        with row2_col2:\n",
        "            detractors = create_top_detractors_chart(enhanced_df)\n",
        "            if detractors:\n",
        "                st.plotly_chart(detractors, use_container_width=True)\n",
        "\n",
        "        # Performance Heatmap (full width)\n",
        "        st.markdown(\"---\")\n",
        "        perf_heatmap = create_performance_heatmap(enhanced_df)\n",
        "        if perf_heatmap:\n",
        "            st.plotly_chart(perf_heatmap, use_container_width=True)\n",
        "\n",
        "    # ========================================================================\n",
        "    # MARKET WATCH - COMPLETE REVAMP\n",
        "    # ========================================================================\n",
        "    elif page == \"üåç Market Watch\":\n",
        "        st.markdown(\"## üåç MARKET WATCH - EXCELLENCE EDITION\")\n",
        "        st.markdown(\"*Your comprehensive window into global markets, crypto, bonds, and credit conditions*\")\n",
        "\n",
        "        st.markdown(\"---\")\n",
        "        st.markdown(\"### üîç Filters & Settings\")\n",
        "        col1, col2, col3, col4 = st.columns(4)\n",
        "\n",
        "        with col1:\n",
        "            filter_change = st.slider(\"Min Change %\", -10.0, 10.0, -10.0)\n",
        "        with col2:\n",
        "            sort_by = st.selectbox(\"Sort By\", [\"Change %\", \"5D %\", \"Volume\"])\n",
        "        with col3:\n",
        "            refresh = st.button(\"üîÑ Refresh Data\")\n",
        "        with col4:\n",
        "            auto_refresh = st.checkbox(\"Auto-Refresh (5min)\")\n",
        "\n",
        "        st.markdown(\"---\")\n",
        "\n",
        "        # EXPANDED TABS\n",
        "        tab1, tab2, tab3, tab4, tab5, tab6, tab7 = st.tabs([\n",
        "            \"üìà Indices\",\n",
        "            \"üí∞ Crypto\",\n",
        "            \"üè¶ ETFs\",\n",
        "            \"‚ö° Commodities\",\n",
        "            \"üìä Stocks\",\n",
        "            \"üíµ Bonds & Rates\",\n",
        "            \"üéØ Credit Spreads\"\n",
        "        ])\n",
        "\n",
        "        with tab1:\n",
        "            st.markdown(\"#### üåç Global Indices\")\n",
        "            with st.spinner(\"Loading indices...\"):\n",
        "                indices_df = fetch_market_watch_data(GLOBAL_INDICES)\n",
        "                if not indices_df.empty:\n",
        "                    indices_df = indices_df[indices_df['Change %'] >= filter_change]\n",
        "                    display_df = create_dynamic_market_table(indices_df, {'sort_by': sort_by, 'ascending': False})\n",
        "                    st.dataframe(display_df, use_container_width=True, hide_index=True, height=600)\n",
        "                else:\n",
        "                    st.warning(\"No data available\")\n",
        "\n",
        "        with tab2:\n",
        "            st.markdown(\"#### ü™ô Cryptocurrency Markets\")\n",
        "            with st.spinner(\"Loading crypto...\"):\n",
        "                crypto_df = fetch_market_watch_data(CRYPTOCURRENCIES)\n",
        "                if not crypto_df.empty:\n",
        "                    crypto_df = crypto_df[crypto_df['Change %'] >= filter_change]\n",
        "                    display_df = create_dynamic_market_table(crypto_df, {'sort_by': sort_by, 'ascending': False})\n",
        "                    st.dataframe(display_df, use_container_width=True, hide_index=True, height=600)\n",
        "                else:\n",
        "                    st.warning(\"No data available\")\n",
        "\n",
        "        with tab3:\n",
        "            st.markdown(\"#### üì¶ Exchange-Traded Funds\")\n",
        "            sectors = st.multiselect(\"Filter by Category\",\n",
        "                                     [\"Broad Market\", \"Sector\", \"Thematic\", \"International\"],\n",
        "                                     default=[\"Broad Market\", \"Sector\", \"Thematic\"])\n",
        "\n",
        "            with st.spinner(\"Loading ETFs...\"):\n",
        "                etf_df = fetch_market_watch_data(POPULAR_ETFS)\n",
        "                if not etf_df.empty:\n",
        "                    if sectors:\n",
        "                        etf_df = etf_df[etf_df['Category'].isin(sectors)]\n",
        "                    display_df = create_dynamic_market_table(etf_df, {'sort_by': sort_by, 'ascending': False})\n",
        "                    st.dataframe(display_df, use_container_width=True, hide_index=True, height=600)\n",
        "                else:\n",
        "                    st.warning(\"No data available\")\n",
        "\n",
        "        with tab4:\n",
        "            st.markdown(\"#### ‚õΩ Commodity Markets\")\n",
        "            commodity_cats = st.multiselect(\"Filter by Type\",\n",
        "                                           [\"Precious Metals\", \"Energy\", \"Industrial Metals\", \"Agriculture\", \"Livestock\"],\n",
        "                                           default=[\"Precious Metals\", \"Energy\"])\n",
        "\n",
        "            with st.spinner(\"Loading commodities...\"):\n",
        "                comm_df = fetch_market_watch_data(COMMODITIES)\n",
        "                if not comm_df.empty:\n",
        "                    if commodity_cats:\n",
        "                        comm_df = comm_df[comm_df['Category'].isin(commodity_cats)]\n",
        "                    display_df = create_dynamic_market_table(comm_df, {'sort_by': sort_by, 'ascending': False})\n",
        "                    st.dataframe(display_df, use_container_width=True, hide_index=True, height=600)\n",
        "                else:\n",
        "                    st.warning(\"No data available\")\n",
        "\n",
        "        with tab5:\n",
        "            st.markdown(\"#### üìà Popular Stocks\")\n",
        "            stock_sectors = st.multiselect(\"Filter by Category\",\n",
        "                                          [\"Mega Cap Tech\", \"Financials\", \"Healthcare\", \"Consumer\", \"Energy\"],\n",
        "                                          default=[\"Mega Cap Tech\", \"Financials\"])\n",
        "\n",
        "            with st.spinner(\"Loading stocks...\"):\n",
        "                stocks_df = fetch_market_watch_data(POPULAR_STOCKS)\n",
        "                if not stocks_df.empty:\n",
        "                    if stock_sectors:\n",
        "                        stocks_df = stocks_df[stocks_df['Category'].isin(stock_sectors)]\n",
        "                    display_df = create_dynamic_market_table(stocks_df, {'sort_by': sort_by, 'ascending': False})\n",
        "                    st.dataframe(display_df, use_container_width=True, hide_index=True, height=600)\n",
        "                else:\n",
        "                    st.warning(\"No data available\")\n",
        "\n",
        "        with tab6:\n",
        "            st.markdown(\"#### üíµ Bond Yields & Treasury Rates\")\n",
        "            st.info(\"üìä **Key Insight:** Monitor the yield curve for recession signals and inflation expectations\")\n",
        "\n",
        "            with st.spinner(\"Loading bonds...\"):\n",
        "                bonds_df = fetch_market_watch_data(BOND_YIELDS)\n",
        "                if not bonds_df.empty:\n",
        "                    display_df = create_dynamic_market_table(bonds_df, {'sort_by': sort_by, 'ascending': False})\n",
        "                    st.dataframe(display_df, use_container_width=True, hide_index=True, height=400)\n",
        "                else:\n",
        "                    st.warning(\"No data available\")\n",
        "\n",
        "        with tab7:\n",
        "            st.markdown(\"#### üéØ Credit Spreads & Conditions\")\n",
        "            st.info(\"üí° **Key Insight:** Widening spreads signal deteriorating credit conditions and rising risk premiums\")\n",
        "\n",
        "            with st.spinner(\"Loading credit spreads...\"):\n",
        "                credit_df = fetch_market_watch_data(CREDIT_SPREADS)\n",
        "                if not credit_df.empty:\n",
        "                    display_df = create_dynamic_market_table(credit_df, {'sort_by': sort_by, 'ascending': False})\n",
        "                    st.dataframe(display_df, use_container_width=True, hide_index=True, height=400)\n",
        "\n",
        "                    st.markdown(\"---\")\n",
        "                    st.markdown(\"#### üìä Credit Market Interpretation\")\n",
        "                    st.markdown(\"\"\"\n",
        "                    **Investment Grade (LQD):** Corporate bonds rated BBB- or higher\n",
        "                    **High Yield (HYG):** \"Junk\" bonds with higher risk and return potential\n",
        "                    **Emerging Markets (EMB):** Sovereign and corporate debt from developing economies\n",
        "                    **TIPS (TIP):** Treasury Inflation-Protected Securities\n",
        "                    **MBS (MBB):** Mortgage-Backed Securities\n",
        "                    \"\"\")\n",
        "                else:\n",
        "                    st.warning(\"No data available\")\n",
        "\n",
        "    # Continue with remaining pages in next message...\n",
        "    # (Risk Analysis, Performance Suite, Portfolio Deep Dive, Multi-Factor, Valuation House, About)\n",
        "\n",
        "    # ========================================================================\n",
        "    # RISK ANALYSIS - WORLD CLASS\n",
        "    # ========================================================================\n",
        "    elif page == \"üìà Risk Analysis\":\n",
        "        st.markdown(\"## üìà RISK ANALYSIS - WORLD CLASS\")\n",
        "\n",
        "        portfolio_data = load_portfolio_data()\n",
        "\n",
        "        if not portfolio_data:\n",
        "            st.warning(\"‚ö†Ô∏è No portfolio data.\")\n",
        "            return\n",
        "\n",
        "        df = pd.DataFrame(portfolio_data)\n",
        "        enhanced_df = create_enhanced_holdings_table(df)\n",
        "\n",
        "        with st.spinner(\"Calculating...\"):\n",
        "            portfolio_returns = calculate_portfolio_returns(df, start_date, end_date)\n",
        "            benchmark_returns = calculate_benchmark_returns(selected_benchmark, start_date, end_date)\n",
        "\n",
        "            if not is_valid_series(portfolio_returns):\n",
        "                st.warning(\"Insufficient data\")\n",
        "                return\n",
        "\n",
        "            sharpe = calculate_sharpe_ratio(portfolio_returns)\n",
        "            sortino = calculate_sortino_ratio(portfolio_returns)\n",
        "            calmar = calculate_calmar_ratio(portfolio_returns)\n",
        "            var_95 = calculate_var(portfolio_returns, 0.95)\n",
        "            max_dd = calculate_max_drawdown(portfolio_returns)\n",
        "\n",
        "        col1, col2, col3, col4, col5 = st.columns(5)\n",
        "        col1.metric(\"Sharpe\", f\"{sharpe:.2f}\" if sharpe else \"N/A\")\n",
        "        col2.metric(\"Sortino\", f\"{sortino:.2f}\" if sortino else \"N/A\")\n",
        "        col3.metric(\"Calmar\", f\"{calmar:.2f}\" if calmar else \"N/A\")\n",
        "        col4.metric(\"VaR 95%\", format_percentage(var_95) if var_95 else \"N/A\")\n",
        "        col5.metric(\"Max DD\", format_percentage(max_dd) if max_dd else \"N/A\")\n",
        "\n",
        "        st.markdown(\"---\")\n",
        "\n",
        "        tab1, tab2, tab3, tab4 = st.tabs([\n",
        "            \"üìä Core Risk\", \"üé≤ Monte Carlo\", \"üî¨ Advanced Analytics\", \"‚ö° Stress Tests\"\n",
        "        ])\n",
        "\n",
        "        with tab1:\n",
        "            col1, col2 = st.columns(2)\n",
        "\n",
        "            with col1:\n",
        "                var_chart = create_var_waterfall(portfolio_returns)\n",
        "                if var_chart:\n",
        "                    st.plotly_chart(var_chart, use_container_width=True)\n",
        "\n",
        "                risk_parity = create_risk_parity_analysis(enhanced_df)\n",
        "                if risk_parity:\n",
        "                    st.plotly_chart(risk_parity, use_container_width=True)\n",
        "\n",
        "            with col2:\n",
        "                efficient = create_efficient_frontier(enhanced_df)\n",
        "                if efficient:\n",
        "                    st.plotly_chart(efficient, use_container_width=True)\n",
        "\n",
        "        with tab2:\n",
        "            simulations = run_monte_carlo_simulation(portfolio_returns)\n",
        "            if simulations is not None:\n",
        "                monte_carlo_chart, mc_stats = create_monte_carlo_chart(simulations, 100000)\n",
        "\n",
        "                if monte_carlo_chart:\n",
        "                    st.plotly_chart(monte_carlo_chart, use_container_width=True)\n",
        "\n",
        "                if mc_stats:\n",
        "                    st.markdown(\"#### üìä Simulation Results\")\n",
        "                    st.markdown(f\"\"\"\n",
        "                    **Key Statistics:**\n",
        "                    - Expected Value: ${mc_stats['mean']:,.2f}\n",
        "                    - Median: ${mc_stats['median']:,.2f}\n",
        "                    - Best Case (95th): ${mc_stats['percentile_95']:,.2f}\n",
        "                    - Worst Case (5th): ${mc_stats['percentile_5']:,.2f}\n",
        "                    - Prob of Profit: {mc_stats['prob_profit']:.1f}%\n",
        "                    \"\"\")\n",
        "\n",
        "        with tab3:\n",
        "            col1, col2 = st.columns(2)\n",
        "\n",
        "            with col1:\n",
        "                rolling = create_rolling_metrics_chart(portfolio_returns)\n",
        "                if rolling:\n",
        "                    st.plotly_chart(rolling, use_container_width=True)\n",
        "\n",
        "            with col2:\n",
        "                underwater = create_underwater_plot(portfolio_returns)\n",
        "                if underwater:\n",
        "                    st.plotly_chart(underwater, use_container_width=True)\n",
        "\n",
        "            sunburst = create_risk_contribution_sunburst(enhanced_df)\n",
        "            if sunburst:\n",
        "                st.plotly_chart(sunburst, use_container_width=True)\n",
        "\n",
        "            corr_network = create_correlation_network(enhanced_df, start_date, end_date)\n",
        "            if corr_network:\n",
        "                st.plotly_chart(corr_network, use_container_width=True)\n",
        "\n",
        "        with tab4:\n",
        "            st.info(\"Comprehensive stress testing scenarios...\")\n",
        "\n",
        "    # Continue with remaining pages...\n",
        "    # ========================================================================\n",
        "    # PERFORMANCE SUITE\n",
        "    # ========================================================================\n",
        "    elif page == \"üíé Performance Suite\":\n",
        "        st.markdown(\"## üíé PERFORMANCE SUITE\")\n",
        "\n",
        "        portfolio_data = load_portfolio_data()\n",
        "\n",
        "        if not portfolio_data:\n",
        "            st.warning(\"‚ö†Ô∏è No portfolio data.\")\n",
        "            return\n",
        "\n",
        "        df = pd.DataFrame(portfolio_data)\n",
        "        enhanced_df = create_enhanced_holdings_table(df)\n",
        "\n",
        "        with st.spinner(\"Calculating...\"):\n",
        "            portfolio_returns = calculate_portfolio_returns(df, start_date, end_date)\n",
        "            benchmark_returns = calculate_benchmark_returns(selected_benchmark, start_date, end_date)\n",
        "\n",
        "            metrics = None\n",
        "            if is_valid_series(portfolio_returns):\n",
        "                metrics = calculate_performance_metrics(enhanced_df, portfolio_returns, benchmark_returns)\n",
        "\n",
        "        tab1, tab2, tab3 = st.tabs([\"üìà Interactive Chart\", \"üìä Analytics\", \"üìã Metrics\"])\n",
        "\n",
        "        with tab1:\n",
        "            available_tickers = enhanced_df['Ticker'].tolist()\n",
        "\n",
        "            col1, col2 = st.columns([3, 1])\n",
        "            with col1:\n",
        "                selected_tickers = st.multiselect(\n",
        "                    \"Select Tickers\",\n",
        "                    options=available_tickers + [\"SPY\", \"QQQ\", \"VTI\"],\n",
        "                    default=available_tickers[:min(5, len(available_tickers))]\n",
        "                )\n",
        "\n",
        "            with col2:\n",
        "                custom_ticker = st.text_input(\"Add Custom\", placeholder=\"TSLA\")\n",
        "                if custom_ticker:\n",
        "                    selected_tickers.append(custom_ticker.upper())\n",
        "\n",
        "            if selected_tickers:\n",
        "                perf_chart = create_interactive_performance_chart(selected_tickers, start_date, end_date)\n",
        "                if perf_chart:\n",
        "                    st.plotly_chart(perf_chart, use_container_width=True)\n",
        "\n",
        "        with tab2:\n",
        "            if metrics:\n",
        "                dashboard = create_performance_dashboard(metrics)\n",
        "                st.plotly_chart(dashboard, use_container_width=True)\n",
        "\n",
        "        with tab3:\n",
        "            if metrics:\n",
        "                metrics_df = pd.DataFrame([\n",
        "                    ['Total Return', format_percentage(metrics['Total Return'])],\n",
        "                    ['Annualized Return', format_percentage(metrics['Annualized Return'])],\n",
        "                    ['Volatility', format_percentage(metrics['Annualized Volatility'])],\n",
        "                    ['Sharpe Ratio', f\"{metrics['Sharpe Ratio']:.3f}\"],\n",
        "                    ['Sortino Ratio', f\"{metrics['Sortino Ratio']:.3f}\"],\n",
        "                    ['Calmar Ratio', f\"{metrics['Calmar Ratio']:.3f}\"],\n",
        "                    ['VaR (95%)', format_percentage(metrics['VaR (95%)'])],\n",
        "                    ['Max Drawdown', format_percentage(metrics['Max Drawdown'])],\n",
        "                    ['Win Rate', format_percentage(metrics['Win Rate'])],\n",
        "                    ['Best Day', format_percentage(metrics['Best Day'])],\n",
        "                    ['Worst Day', format_percentage(metrics['Worst Day'])]\n",
        "                ], columns=['Metric', 'Value'])\n",
        "\n",
        "                st.dataframe(metrics_df, use_container_width=True, hide_index=True, height=600)\n",
        "\n",
        "    # ========================================================================\n",
        "    # PORTFOLIO DEEP DIVE - ENHANCED\n",
        "    # ========================================================================\n",
        "    elif page == \"üî¨ Portfolio Deep Dive\":\n",
        "        st.markdown(\"## üî¨ PORTFOLIO DEEP DIVE - ENHANCED\")\n",
        "\n",
        "        portfolio_data = load_portfolio_data()\n",
        "\n",
        "        if not portfolio_data:\n",
        "            st.warning(\"‚ö†Ô∏è No portfolio data.\")\n",
        "            return\n",
        "\n",
        "        df = pd.DataFrame(portfolio_data)\n",
        "        enhanced_df = create_enhanced_holdings_table(df)\n",
        "\n",
        "        tab1, tab2, tab3 = st.tabs([\n",
        "            \"üéØ Attribution\", \"üîÑ Sector Rotation\", \"üìä Concentration\"\n",
        "        ])\n",
        "\n",
        "        with tab1:\n",
        "            col1, col2 = st.columns(2)\n",
        "\n",
        "            with col1:\n",
        "                heatmap = create_portfolio_heatmap(enhanced_df)\n",
        "                if heatmap:\n",
        "                    st.plotly_chart(heatmap, use_container_width=True)\n",
        "\n",
        "            with col2:\n",
        "                waterfall = create_holdings_attribution_waterfall(enhanced_df)\n",
        "                if waterfall:\n",
        "                    st.plotly_chart(waterfall, use_container_width=True)\n",
        "\n",
        "        with tab2:\n",
        "            rotation = create_sector_rotation_heatmap(enhanced_df, start_date, end_date)\n",
        "            if rotation:\n",
        "                st.plotly_chart(rotation, use_container_width=True)\n",
        "\n",
        "        with tab3:\n",
        "            col1, col2 = st.columns([1, 2])\n",
        "\n",
        "            with col1:\n",
        "                gauge = create_concentration_gauge(enhanced_df)\n",
        "                if gauge:\n",
        "                    st.plotly_chart(gauge, use_container_width=True)\n",
        "\n",
        "            with col2:\n",
        "                # ENHANCED: Better concentration visual\n",
        "                conc_analysis = create_concentration_analysis(enhanced_df)\n",
        "                if conc_analysis:\n",
        "                    st.plotly_chart(conc_analysis, use_container_width=True)\n",
        "\n",
        "    # ========================================================================\n",
        "    # MULTI-FACTOR ANALYSIS - ENHANCED\n",
        "    # ========================================================================\n",
        "    elif page == \"üìä Multi-Factor Analysis\":\n",
        "        st.markdown(\"## üìä MULTI-FACTOR ANALYSIS - ENHANCED\")\n",
        "\n",
        "        portfolio_data = load_portfolio_data()\n",
        "\n",
        "        if not portfolio_data:\n",
        "            st.warning(\"‚ö†Ô∏è No portfolio data.\")\n",
        "            return\n",
        "\n",
        "        df = pd.DataFrame(portfolio_data)\n",
        "        enhanced_df = create_enhanced_holdings_table(df)\n",
        "\n",
        "        with st.spinner(\"Running analysis...\"):\n",
        "            factor_data = calculate_factor_exposures(enhanced_df, start_date, end_date)\n",
        "\n",
        "        if factor_data:\n",
        "            st.markdown(f\"**Model R¬≤ = {factor_data['r_squared']:.3f}**\")\n",
        "            st.progress(factor_data['r_squared'])\n",
        "\n",
        "            result = create_factor_attribution_table(factor_data, enhanced_df)\n",
        "\n",
        "            tab1, tab2, tab3 = st.tabs([\n",
        "                \"üìà Factor Momentum\", \"üéØ Exposure Radar\", \"üìä Attribution\"\n",
        "            ])\n",
        "\n",
        "            with tab1:\n",
        "                momentum = create_factor_momentum_chart(factor_data)\n",
        "                if momentum:\n",
        "                    st.plotly_chart(momentum, use_container_width=True)\n",
        "\n",
        "            with tab2:\n",
        "                radar = create_factor_exposure_radar(factor_data)\n",
        "                if radar:\n",
        "                    st.plotly_chart(radar, use_container_width=True)\n",
        "\n",
        "            with tab3:\n",
        "                if result is not None:\n",
        "                    attr_df, factor_summary, sector_summary = result\n",
        "\n",
        "                    if factor_summary is not None:\n",
        "                        st.markdown(\"### Factor Summary\")\n",
        "                        factor_display = factor_summary.copy()\n",
        "                        factor_display['Total Contribution'] = factor_display['Total Contribution'].apply(\n",
        "                            lambda x: f\"{x:.4f}\")\n",
        "                        st.dataframe(factor_display, use_container_width=True, hide_index=True)\n",
        "\n",
        "                    if attr_df is not None:\n",
        "                        st.markdown(\"### Holdings Attribution\")\n",
        "                        holdings_attr = attr_df.pivot_table(\n",
        "                            index='Ticker',\n",
        "                            columns='Factor',\n",
        "                            values='Contribution',\n",
        "                            aggfunc='sum'\n",
        "                        ).round(4)\n",
        "\n",
        "                        st.dataframe(holdings_attr, use_container_width=True)\n",
        "\n",
        "                        st.info(\"\"\"\n",
        "                        **Positive values**: Holding increases exposure\n",
        "                        **Negative values**: Holding decreases exposure\n",
        "                        \"\"\")\n",
        "        else:\n",
        "            st.error(\"Unable to calculate factor exposures.\")\n",
        "\n",
        "    # ========================================================================\n",
        "    # VALUATION HOUSE - ENHANCED WITH SMART ASSUMPTIONS\n",
        "    # ========================================================================\n",
        "    elif page == \"üí∞ Valuation House\":\n",
        "        st.markdown(\"## üí∞ VALUATION HOUSE - EXCELLENCE EDITION\")\n",
        "        st.markdown(\"### Professional DCF Valuation Engine with Smart Assumptions\")\n",
        "\n",
        "        st.info(\"üéØ **New Feature:** Toggle between Manual and Smart Assumptions for realistic valuations!\")\n",
        "\n",
        "        # Company Search\n",
        "        st.markdown(\"---\")\n",
        "        st.markdown(\"#### üîç Company Search\")\n",
        "\n",
        "        col1, col2 = st.columns([3, 1])\n",
        "\n",
        "        with col1:\n",
        "            ticker_input = st.text_input(\n",
        "                \"Enter Ticker Symbol\",\n",
        "                placeholder=\"e.g., AAPL, MSFT, GOOGL\",\n",
        "                help=\"Enter any publicly traded company ticker\"\n",
        "            ).upper()\n",
        "\n",
        "        with col2:\n",
        "            search_button = st.button(\"üöÄ Load Company\", type=\"primary\", use_container_width=True)\n",
        "\n",
        "        if search_button and ticker_input:\n",
        "            with st.spinner(f\"üìä Fetching data for {ticker_input}...\"):\n",
        "                company_data = fetch_company_financials(ticker_input)\n",
        "\n",
        "                if company_data['success']:\n",
        "                    st.session_state['valuation_company'] = company_data\n",
        "                    st.success(f\"‚úÖ Loaded {company_data['company']['name']}\")\n",
        "                else:\n",
        "                    st.error(f\"‚ùå Could not fetch data: {company_data.get('error', 'Unknown error')}\")\n",
        "\n",
        "        # Display valuation if company is loaded\n",
        "        if 'valuation_company' in st.session_state:\n",
        "            company = st.session_state['valuation_company']['company']\n",
        "            financials = st.session_state['valuation_company']['financials']\n",
        "\n",
        "            st.markdown(\"---\")\n",
        "\n",
        "            # Company Overview\n",
        "            st.markdown(f\"### üìä {company['name']} ({company['ticker']})\")\n",
        "\n",
        "            col1, col2, col3, col4, col5 = st.columns(5)\n",
        "            col1.metric(\"Current Price\", format_currency(company['current_price']))\n",
        "            col2.metric(\"Market Cap\", format_large_number(company['market_cap']))\n",
        "            col3.metric(\"Sector\", company['sector'])\n",
        "            col4.metric(\"Beta\", f\"{company['beta']:.2f}\")\n",
        "            col5.metric(\"Forward P/E\", f\"{company.get('forward_pe', 'N/A'):.1f}\" if company.get('forward_pe') else \"N/A\")\n",
        "\n",
        "            st.markdown(\"---\")\n",
        "\n",
        "            # DCF Method Selection\n",
        "            st.markdown(\"#### üéØ Valuation Method\")\n",
        "            dcf_method = st.radio(\n",
        "                \"Select DCF Method\",\n",
        "                options=['FCFF', 'FCFE'],\n",
        "                horizontal=True,\n",
        "                help=\"FCFF: Free Cash Flow to Firm | FCFE: Free Cash Flow to Equity\"\n",
        "            )\n",
        "\n",
        "            st.markdown(\"---\")\n",
        "\n",
        "            # NEW: Smart Assumptions Toggle\n",
        "            st.markdown(\"#### üß† Assumptions Mode\")\n",
        "\n",
        "            use_smart_assumptions = st.checkbox(\n",
        "                \"ü§ñ Use Smart Assumptions (AI-Generated)\",\n",
        "                help=\"Generate realistic assumptions based on sector averages, company size, and economic fundamentals\"\n",
        "            )\n",
        "\n",
        "            if use_smart_assumptions:\n",
        "                st.info(\"ü§ñ **Smart Mode Active:** Assumptions are generated based on sector benchmarks and economic reality\")\n",
        "                smart_params = calculate_smart_assumptions(company, financials)\n",
        "\n",
        "            # Assumptions Panel\n",
        "            st.markdown(\"---\")\n",
        "            st.markdown(\"#### üéõÔ∏è Valuation Assumptions\")\n",
        "\n",
        "            tab1, tab2, tab3 = st.tabs([\"üìà Growth & Operations\", \"üí∞ Cost of Capital\", \"üéØ Terminal Value\"])\n",
        "\n",
        "            with tab1:\n",
        "                st.markdown(\"##### Growth & Operating Assumptions\")\n",
        "\n",
        "                col1, col2 = st.columns(2)\n",
        "\n",
        "                with col1:\n",
        "                    if use_smart_assumptions:\n",
        "                        revenue_growth = smart_params['revenue_growth']\n",
        "                        st.metric(\"Revenue Growth Rate\", f\"{revenue_growth*100:.1f}%\",\n",
        "                                 delta=\"AI Generated\", delta_color=\"normal\")\n",
        "                    else:\n",
        "                        revenue_growth = st.slider(\n",
        "                            \"Revenue Growth Rate (%)\",\n",
        "                            min_value=-10.0,\n",
        "                            max_value=30.0,\n",
        "                            value=5.0,\n",
        "                            step=0.5\n",
        "                        ) / 100\n",
        "\n",
        "                    if use_smart_assumptions:\n",
        "                        ebit_margin = smart_params['ebit_margin']\n",
        "                        st.metric(\"EBIT Margin\", f\"{ebit_margin*100:.1f}%\",\n",
        "                                 delta=\"AI Generated\", delta_color=\"normal\")\n",
        "                    else:\n",
        "                        ebit_margin = st.slider(\n",
        "                            \"EBIT Margin (%)\",\n",
        "                            min_value=0.0,\n",
        "                            max_value=50.0,\n",
        "                            value=20.0,\n",
        "                            step=1.0\n",
        "                        ) / 100\n",
        "\n",
        "                    forecast_years = st.slider(\n",
        "                        \"Forecast Horizon (Years)\",\n",
        "                        min_value=3,\n",
        "                        max_value=15,\n",
        "                        value=smart_params['forecast_years'] if use_smart_assumptions else 5,\n",
        "                        step=1\n",
        "                    )\n",
        "\n",
        "                with col2:\n",
        "                    if use_smart_assumptions:\n",
        "                        capex_pct = smart_params['capex_pct']\n",
        "                        st.metric(\"CapEx (% of Revenue)\", f\"{capex_pct*100:.1f}%\",\n",
        "                                 delta=\"AI Generated\", delta_color=\"normal\")\n",
        "                    else:\n",
        "                        capex_pct = st.slider(\n",
        "                            \"CapEx (% of Revenue)\",\n",
        "                            min_value=0.0,\n",
        "                            max_value=20.0,\n",
        "                            value=5.0,\n",
        "                            step=0.5\n",
        "                        ) / 100\n",
        "\n",
        "                    if use_smart_assumptions:\n",
        "                        depreciation_pct = smart_params['depreciation_pct']\n",
        "                        st.metric(\"Depreciation (% of Revenue)\", f\"{depreciation_pct*100:.1f}%\",\n",
        "                                 delta=\"AI Generated\", delta_color=\"normal\")\n",
        "                    else:\n",
        "                        depreciation_pct = st.slider(\n",
        "                            \"Depreciation (% of Revenue)\",\n",
        "                            min_value=0.0,\n",
        "                            max_value=15.0,\n",
        "                            value=3.0,\n",
        "                            step=0.5\n",
        "                        ) / 100\n",
        "\n",
        "                    wc_change = st.number_input(\n",
        "                        \"Working Capital Change ($M)\",\n",
        "                        min_value=-1000.0,\n",
        "                        max_value=1000.0,\n",
        "                        value=smart_params['wc_change'] if use_smart_assumptions else 0.0,\n",
        "                        step=10.0\n",
        "                    ) * 1e6\n",
        "\n",
        "            with tab2:\n",
        "                st.markdown(\"##### Cost of Capital Assumptions\")\n",
        "\n",
        "                col1, col2 = st.columns(2)\n",
        "\n",
        "                with col1:\n",
        "                    risk_free = st.slider(\n",
        "                        \"Risk-Free Rate (%)\",\n",
        "                        min_value=0.0,\n",
        "                        max_value=10.0,\n",
        "                        value=4.5,\n",
        "                        step=0.1\n",
        "                    ) / 100\n",
        "\n",
        "                    market_risk_premium = st.slider(\n",
        "                        \"Market Risk Premium (%)\",\n",
        "                        min_value=3.0,\n",
        "                        max_value=10.0,\n",
        "                        value=6.0,\n",
        "                        step=0.5\n",
        "                    ) / 100\n",
        "\n",
        "                    beta = st.number_input(\n",
        "                        \"Beta\",\n",
        "                        min_value=0.0,\n",
        "                        max_value=3.0,\n",
        "                        value=float(company['beta']) if company['beta'] else 1.0,\n",
        "                        step=0.1\n",
        "                    )\n",
        "\n",
        "                with col2:\n",
        "                    if dcf_method == 'FCFF':\n",
        "                        cost_debt = st.slider(\n",
        "                            \"Cost of Debt (%)\",\n",
        "                            min_value=0.0,\n",
        "                            max_value=15.0,\n",
        "                            value=5.0,\n",
        "                            step=0.5\n",
        "                        ) / 100\n",
        "\n",
        "                    if use_smart_assumptions:\n",
        "                        tax_rate = smart_params['tax_rate']\n",
        "                        st.metric(\"Tax Rate\", f\"{tax_rate*100:.1f}%\",\n",
        "                                 delta=\"AI Generated\", delta_color=\"normal\")\n",
        "                    else:\n",
        "                        tax_rate = st.slider(\n",
        "                            \"Tax Rate (%)\",\n",
        "                            min_value=0.0,\n",
        "                            max_value=40.0,\n",
        "                            value=float(financials.get('tax_rate', 0.21) * 100),\n",
        "                            step=1.0\n",
        "                        ) / 100\n",
        "\n",
        "                    if dcf_method == 'FCFE':\n",
        "                        net_borrowing = st.number_input(\n",
        "                            \"Net Borrowing ($M)\",\n",
        "                            min_value=-1000.0,\n",
        "                            max_value=1000.0,\n",
        "                            value=0.0,\n",
        "                            step=10.0\n",
        "                        ) * 1e6\n",
        "\n",
        "            with tab3:\n",
        "                st.markdown(\"##### Terminal Value Assumptions\")\n",
        "\n",
        "                col1, col2 = st.columns(2)\n",
        "\n",
        "                with col1:\n",
        "                    if use_smart_assumptions:\n",
        "                        terminal_growth = smart_params['terminal_growth']\n",
        "                        st.metric(\"Perpetual Growth Rate\", f\"{terminal_growth*100:.1f}%\",\n",
        "                                 delta=\"AI Generated\", delta_color=\"normal\")\n",
        "                    else:\n",
        "                        terminal_growth = st.slider(\n",
        "                            \"Perpetual Growth Rate (%)\",\n",
        "                            min_value=0.0,\n",
        "                            max_value=5.0,\n",
        "                            value=2.5,\n",
        "                            step=0.1\n",
        "                        ) / 100\n",
        "\n",
        "                with col2:\n",
        "                    st.info(f\"\"\"\n",
        "                    **Terminal Value Method:** Gordon Growth Model\n",
        "\n",
        "                    TV = FCF‚Çô‚Çä‚ÇÅ / (r - g)\n",
        "                    \"\"\")\n",
        "\n",
        "            st.markdown(\"---\")\n",
        "\n",
        "            # Calculate DCF\n",
        "            if st.button(\"üöÄ Calculate Intrinsic Value\", type=\"primary\", use_container_width=True):\n",
        "                with st.spinner(\"üî¨ Running DCF Analysis...\"):\n",
        "\n",
        "                    # Calculate cost of equity\n",
        "                    cost_equity = calculate_cost_of_equity(risk_free, beta, market_risk_premium)\n",
        "\n",
        "                    # Calculate discount rate\n",
        "                    if dcf_method == 'FCFF':\n",
        "                        total_debt = financials.get('total_debt', 0)\n",
        "                        total_equity = company['market_cap']\n",
        "                        discount_rate = calculate_wacc(cost_equity, cost_debt, tax_rate, total_debt, total_equity)\n",
        "                    else:\n",
        "                        discount_rate = cost_equity\n",
        "\n",
        "                    # Get base financials\n",
        "                    base_revenue = financials.get('revenue', 0)\n",
        "                    base_ebit = financials.get('ebit', 0)\n",
        "                    base_net_income = financials.get('net_income', 0)\n",
        "\n",
        "                    # ENHANCED: Project cash flows with scaling D&A and CapEx\n",
        "                    if dcf_method == 'FCFF':\n",
        "                        projections = project_fcff_enhanced(\n",
        "                            base_revenue, base_ebit, revenue_growth, ebit_margin, tax_rate,\n",
        "                            depreciation_pct, capex_pct, wc_change, forecast_years\n",
        "                        )\n",
        "                        final_fcf = projections[-1]['fcff']\n",
        "                    else:\n",
        "                        projections = project_fcfe_enhanced(\n",
        "                            base_revenue, base_net_income, revenue_growth, tax_rate,\n",
        "                            depreciation_pct, capex_pct, wc_change, net_borrowing, forecast_years\n",
        "                        )\n",
        "                        final_fcf = projections[-1]['fcfe']\n",
        "\n",
        "                    # Calculate terminal value\n",
        "                    terminal_value = calculate_terminal_value(final_fcf, discount_rate, terminal_growth)\n",
        "\n",
        "                    # Calculate DCF value\n",
        "                    net_debt = financials.get('total_debt', 0) - financials.get('cash', 0)\n",
        "                    shares = company['shares_outstanding']\n",
        "\n",
        "                    dcf_results = calculate_dcf_value(\n",
        "                        projections, discount_rate, terminal_value, shares,\n",
        "                        net_debt if dcf_method == 'FCFF' else 0, dcf_method\n",
        "                    )\n",
        "\n",
        "                    dcf_results['net_debt'] = net_debt\n",
        "\n",
        "                    # Store results\n",
        "                    st.session_state['dcf_results'] = dcf_results\n",
        "                    st.session_state['dcf_projections'] = projections\n",
        "                    st.session_state['dcf_method'] = dcf_method\n",
        "                    st.session_state['discount_rate'] = discount_rate\n",
        "                    st.session_state['terminal_growth'] = terminal_growth\n",
        "                    st.session_state['used_smart_assumptions'] = use_smart_assumptions\n",
        "\n",
        "                    st.success(\"‚úÖ Valuation Complete!\")\n",
        "\n",
        "            # Display Results\n",
        "            if 'dcf_results' in st.session_state:\n",
        "                results = st.session_state['dcf_results']\n",
        "                projections = st.session_state['dcf_projections']\n",
        "                method = st.session_state['dcf_method']\n",
        "\n",
        "                st.markdown(\"---\")\n",
        "                st.markdown(\"### üìä Valuation Results\")\n",
        "\n",
        "                if st.session_state.get('used_smart_assumptions', False):\n",
        "                    st.success(\"ü§ñ **These results used AI-Generated Smart Assumptions**\")\n",
        "\n",
        "                # Key metrics\n",
        "                intrinsic_value = results['intrinsic_value_per_share']\n",
        "                current_price = company['current_price']\n",
        "                upside_downside = ((intrinsic_value - current_price) / current_price) * 100\n",
        "\n",
        "                col1, col2, col3, col4 = st.columns(4)\n",
        "\n",
        "                col1.metric(\n",
        "                    \"Intrinsic Value\",\n",
        "                    format_currency(intrinsic_value),\n",
        "                    delta=format_percentage(upside_downside) if abs(upside_downside) < 1000 else \"¬±‚àû\"\n",
        "                )\n",
        "\n",
        "                col2.metric(\"Current Price\", format_currency(current_price))\n",
        "\n",
        "                col3.metric(\n",
        "                    \"Upside/Downside\",\n",
        "                    format_percentage(upside_downside) if abs(upside_downside) < 1000 else \"¬±‚àû\",\n",
        "                    delta=\"Undervalued\" if upside_downside > 0 else \"Overvalued\"\n",
        "                )\n",
        "\n",
        "                col4.metric(\"Discount Rate\", format_percentage(st.session_state['discount_rate'] * 100))\n",
        "\n",
        "                # Valuation interpretation\n",
        "                st.markdown(\"---\")\n",
        "\n",
        "                if upside_downside > 20:\n",
        "                    st.success(f\"\"\"\n",
        "                    ‚úÖ **Significantly Undervalued**\n",
        "\n",
        "                    The intrinsic value suggests the stock is trading at a {abs(upside_downside):.1f}% discount to fair value.\n",
        "                    \"\"\")\n",
        "                elif upside_downside > 0:\n",
        "                    st.info(f\"\"\"\n",
        "                    üìä **Slightly Undervalued**\n",
        "\n",
        "                    Modest upside potential of {upside_downside:.1f}%.\n",
        "                    \"\"\")\n",
        "                elif upside_downside > -20:\n",
        "                    st.warning(f\"\"\"\n",
        "                    ‚ö†Ô∏è **Slightly Overvalued**\n",
        "\n",
        "                    Trading {abs(upside_downside):.1f}% above fair value.\n",
        "                    \"\"\")\n",
        "                else:\n",
        "                    st.error(f\"\"\"\n",
        "                    ‚ùå **Significantly Overvalued**\n",
        "\n",
        "                    Trading at a {abs(upside_downside):.1f}% premium to fair value.\n",
        "                    \"\"\")\n",
        "\n",
        "                st.markdown(\"---\")\n",
        "\n",
        "                # Visualizations\n",
        "                col1, col2 = st.columns(2)\n",
        "\n",
        "                with col1:\n",
        "                    waterfall = create_dcf_waterfall(results, method)\n",
        "                    st.plotly_chart(waterfall, use_container_width=True)\n",
        "\n",
        "                with col2:\n",
        "                    cf_chart = create_cash_flow_chart(projections, method)\n",
        "                    st.plotly_chart(cf_chart, use_container_width=True)\n",
        "\n",
        "                # Sensitivity Analysis\n",
        "                st.markdown(\"---\")\n",
        "                st.markdown(\"#### üéØ Sensitivity Analysis\")\n",
        "\n",
        "                sensitivity = create_sensitivity_table(\n",
        "                    intrinsic_value,\n",
        "                    st.session_state['discount_rate'],\n",
        "                    st.session_state['terminal_growth']\n",
        "                )\n",
        "                st.plotly_chart(sensitivity, use_container_width=True)\n",
        "\n",
        "                # Detailed Projections Table\n",
        "                st.markdown(\"---\")\n",
        "                st.markdown(\"#### üìã Detailed Cash Flow Projections\")\n",
        "\n",
        "                proj_df = pd.DataFrame(projections)\n",
        "\n",
        "                # Format for display\n",
        "                if method == 'FCFF':\n",
        "                    display_cols = ['year', 'revenue', 'ebit', 'nopat', 'depreciation', 'capex', 'change_wc', 'fcff']\n",
        "                    col_names = ['Year', 'Revenue', 'EBIT', 'NOPAT', 'D&A', 'CapEx', 'ŒîWC', 'FCFF']\n",
        "                else:\n",
        "                    display_cols = ['year', 'revenue', 'net_income', 'depreciation', 'capex', 'change_wc', 'net_borrowing', 'fcfe']\n",
        "                    col_names = ['Year', 'Revenue', 'Net Income', 'D&A', 'CapEx', 'ŒîWC', 'Borrowing', 'FCFE']\n",
        "\n",
        "                proj_display = proj_df[display_cols].copy()\n",
        "                proj_display.columns = col_names\n",
        "\n",
        "                # Format numbers\n",
        "                for col in proj_display.columns:\n",
        "                    if col != 'Year':\n",
        "                        proj_display[col] = proj_display[col].apply(format_large_number)\n",
        "\n",
        "                st.dataframe(proj_display, use_container_width=True, hide_index=True)\n",
        "\n",
        "                st.success(\"‚úÖ **Notice:** D&A and CapEx scale with revenue growth (as they should!)\")\n",
        "\n",
        "                # Export Options\n",
        "                st.markdown(\"---\")\n",
        "                col1, col2, col3 = st.columns(3)\n",
        "\n",
        "                with col1:\n",
        "                    if st.button(\"üì• Export to Excel\", use_container_width=True):\n",
        "                        st.info(\"Excel export feature coming soon!\")\n",
        "\n",
        "                with col2:\n",
        "                    if st.button(\"üìÑ Generate PDF Report\", use_container_width=True):\n",
        "                        st.info(\"PDF export feature coming soon!\")\n",
        "\n",
        "                with col3:\n",
        "                    if st.button(\"üîÑ Reset Valuation\", use_container_width=True):\n",
        "                        for key in ['dcf_results', 'dcf_projections', 'used_smart_assumptions']:\n",
        "                            if key in st.session_state:\n",
        "                                del st.session_state[key]\n",
        "                        st.rerun()\n",
        "\n",
        "        else:\n",
        "            # No company loaded\n",
        "            st.markdown(\"---\")\n",
        "            st.markdown(\"\"\"\n",
        "            ### üìö How to Use Valuation House - Excellence Edition\n",
        "\n",
        "            **NEW in v9.3: ü§ñ Smart Assumptions Mode**\n",
        "            - AI-generated assumptions based on sector benchmarks\n",
        "            - Realistic, economically grounded projections\n",
        "            - Toggle between manual and smart modes\n",
        "\n",
        "            **Step 1:** Search for any publicly traded company\n",
        "            **Step 2:** Choose FCFF or FCFE valuation method\n",
        "            **Step 3:** Enable Smart Assumptions or customize manually\n",
        "            **Step 4:** Calculate intrinsic value and analyze results\n",
        "            **Step 5:** Review sensitivity analysis\n",
        "\n",
        "            ---\n",
        "\n",
        "            ### ‚ú® What's New in v9.3 Excellence\n",
        "\n",
        "            ‚úÖ **Smart Assumptions:** AI-powered realistic assumptions\n",
        "            ‚úÖ **Fixed Scaling:** D&A and CapEx properly scale with revenue\n",
        "            ‚úÖ **Enhanced Visuals:** Seamless dark mode theming\n",
        "            ‚úÖ **Better Analysis:** More comprehensive sensitivity testing\n",
        "\n",
        "            *Ready to start? Enter a ticker symbol above!* üöÄ\n",
        "            \"\"\")\n",
        "\n",
        "    # ========================================================================\n",
        "    # ABOUT\n",
        "    # ========================================================================\n",
        "    elif page == \"‚ÑπÔ∏è About\":\n",
        "        st.markdown(\"### ‚ÑπÔ∏è ATLAS Terminal v9.3 EXCELLENCE EDITION\")\n",
        "        st.success(\"\"\"\n",
        "        **ATLAS v9.3 EXCELLENCE EDITION** üî•üíé\n",
        "\n",
        "        **EXCELLENCE ENHANCEMENTS:**\n",
        "        ‚úÖ Enhanced Home Page (Top Contributors/Detractors + Better Layout)\n",
        "        ‚úÖ Market Watch COMPLETE REVAMP (Crypto, Bonds, Spreads, 100+ Assets)\n",
        "        ‚úÖ ALL Charts Seamlessly Themed (No More Black Boxes!)\n",
        "        ‚úÖ Portfolio Deep Dive Enhanced (Better Concentration Analysis)\n",
        "        ‚úÖ Valuation House: Smart Assumptions Mode (AI-Generated)\n",
        "        ‚úÖ Valuation House: Fixed D&A/CapEx Scaling with Revenue\n",
        "        ‚úÖ Fixed Nov 2024 Columns in All Heatmaps\n",
        "        ‚úÖ Multi-Factor Analysis (Perfect - No Changes Needed!)\n",
        "\n",
        "        **COMPLETE MODULE LIST:**\n",
        "        1. **Phoenix Parser** - Exceptional data parsing\n",
        "        2. **Portfolio Home** - Enhanced dashboard with contributors/detractors\n",
        "        3. **Market Watch** - Comprehensive: Indices, Crypto, Bonds, Spreads, ETFs, Stocks, Commodities\n",
        "        4. **Risk Analysis** - World-class metrics & visualizations\n",
        "        5. **Performance Suite** - Comprehensive analytics\n",
        "        6. **Portfolio Deep Dive** - Enhanced concentration analysis\n",
        "        7. **Multi-Factor Analysis** - Advanced attribution (kept perfect!)\n",
        "        8. **Valuation House** - Smart Assumptions + Enhanced DCF\n",
        "\n",
        "        **KEY FEATURES:**\n",
        "        - ü§ñ Smart Assumptions for DCF valuations\n",
        "        - üåç Expanded Market Watch (150+ assets)\n",
        "        - üìä Seamless chart theming throughout\n",
        "        - üéØ Enhanced Home Page dashboard\n",
        "        - üíé Fixed D&A/CapEx scaling\n",
        "        - ‚ú® All original features preserved\n",
        "\n",
        "        **WHAT'S FIXED IN v9.3:**\n",
        "        - ‚úÖ All charts blend with dark background\n",
        "        - ‚úÖ Nov 2024 incomplete month columns removed\n",
        "        - ‚úÖ D&A and CapEx scale properly with revenue\n",
        "        - ‚úÖ Home Page layout optimized\n",
        "        - ‚úÖ Market Watch massively expanded\n",
        "        - ‚úÖ Concentration analysis enhanced\n",
        "\n",
        "        Total: **The Ultimate Investment Analysis Platform - Now EXCELLENT!** üöÄ\n",
        "        \"\"\")\n",
        "\n",
        "if __name__ == \"__main__\":\n",
        "    main()\n",
        "    ''')\n",
        "\n",
        "print(\"‚úÖ atlas_app.py saved!\")"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "UKoJdd4t-8aU",
        "outputId": "fb9ade5e-bd1e-4bc2-d9b3-dc9e6f680359"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "üöÄ Launching ATLAS v9.3...\n",
            "\n",
            "‚úÖ ATLAS IS LIVE!\n",
            "üåê Access at: NgrokTunnel: \"https://venus-unnauseated-superofficiously.ngrok-free.dev\" -> \"http://localhost:8501\"\n",
            "\n"
          ]
        }
      ],
      "source": [
        "import os\n",
        "import time\n",
        "import threading\n",
        "from pyngrok import ngrok\n",
        "\n",
        "if not os.path.exists('atlas_app.py'):\n",
        "    raise FileNotFoundError(\"‚ùå atlas_app.py not found! Run Step 2 first.\")\n",
        "\n",
        "print(\"üöÄ Launching ATLAS v9.3...\")\n",
        "ngrok.set_auth_token(\"3560NW1Q6pfr5LKXYCFxvt6JnAI_39PX8PaW3aGqhTTr2yo2M\")\n",
        "\n",
        "def run_streamlit():\n",
        "    os.system(\"streamlit run atlas_app.py --server.port 8501 --server.headless true\")\n",
        "\n",
        "threading.Thread(target=run_streamlit, daemon=True).start()\n",
        "time.sleep(10)\n",
        "\n",
        "public_url = ngrok.connect(8501)\n",
        "print(f\"\\n‚úÖ ATLAS IS LIVE!\\nüåê Access at: {public_url}\\n\")\n",
        "\n",
        "while True:\n",
        "    time.sleep(1)"
      ]
    }
  ],
  "metadata": {
    "colab": {
      "provenance": [],
      "authorship_tag": "ABX9TyNBrwYNx0ppjJ6wgtcJrmcY",
      "include_colab_link": true
    },
    "kernelspec": {
      "display_name": "Python 3",
      "name": "python3"
    },
    "language_info": {
      "name": "python"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 0
}